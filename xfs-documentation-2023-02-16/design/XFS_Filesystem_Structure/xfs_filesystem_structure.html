<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>XFS Algorithms &amp; Data Structures</title><link rel="stylesheet" type="text/css" href="docbook-xsl.css" /><meta name="generator" content="DocBook XSL Stylesheets V1.79.1" /></head><body><div xml:lang="en" class="book" lang="en"><div class="titlepage"><div><div><h1 class="title"><a id="idm1"></a>XFS Algorithms &amp; Data Structures</h1></div><div><h2 class="subtitle">3rd Edition</h2></div><div><h3 class="corpauthor">
</h3></div><div><p class="copyright">Copyright © 2006 Silicon Graphics Inc.</p></div><div><div class="legalnotice"><a id="idm9"></a><p>© Copyright 2006 Silicon Graphics Inc. All rights reserved.  Permission is granted to copy, distribute, and/or modify this document under the terms of the Creative Commons Attribution-Share Alike, Version 3.0 or any later version published by the Creative Commons Corp. A copy of the license is available at <a class="ulink" href="http://creativecommons.org/licenses/by-sa/3.0/us/" target="_top">http://creativecommons.org/licenses/by-sa/3.0/us/</a>.</p></div></div><div><div class="revhistory"><table style="border-style:solid; width:100%;" summary="Revision History"><tr><th align="left" valign="top" colspan="3"><strong>Revision History</strong></th></tr><tr><td align="left">Revision 0.1</td><td align="left">2006</td><td align="left"><span class="firstname">Silicon Graphics, Inc<br /></span><span class="surname"><br /></span><code class="email">&lt;<a class="email" href="mailto:"></a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>Initial Release</td></tr></table>
                </td></tr><tr><td align="left">Revision 1.0</td><td align="left">Fri Jul 03 2009</td><td align="left"><span class="firstname">Ryan<br /></span><span class="surname">Lerch<br /></span><code class="email">&lt;<a class="email" href="mailto:"></a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>Publican Conversion</td></tr></table>
                </td></tr><tr><td align="left">Revision 1.1</td><td align="left">March 2010</td><td align="left"><span class="firstname">Eric<br /></span><span class="surname">Sandeen<br /></span><code class="email">&lt;<a class="email" href="mailto:"></a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>Community Release</td></tr></table>
                </td></tr><tr><td align="left">Revision 1.99</td><td align="left">February 2014</td><td align="left"><span class="firstname">Dave<br /></span><span class="surname">Chinner<br /></span><code class="email">&lt;<a class="email" href="mailto:"></a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>AsciiDoc Conversion</td></tr></table>
                </td></tr><tr><td align="left">Revision 3</td><td align="left">October 2015</td><td align="left"><span class="firstname">Darrick<br /></span><span class="surname">Wong<br /></span><code class="email">&lt;<a class="email" href="mailto:"></a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>Miscellaneous fixes.</td></tr><tr><td>Add missing field definitions.</td></tr><tr><td>Add some missing xfs_db examples.</td></tr><tr><td>Add an overview of XFS.</td></tr><tr><td>Document the journal format.</td></tr><tr><td>Document the realtime device.</td></tr></table>
                </td></tr><tr><td align="left">Revision 3.1</td><td align="left">October 2015</td><td align="left"><span class="firstname">Darrick<br /></span><span class="surname">Wong<br /></span><code class="email">&lt;<a class="email" href="mailto:"></a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>Add v5 fields.</td></tr><tr><td>Discuss metadata integrity.</td></tr><tr><td>Document the free inode B+tree.</td></tr><tr><td>Create an index of magic numbers.</td></tr><tr><td>Document sparse inodes.</td></tr></table>
                </td></tr><tr><td align="left">Revision 3.14</td><td align="left">January 2016</td><td align="left"><span class="firstname">Darrick<br /></span><span class="surname">Wong<br /></span><code class="email">&lt;<a class="email" href="mailto:"></a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>Document disk format change testing.</td></tr></table>
                </td></tr><tr><td align="left">Revision 3.141</td><td align="left">June 2016</td><td align="left"><span class="firstname">Darrick<br /></span><span class="surname">Wong<br /></span><code class="email">&lt;<a class="email" href="mailto:"></a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>Document the reverse-mapping btree.</td></tr><tr><td>Move the b+tree info to a separate chapter.</td></tr><tr><td>Discuss overlapping interval b+trees.</td></tr><tr><td>Discuss new log items for atomic updates.</td></tr><tr><td>Document the reference-count btree.</td></tr><tr><td>Discuss block sharing, reflink, &amp; deduplication.</td></tr></table>
                </td></tr><tr><td align="left">Revision 3.1415</td><td align="left">July 2016</td><td align="left"><span class="firstname">Darrick<br /></span><span class="surname">Wong<br /></span><code class="email">&lt;<a class="email" href="mailto:"></a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>Document the real-time reverse-mapping btree.</td></tr></table>
                </td></tr><tr><td align="left">Revision 3.14159</td><td align="left">June 2017</td><td align="left"><span class="firstname">Darrick<br /></span><span class="surname">Wong<br /></span><code class="email">&lt;<a class="email" href="mailto:darrick.wong@oracle.com">darrick.wong@oracle.com</a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>Add the metadump file format.</td></tr></table>
                </td></tr><tr><td align="left">Revision 3.141592</td><td align="left">May 2018</td><td align="left"><span class="firstname">Darrick<br /></span><span class="surname">Wong<br /></span><code class="email">&lt;<a class="email" href="mailto:darrick.wong@oracle.com">darrick.wong@oracle.com</a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>Incorporate Dave Chinner's log design document.</td></tr><tr><td>Incorporate Dave Chinner's self-describing metadata design document.</td></tr></table>
                </td></tr><tr><td align="left">Revision 3.1415926</td><td align="left">April 2021</td><td align="left"><span class="firstname">Darrick<br /></span><span class="surname">Wong<br /></span><code class="email">&lt;<a class="email" href="mailto:djwong@kernel.org">djwong@kernel.org</a>&gt;</code></td></tr><tr><td align="left" colspan="3">
                        <table border="0" summary="Simple list" class="simplelist"><tr><td>Document the needsrepair, bigtime, and inobtcount features.</td></tr></table>
                </td></tr></table></div></div></div><hr /></div><div class="toc"><p><strong>Table of Contents</strong></p><dl class="toc"><dt><span class="part"><a href="#_high_level_design">I. High Level Design</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_overview">1. Overview</a></span></dt><dt><span class="chapter"><a href="#_metadata_integrity">2. Metadata Integrity</a></span></dt><dd><dl><dt><span class="section"><a href="#_introduction">2.1. Introduction</a></span></dt><dt><span class="section"><a href="#_self_describing_metadata">2.2. Self Describing Metadata</a></span></dt><dt><span class="section"><a href="#_runtime_validation">2.3. Runtime Validation</a></span></dt><dt><span class="section"><a href="#_structures">2.4. Structures</a></span></dt><dt><span class="section"><a href="#_inodes_and_dquots">2.5. Inodes and Dquots</a></span></dt></dl></dd><dt><span class="chapter"><a href="#_delayed_logging">3. Delayed Logging</a></span></dt><dd><dl><dt><span class="section"><a href="#_introduction_to_re_logging_in_xfs">3.1. Introduction to Re-logging in XFS</a></span></dt><dt><span class="section"><a href="#_delayed_logging_concepts">3.2. Delayed Logging Concepts</a></span></dt><dt><span class="section"><a href="#_delayed_logging_design">3.3. Delayed Logging Design</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Reflink_Deduplication">4. Sharing Data Blocks</a></span></dt><dt><span class="chapter"><a href="#Reconstruction">5. Metadata Reconstruction</a></span></dt><dt><span class="chapter"><a href="#_common_xfs_types">6. Common XFS Types</a></span></dt><dt><span class="chapter"><a href="#_magic_numbers">7. Magic Numbers</a></span></dt><dt><span class="chapter"><a href="#_theoretical_limits">8. Theoretical Limits</a></span></dt><dt><span class="chapter"><a href="#Testing">9. Testing Filesystem Changes</a></span></dt></dl></dd><dt><span class="part"><a href="#_global_structures">II. Global Structures</a></span></dt><dd><dl><dt><span class="chapter"><a href="#_fixed_length_record_b_trees">10. Fixed Length Record B+trees</a></span></dt><dd><dl><dt><span class="section"><a href="#Short_Format_Btrees">10.1. Short Format B+trees</a></span></dt><dt><span class="section"><a href="#Long_Format_Btrees">10.2. Long Format B+trees</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Directory_Attribute_Btree">11. Variable Length Record B+trees</a></span></dt><dd><dl><dt><span class="section"><a href="#Directory_Attribute_Block_Header">11.1. Block Headers</a></span></dt><dt><span class="section"><a href="#Directory_Attribute_Internal_Node">11.2. Internal Nodes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Timestamps">12. Timestamps</a></span></dt><dd><dl><dt><span class="section"><a href="#Inode_Timestamps">12.1. Inode Timestamps</a></span></dt><dt><span class="section"><a href="#Quota_Timers">12.2. Quota Grace Period Expiration Timers</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Allocation_Groups">13. Allocation Groups</a></span></dt><dd><dl><dt><span class="section"><a href="#Superblocks">13.1. Superblocks</a></span></dt><dt><span class="section"><a href="#AG_Free_Space_Management">13.2. AG Free Space Management</a></span></dt><dt><span class="section"><a href="#AG_Inode_Management">13.3. AG Inode Management</a></span></dt><dt><span class="section"><a href="#Inode_Btrees">13.4. Inode B+trees</a></span></dt><dt><span class="section"><a href="#Sparse_Inodes">13.5. Sparse Inodes</a></span></dt><dt><span class="section"><a href="#Real-time_Devices">13.6. Real-time Devices</a></span></dt><dt><span class="section"><a href="#Reverse_Mapping_Btree">13.7. Reverse-Mapping B+tree</a></span></dt><dt><span class="section"><a href="#Reference_Count_Btree">13.8. Reference Count B+tree</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Journaling_Log">14. Journaling Log</a></span></dt><dd><dl><dt><span class="section"><a href="#Log_Records">14.1. Log Records</a></span></dt><dt><span class="section"><a href="#Log_Operations">14.2. Log Operations</a></span></dt><dt><span class="section"><a href="#Log_Items">14.3. Log Items</a></span></dt><dt><span class="section"><a href="#_xfs_logprint_example">14.4. xfs_logprint Example</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Internal_Inodes">15. Internal Inodes</a></span></dt><dd><dl><dt><span class="section"><a href="#Quota_Inodes">15.1. Quota Inodes</a></span></dt><dt><span class="section"><a href="#Real-time_Inodes">15.2. Real-time Inodes</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#_dynamically_allocated_structures">III. Dynamically Allocated Structures</a></span></dt><dd><dl><dt><span class="chapter"><a href="#On-disk_Inode">16. On-disk Inode</a></span></dt><dd><dl><dt><span class="section"><a href="#Inode_Core">16.1. Inode Core</a></span></dt><dt><span class="section"><a href="#Unlinked_Pointer">16.2. Unlinked Pointer</a></span></dt><dt><span class="section"><a href="#Data_Fork">16.3. Data Fork</a></span></dt><dt><span class="section"><a href="#Attribute_Fork">16.4. Attribute Fork</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Data_Extents">17. Data Extents</a></span></dt><dd><dl><dt><span class="section"><a href="#Extent_List">17.1. Extent List</a></span></dt><dt><span class="section"><a href="#Btree_Extent_List">17.2. B+tree Extent List</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Directories">18. Directories</a></span></dt><dd><dl><dt><span class="section"><a href="#Shortform_Directories">18.1. Short Form Directories</a></span></dt><dt><span class="section"><a href="#Block_Directories">18.2. Block Directories</a></span></dt><dt><span class="section"><a href="#Leaf_Directories">18.3. Leaf Directories</a></span></dt><dt><span class="section"><a href="#Node_Directories">18.4. Node Directories</a></span></dt><dt><span class="section"><a href="#Btree_Directories">18.5. B+tree Directories</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Extended_Attributes">19. Extended Attributes</a></span></dt><dd><dl><dt><span class="section"><a href="#Shortform_Attributes">19.1. Short Form Attributes</a></span></dt><dt><span class="section"><a href="#Leaf_Attributes">19.2. Leaf Attributes</a></span></dt><dt><span class="section"><a href="#Node_Attributes">19.3. Node Attributes</a></span></dt><dt><span class="section"><a href="#Btree_Attributes">19.4. B+tree Attributes</a></span></dt><dt><span class="section"><a href="#Remote_Values">19.5. Remote Attribute Values</a></span></dt><dt><span class="section"><a href="#_key_differences_between_directories_and_extended_attributes">19.6. Key Differences Between Directories and Extended Attributes</a></span></dt></dl></dd><dt><span class="chapter"><a href="#Symbolic_Links">20. Symbolic Links</a></span></dt><dd><dl><dt><span class="section"><a href="#Shortform_Symbolic_Links">20.1. Short Form Symbolic Links</a></span></dt><dt><span class="section"><a href="#Extent_Symbolic_Links">20.2. Extent Symbolic Links</a></span></dt></dl></dd></dl></dd><dt><span class="part"><a href="#_auxiliary_data_structures">IV. Auxiliary Data Structures</a></span></dt><dd><dl><dt><span class="chapter"><a href="#Metadata_Dumps">21. Metadata Dumps</a></span></dt><dd><dl><dt><span class="section"><a href="#_dump_obfuscation">21.1. Dump Obfuscation</a></span></dt></dl></dd></dl></dd></dl></div><div class="list-of-figures"><p><strong>List of Figures</strong></p><dl><dt>13.1. <a href="#idm1648">Allocation group layout</a></dt><dt>13.2. <a href="#idm2479">Freespace B+tree with one leaf.</a></dt><dt>13.3. <a href="#idm2487">Multi-level freespace B+tree.</a></dt><dt>13.4. <a href="#idm2537">AG Free List layout</a></dt><dt>13.5. <a href="#idm2577">Inode number formats</a></dt><dt>13.6. <a href="#idm2722">Single Level inode B+tree</a></dt><dt>13.7. <a href="#idm2730">Multi-Level inode B+tree</a></dt><dt>15.1. <a href="#idm4700">Quota inode layout</a></dt><dt>16.1. <a href="#idm4977">On-disk inode sections</a></dt><dt>16.2. <a href="#idm5404">Unlinked inode pointer</a></dt><dt>16.3. <a href="#idm5522">Extended attribute layouts</a></dt><dt>17.1. <a href="#idm5616">Inode data fork extent layout</a></dt><dt>17.2. <a href="#idm5683">Single level extent B+tree</a></dt><dt>17.3. <a href="#idm5690">Multiple level extent B+tree</a></dt><dt>18.1. <a href="#idm5884">Short form directory layout</a></dt><dt>18.2. <a href="#idm6111">Block directory layout</a></dt><dt>18.3. <a href="#idm6296">Leaf directory free entry detail</a></dt><dt>18.4. <a href="#idm6457">Node directory layout</a></dt><dt>19.1. <a href="#idm6607">Short form attribute layout</a></dt><dt>19.2. <a href="#idm6796">Leaf attribute layout</a></dt><dt>19.3. <a href="#idm6832">Node attribute layout</a></dt><dt>20.1. <a href="#idm6937">Symbolic link short form layout</a></dt><dt>20.2. <a href="#idm7002">Symbolic link extent layout</a></dt></dl></div><div class="list-of-tables"><p><strong>List of Tables</strong></p><dl><dt>13.1. <a href="#idm1746">Version 4 Superblock version flags</a></dt><dt>13.2. <a href="#idm1943">Superblock quota flags</a></dt><dt>13.3. <a href="#idm2025">Superblock flags</a></dt><dt>13.4. <a href="#idm2095">Extended Version 4 Superblock flags</a></dt><dt>13.5. <a href="#idm2162">Extended Version 5 Superblock Read-Only compatibility flags</a></dt><dt>13.6. <a href="#idm2204">Extended Version 5 Superblock Read-Write incompatibility flags</a></dt><dt>13.7. <a href="#idm2262">Extended Version 5 Superblock Log incompatibility flags</a></dt><dt>13.8. <a href="#idm2826">Special owner values</a></dt><dt>14.1. <a href="#idm3075">Log record formats</a></dt><dt>14.2. <a href="#idm3154">Log Operation Client ID</a></dt><dt>14.3. <a href="#idm3188">Log Operation Flags</a></dt><dt>14.4. <a href="#idm3248">Log Operation Magic Numbers</a></dt><dt>14.5. <a href="#idm3797">Reverse mapping update log intent types</a></dt><dt>14.6. <a href="#idm3855">Reverse mapping update log intent flags</a></dt><dt>14.7. <a href="#idm3951">Reference count update log intent types</a></dt><dt>14.8. <a href="#idm4040">File block mapping update log intent types</a></dt><dt>14.9. <a href="#idm4062">File block mapping update log intent flags</a></dt><dt>14.10. <a href="#idm4137">Extended attribute update log intent types</a></dt><dt>16.1. <a href="#idm5185">Version 2 Inode flags</a></dt><dt>16.2. <a href="#idm5322">Version 3 Inode flags</a></dt><dt>17.1. <a href="#idm5539">Extent record format</a></dt><dt>18.1. <a href="#idm5734">ftype values</a></dt><dt>19.1. <a href="#Attribute_Flags">Attribute Namespaces</a></dt></dl></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="_high_level_design"></a>Part I. High Level Design</h1></div></div></div><div class="partintro"><div></div><p>XFS is a high performance filesystem which was designed to maximize parallel
throughput and to scale up to extremely large 64-bit storage systems.
Originally developed by SGI in October 1993 for IRIX, XFS can handle large
files, large filesystems, many inodes, large directories, large file
attributes, and large allocations.  Filesystems are optimized for parallel
access by splitting the storage device into semi-autonomous allocation groups.
XFS employs branching trees (B+ trees) to facilitate fast searches of large
lists; it also uses delayed extent-based allocation to improve data contiguity
and IO performance.</p><p>This document describes the on-disk layout of an XFS filesystem and how to use
the debugging tools <code class="literal">xfs_db</code> and <code class="literal">xfs_logprint</code> to inspect the metadata
structures.  It also describes how on-disk metadata relates to the higher level
design goals.</p><p>The information contained in this document derives from the XFS source code in
the Linux kernel as of v4.3.  This book’s source code is available at
<code class="literal">git://git.kernel.org/pub/scm/fs/xfs/xfs-documentation.git</code>.  Feedback should
be sent to the XFS mailing list, currently at <code class="literal">linux-xfs@vger.kernel.org</code>.</p><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>All fields in XFS metadata structures are in big-endian byte order except for
log items which are formatted in host order.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_overview"></a>Chapter 1. Overview</h2></div></div></div><p>XFS presents to users a standard Unix filesystem interface: a rooted
tree of directories, files, symbolic links, and devices.  All five of those
entities are represented inside the filesystem by an index node, or “inode”;
each node is uniquely referenced by an inode number.  Directories consist of
(name, inode number) tuples and it is possible for multiple tuples to contain
the same inode number.  Data blocks are associated with files by means of a
block map in each index node.  It is also possible to attach (key, value)
tuples to any index node; these are known as “extended attributes”, which
extend beyond the standard Unix file attributes.</p><p>Internally, XFS filesystems are divided into a number of equally sized chunks
called Allocation Groups.  Each AG can almost be thought of as an individual
filesystem that maintains its own space usage, index nodes, and other secondary
metadata.  Having multiple AGs allows XFS to handle most operations in parallel
without degrading performance as the number of concurrent accesses increases.
Each allocation group uses multiple B+trees to maintain bookkeeping records
such as the locations of free blocks, the locations of allocated inodes, and
the locations of free inodes.</p><p>Files, symbolic links, and directories can have up to two block maps, or
“forks”, which associate filesystems blocks with a particular file or
directory.  The “attribute fork” tracks blocks used to store and index
extended attributes, whereas the “data fork” tracks file data blocks,
symbolic link targets, or directory blocks, depending on the type of the inode
record.  Both forks associate a logical offset with an extent of physical
blocks, which makes sparse files and directories possible.  Directory entries
and extended attributes are contained inside a second-level data structure
within the blocks that are mapped by the forks.  This structure consists of
variable-length directory or attribute records and, possibly, a second B+tree to
index these records.</p><p>XFS employs a journalling log in which metadata changes are collected so that
filesystem operations can be carried out atomically in the case of a crash.
Furthermore, there is the concept of a real-time device wherein allocations are
tracked more simply and in larger chunks to reduce jitter in allocation
latency.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_metadata_integrity"></a>Chapter 2. Metadata Integrity</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_introduction"></a>2.1. Introduction</h2></div></div></div><p>The largest scalability problem facing XFS is not one of algorithmic
scalability, but of verification of the filesystem structure. Scalabilty of the
structures and indexes on disk and the algorithms for iterating them are
adequate for supporting PB scale filesystems with billions of inodes, however it
is this very scalability that causes the verification problem.</p><p>Almost all metadata on XFS is dynamically allocated. The only fixed location
metadata is the allocation group headers (SB, AGF, AGFL and AGI), while all
other metadata structures need to be discovered by walking the filesystem
structure in different ways. While this is already done by userspace tools for
validating and repairing the structure, there are limits to what they can
verify, and this in turn limits the supportable size of an XFS filesystem.</p><p>For example, it is entirely possible to manually use xfs_db and a bit of
scripting to analyse the structure of a 100TB filesystem when trying to
determine the root cause of a corruption problem, but it is still mainly a
manual task of verifying that things like single bit errors or misplaced writes
weren’t the ultimate cause of a corruption event. It may take a few hours to a
few days to perform such forensic analysis, so for at this scale root cause
analysis is entirely possible.</p><p>However, if we scale the filesystem up to 1PB, we now have 10x as much metadata
to analyse and so that analysis blows out towards weeks/months of forensic work.
Most of the analysis work is slow and tedious, so as the amount of analysis goes
up, the more likely that the cause will be lost in the noise.  Hence the primary
concern for supporting PB scale filesystems is minimising the time and effort
required for basic forensic analysis of the filesystem structure.</p><p>Therefore, the version 5 disk format introduced larger headers for all metadata
types, which enable the filesystem to check information being read from the
disk more rigorously.  Metadata integrity fields now include:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<span class="strong"><strong>Magic</strong></span> numbers, to classify all types of metadata.  This is unchanged from v4.
</li><li class="listitem">
A copy of the filesystem <span class="strong"><strong>UUID</strong></span>, to confirm that a given disk block is connected to the superblock.
</li><li class="listitem">
The <span class="strong"><strong>owner</strong></span>, to avoid accessing a piece of metadata which belongs to some other part of the filesystem.
</li><li class="listitem">
The filesystem <span class="strong"><strong>block number</strong></span>, to detect misplaced writes.
</li><li class="listitem">
The <span class="strong"><strong>log serial number</strong></span> of the last write to this block, to avoid replaying obsolete log entries.
</li><li class="listitem">
A CRC32c <span class="strong"><strong>checksum</strong></span> of the entire block, to detect minor corruption.
</li></ul></div><p>Metadata integrity coverage has been extended to all metadata blocks in the
filesystem, with the following notes:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Inodes can have multiple “owners” in the directory tree; therefore the record contains the inode number instead of an owner or a block number.
</li><li class="listitem">
Superblocks have no owners.
</li><li class="listitem">
The disk quota file has no owner or block numbers.
</li><li class="listitem">
Metadata owned by files list the inode number as the owner.
</li><li class="listitem">
Per-AG data and B+tree blocks list the AG number as the owner.
</li><li class="listitem">
Per-AG header sectors don’t list owners or block numbers, since they have fixed locations.
</li><li class="listitem">
Remote attribute blocks are not logged and therefore the LSN must be -1.
</li></ul></div><p>This functionality enables XFS to decide that a block contents are so
unexpected that it should stop immediately.  Unfortunately checksums do not
allow for automatic correction.  Please keep regular backups, as always.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_self_describing_metadata"></a>2.2. Self Describing Metadata</h2></div></div></div><p>One of the problems with the current metadata format is that apart from the
magic number in the metadata block, we have no other way of identifying what it
is supposed to be. We can’t even identify if it is the right place. Put simply,
you can’t look at a single metadata block in isolation and say "yes, it is
supposed to be there and the contents are valid".</p><p>Hence most of the time spent on forensic analysis is spent doing basic
verification of metadata values, looking for values that are in range (and hence
not detected by automated verification checks) but are not correct. Finding and
understanding how things like cross linked block lists (e.g. sibling
pointers in a btree end up with loops in them) are the key to understanding what
went wrong, but it is impossible to tell what order the blocks were linked into
each other or written to disk after the fact.</p><p>Hence we need to record more information into the metadata to allow us to
quickly determine if the metadata is intact and can be ignored for the purpose
of analysis. We can’t protect against every possible type of error, but we can
ensure that common types of errors are easily detectable.  Hence the concept of
self describing metadata.</p><p>The first, fundamental requirement of self describing metadata is that the
metadata object contains some form of unique identifier in a well known
location. This allows us to identify the expected contents of the block and
hence parse and verify the metadata object. IF we can’t independently identify
the type of metadata in the object, then the metadata doesn’t describe itself
very well at all!</p><p>Luckily, almost all XFS metadata has magic numbers embedded already - only the
AGFL, remote symlinks and remote attribute blocks do not contain identifying
magic numbers. Hence we can change the on-disk format of all these objects to
add more identifying information and detect this simply by changing the magic
numbers in the metadata objects. That is, if it has the current magic number,
the metadata isn’t self identifying. If it contains a new magic number, it is
self identifying and we can do much more expansive automated verification of the
metadata object at runtime, during forensic analysis or repair.</p><p>As a primary concern, self describing metadata needs some form of overall
integrity checking. We cannot trust the metadata if we cannot verify that it has
not been changed as a result of external influences. Hence we need some form of
integrity check, and this is done by adding CRC32c validation to the metadata
block. If we can verify the block contains the metadata it was intended to
contain, a large amount of the manual verification work can be skipped.</p><p>CRC32c was selected as metadata cannot be more than 64k in length in XFS and
hence a 32 bit CRC is more than sufficient to detect multi-bit errors in
metadata blocks. CRC32c is also now hardware accelerated on common CPUs so it is
fast. So while CRC32c is not the strongest of possible integrity checks that
could be used, it is more than sufficient for our needs and has relatively
little overhead. Adding support for larger integrity fields and/or algorithms
does really provide any extra value over CRC32c, but it does add a lot of
complexity and so there is no provision for changing the integrity checking
mechanism.</p><p>Self describing metadata needs to contain enough information so that the
metadata block can be verified as being in the correct place without needing to
look at any other metadata. This means it needs to contain location information.
Just adding a block number to the metadata is not sufficient to protect against
mis-directed writes - a write might be misdirected to the wrong LUN and so be
written to the "correct block" of the wrong filesystem. Hence location
information must contain a filesystem identifier as well as a block number.</p><p>Another key information point in forensic analysis is knowing who the metadata
block belongs to. We already know the type, the location, that it is valid
and/or corrupted, and how long ago that it was last modified. Knowing the owner
of the block is important as it allows us to find other related metadata to
determine the scope of the corruption. For example, if we have a extent btree
object, we don’t know what inode it belongs to and hence have to walk the entire
filesystem to find the owner of the block. Worse, the corruption could mean that
no owner can be found (i.e. it’s an orphan block), and so without an owner field
in the metadata we have no idea of the scope of the corruption. If we have an
owner field in the metadata object, we can immediately do top down validation to
determine the scope of the problem.</p><p>Different types of metadata have different owner identifiers. For example,
directory, attribute and extent tree blocks are all owned by an inode, whilst
freespace btree blocks are owned by an allocation group. Hence the size and
contents of the owner field are determined by the type of metadata object we are
looking at.  The owner information can also identify misplaced writes (e.g.
freespace btree block written to the wrong AG).</p><p>Self describing metadata also needs to contain some indication of when it was
written to the filesystem. One of the key information points when doing forensic
analysis is how recently the block was modified. Correlation of set of corrupted
metadata blocks based on modification times is important as it can indicate
whether the corruptions are related, whether there’s been multiple corruption
events that lead to the eventual failure, and even whether there are corruptions
present that the run-time verification is not detecting.</p><p>For example, we can determine whether a metadata object is supposed to be free
space or still allocated if it is still referenced by its owner by looking at
when the free space btree block that contains the block was last written
compared to when the metadata object itself was last written.  If the free space
block is more recent than the object and the object’s owner, then there is a
very good chance that the block should have been removed from the owner.</p><p>To provide this "written timestamp", each metadata block gets the Log Sequence
Number (LSN) of the most recent transaction it was modified on written into it.
This number will always increase over the life of the filesystem, and the only
thing that resets it is running xfs_repair on the filesystem. Further, by use of
the LSN we can tell if the corrupted metadata all belonged to the same log
checkpoint and hence have some idea of how much modification occurred between
the first and last instance of corrupt metadata on disk and, further, how much
modification occurred between the corruption being written and when it was
detected.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_runtime_validation"></a>2.3. Runtime Validation</h2></div></div></div><p>Validation of self-describing metadata takes place at runtime in two places:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
immediately after a successful read from disk
</li><li class="listitem">
immediately prior to write IO submission
</li></ul></div><p>The verification is completely stateless - it is done independently of the
modification process, and seeks only to check that the metadata is what it says
it is and that the metadata fields are within bounds and internally consistent.
As such, we cannot catch all types of corruption that can occur within a block
as there may be certain limitations that operational state enforces of the
metadata, or there may be corruption of interblock relationships (e.g. corrupted
sibling pointer lists). Hence we still need stateful checking in the main code
body, but in general most of the per-field validation is handled by the
verifiers.</p><p>For read verification, the caller needs to specify the expected type of metadata
that it should see, and the IO completion process verifies that the metadata
object matches what was expected. If the verification process fails, then it
marks the object being read as EFSCORRUPTED. The caller needs to catch this
error (same as for IO errors), and if it needs to take special action due to a
verification error it can do so by catching the EFSCORRUPTED error value. If we
need more discrimination of error type at higher levels, we can define new
error numbers for different errors as necessary.</p><p>The first step in read verification is checking the magic number and determining
whether CRC validating is necessary. If it is, the CRC32c is calculated and
compared against the value stored in the object itself. Once this is validated,
further checks are made against the location information, followed by extensive
object specific metadata validation. If any of these checks fail, then the
buffer is considered corrupt and the EFSCORRUPTED error is set appropriately.</p><p>Write verification is the opposite of the read verification - first the object
is extensively verified and if it is OK we then update the LSN from the last
modification made to the object, After this, we calculate the CRC and insert it
into the object. Once this is done the write IO is allowed to continue. If any
error occurs during this process, the buffer is again marked with a EFSCORRUPTED
error for the higher layers to catch.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_structures"></a>2.4. Structures</h2></div></div></div><p>A typical on-disk structure needs to contain the following information:</p><pre class="programlisting">struct xfs_ondisk_hdr {
        __be32  magic;          /* magic number */
        __be32  crc;            /* CRC, not logged */
        uuid_t  uuid;           /* filesystem identifier */
        __be64  owner;          /* parent object */
        __be64  blkno;          /* location on disk */
        __be64  lsn;            /* last modification in log, not logged */
};</pre><p>Depending on the metadata, this information may be part of a header structure
separate to the metadata contents, or may be distributed through an existing
structure. The latter occurs with metadata that already contains some of this
information, such as the superblock and AG headers.</p><p>Other metadata may have different formats for the information, but the same
level of information is generally provided. For example:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
short btree blocks have a 32 bit owner (ag number) and a 32 bit block
          number for location. The two of these combined provide the same
          information as @owner and @blkno in eh above structure, but using 8
          bytes less space on disk.
</li><li class="listitem">
directory/attribute node blocks have a 16 bit magic number, and the
          header that contains the magic number has other information in it as
          well. hence the additional metadata headers change the overall format
          of the metadata.
</li></ul></div><p>A typical buffer read verifier is structured as follows:</p><pre class="programlisting">#define XFS_FOO_CRC_OFF         offsetof(struct xfs_ondisk_hdr, crc)

static void
xfs_foo_read_verify(
        struct xfs_buf  *bp)
{
       struct xfs_mount *mp = bp-&gt;b_target-&gt;bt_mount;

        if ((xfs_sb_version_hascrc(&amp;mp-&gt;m_sb) &amp;&amp;
             !xfs_verify_cksum(bp-&gt;b_addr, BBTOB(bp-&gt;b_length),
                                        XFS_FOO_CRC_OFF)) ||
            !xfs_foo_verify(bp)) {
                XFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, bp-&gt;b_addr);
                xfs_buf_ioerror(bp, EFSCORRUPTED);
        }
}</pre><p>The code ensures that the CRC is only checked if the filesystem has CRCs enabled
by checking the superblock of the feature bit, and then if the CRC verifies OK
(or is not needed) it verifies the actual contents of the block.</p><p>The verifier function will take a couple of different forms, depending on
whether the magic number can be used to determine the format of the block. In
the case it can’t, the code is structured as follows:</p><pre class="programlisting">static bool
xfs_foo_verify(
        struct xfs_buf          *bp)
{
        struct xfs_mount        *mp = bp-&gt;b_target-&gt;bt_mount;
        struct xfs_ondisk_hdr   *hdr = bp-&gt;b_addr;

        if (hdr-&gt;magic != cpu_to_be32(XFS_FOO_MAGIC))
                return false;

        if (!xfs_sb_version_hascrc(&amp;mp-&gt;m_sb)) {
                if (!uuid_equal(&amp;hdr-&gt;uuid, &amp;mp-&gt;m_sb.sb_uuid))
                        return false;
                if (bp-&gt;b_bn != be64_to_cpu(hdr-&gt;blkno))
                        return false;
                if (hdr-&gt;owner == 0)
                        return false;
        }

        /* object specific verification checks here */

        return true;
}</pre><p>If there are different magic numbers for the different formats, the verifier
will look like:</p><pre class="programlisting">static bool
xfs_foo_verify(
        struct xfs_buf          *bp)
{
        struct xfs_mount        *mp = bp-&gt;b_target-&gt;bt_mount;
        struct xfs_ondisk_hdr   *hdr = bp-&gt;b_addr;

        if (hdr-&gt;magic == cpu_to_be32(XFS_FOO_CRC_MAGIC)) {
                if (!uuid_equal(&amp;hdr-&gt;uuid, &amp;mp-&gt;m_sb.sb_uuid))
                        return false;
                if (bp-&gt;b_bn != be64_to_cpu(hdr-&gt;blkno))
                        return false;
                if (hdr-&gt;owner == 0)
                        return false;
        } else if (hdr-&gt;magic != cpu_to_be32(XFS_FOO_MAGIC))
                return false;

        /* object specific verification checks here */

        return true;
}</pre><p>Write verifiers are very similar to the read verifiers, they just do things in
the opposite order to the read verifiers. A typical write verifier:</p><pre class="programlisting">static void
xfs_foo_write_verify(
        struct xfs_buf  *bp)
{
        struct xfs_mount        *mp = bp-&gt;b_target-&gt;bt_mount;
        struct xfs_buf_log_item *bip = bp-&gt;b_fspriv;

        if (!xfs_foo_verify(bp)) {
                XFS_CORRUPTION_ERROR(__func__, XFS_ERRLEVEL_LOW, mp, bp-&gt;b_addr);
                xfs_buf_ioerror(bp, EFSCORRUPTED);
                return;
        }

        if (!xfs_sb_version_hascrc(&amp;mp-&gt;m_sb))
                return;


        if (bip) {
                struct xfs_ondisk_hdr   *hdr = bp-&gt;b_addr;
                hdr-&gt;lsn = cpu_to_be64(bip-&gt;bli_item.li_lsn);
        }
        xfs_update_cksum(bp-&gt;b_addr, BBTOB(bp-&gt;b_length), XFS_FOO_CRC_OFF);
}</pre><p>This will verify the internal structure of the metadata before we go any
further, detecting corruptions that have occurred as the metadata has been
modified in memory. If the metadata verifies OK, and CRCs are enabled, we then
update the LSN field (when it was last modified) and calculate the CRC on the
metadata. Once this is done, we can issue the IO.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_inodes_and_dquots"></a>2.5. Inodes and Dquots</h2></div></div></div><p>Inodes and dquots are special snowflakes. They have per-object CRC and
self-identifiers, but they are packed so that there are multiple objects per
buffer. Hence we do not use per-buffer verifiers to do the work of per-object
verification and CRC calculations. The per-buffer verifiers simply perform basic
identification of the buffer - that they contain inodes or dquots, and that
there are magic numbers in all the expected spots. All further CRC and
verification checks are done when each inode is read from or written back to the
buffer.</p><p>The structure of the verifiers and the identifiers checks is very similar to the
buffer code described above. The only difference is where they are called. For
example, inode read verification is done in xfs_iread() when the inode is first
read out of the buffer and the struct xfs_inode is instantiated. The inode is
already extensively verified during writeback in xfs_iflush_int, so the only
addition here is to add the LSN and CRC to the inode as it is copied back into
the buffer.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_delayed_logging"></a>Chapter 3. Delayed Logging</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_introduction_to_re_logging_in_xfs"></a>3.1. Introduction to Re-logging in XFS</h2></div></div></div><p>XFS logging is a combination of logical and physical logging. Some objects,
such as inodes and dquots, are logged in logical format where the details
logged are made up of the changes to in-core structures rather than on-disk
structures. Other objects - typically buffers - have their physical changes
logged. The reason for these differences is to reduce the amount of log space
required for objects that are frequently logged. Some parts of inodes are more
frequently logged than others, and inodes are typically more frequently logged
than any other object (except maybe the superblock buffer) so keeping the
amount of metadata logged low is of prime importance.</p><p>The reason that this is such a concern is that XFS allows multiple separate
modifications to a single object to be carried in the log at any given time.
This allows the log to avoid needing to flush each change to disk before
recording a new change to the object. XFS does this via a method called
"re-logging". Conceptually, this is quite simple - all it requires is that any
new change to the object is recorded with a <span class="strong"><strong>new copy</strong></span> of all the existing
changes in the new transaction that is written to the log.</p><p>That is, if we have a sequence of changes A through to F, and the object was
written to disk after change D, we would see in the log the following series
of transactions, their contents and the log sequence number (LSN) of the
transaction:</p><pre class="literallayout">        Transaction             Contents        LSN
           A                       A               X
           B                      A+B             X+n
           C                     A+B+C           X+n+m
           D                    A+B+C+D         X+n+m+o
            &lt;object written to disk&gt;
           E                       E               Y (&gt; X+n+m+o)
           F                      E+F             Y+p</pre><p>In other words, each time an object is relogged, the new transaction contains
the aggregation of all the previous changes currently held only in the log.</p><p>This relogging technique also allows objects to be moved forward in the log so
that an object being relogged does not prevent the tail of the log from ever
moving forward.  This can be seen in the table above by the changing
(increasing) LSN of each subsequent transaction - the LSN is effectively a
direct encoding of the location in the log of the transaction.</p><p>This relogging is also used to implement long-running, multiple-commit
transactions.  These transaction are known as rolling transactions, and require
a special log reservation known as a permanent transaction reservation. A
typical example of a rolling transaction is the removal of extents from an
inode which can only be done at a rate of two extents per transaction because
of reservation size limitations. Hence a rolling extent removal transaction
keeps relogging the inode and btree buffers as they get modified in each
removal operation. This keeps them moving forward in the log as the operation
progresses, ensuring that current operation never gets blocked by itself if the
log wraps around.</p><p>Hence it can be seen that the relogging operation is fundamental to the correct
working of the XFS journalling subsystem. From the above description, most
people should be able to see why the XFS metadata operations writes so much to
the log - repeated operations to the same objects write the same changes to
the log over and over again. Worse is the fact that objects tend to get
dirtier as they get relogged, so each subsequent transaction is writing more
metadata into the log.</p><p>Another feature of the XFS transaction subsystem is that most transactions are
asynchronous. That is, they don’t commit to disk until either a log buffer is
filled (a log buffer can hold multiple transactions) or a synchronous operation
forces the log buffers holding the transactions to disk. This means that XFS is
doing aggregation of transactions in memory - batching them, if you like - to
minimise the impact of the log IO on transaction throughput.</p><p>The limitation on asynchronous transaction throughput is the number and size of
log buffers made available by the log manager. By default there are 8 log
buffers available and the size of each is 32kB - the size can be increased up
to 256kB by use of a mount option.</p><p>Effectively, this gives us the maximum bound of outstanding metadata changes
that can be made to the filesystem at any point in time - if all the log
buffers are full and under IO, then no more transactions can be committed until
the current batch completes. It is now common for a single current CPU core to
be to able to issue enough transactions to keep the log buffers full and under
IO permanently. Hence the XFS journalling subsystem can be considered to be IO
bound.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_delayed_logging_concepts"></a>3.2. Delayed Logging Concepts</h2></div></div></div><p>The key thing to note about the asynchronous logging combined with the
relogging technique XFS uses is that we can be relogging changed objects
multiple times before they are committed to disk in the log buffers. If we
return to the previous relogging example, it is entirely possible that
transactions A through D are committed to disk in the same log buffer.</p><p>That is, a single log buffer may contain multiple copies of the same object,
but only one of those copies needs to be there - the last one "D", as it
contains all the changes from the previous changes. In other words, we have one
necessary copy in the log buffer, and three stale copies that are simply
wasting space. When we are doing repeated operations on the same set of
objects, these "stale objects" can be over 90% of the space used in the log
buffers. It is clear that reducing the number of stale objects written to the
log would greatly reduce the amount of metadata we write to the log, and this
is the fundamental goal of delayed logging.</p><p>From a conceptual point of view, XFS is already doing relogging in memory (where
memory == log buffer), only it is doing it extremely inefficiently. It is using
logical to physical formatting to do the relogging because there is no
infrastructure to keep track of logical changes in memory prior to physically
formatting the changes in a transaction to the log buffer. Hence we cannot avoid
accumulating stale objects in the log buffers.</p><p>Delayed logging is the name we’ve given to keeping and tracking transactional
changes to objects in memory outside the log buffer infrastructure. Because of
the relogging concept fundamental to the XFS journalling subsystem, this is
actually relatively easy to do - all the changes to logged items are already
tracked in the current infrastructure. The big problem is how to accumulate
them and get them to the log in a consistent, recoverable manner.
Describing the problems and how they have been solved is the focus of this
document.</p><p>One of the key changes that delayed logging makes to the operation of the
journalling subsystem is that it disassociates the amount of outstanding
metadata changes from the size and number of log buffers available. In other
words, instead of there only being a maximum of 2MB of transaction changes not
written to the log at any point in time, there may be a much greater amount
being accumulated in memory. Hence the potential for loss of metadata on a
crash is much greater than for the existing logging mechanism.</p><p>It should be noted that this does not change the guarantee that log recovery
will result in a consistent filesystem. What it does mean is that as far as the
recovered filesystem is concerned, there may be many thousands of transactions
that simply did not occur as a result of the crash. This makes it even more
important that applications that care about their data use fsync() where they
need to ensure application level data integrity is maintained.</p><p>It should be noted that delayed logging is not an innovative new concept that
warrants rigorous proofs to determine whether it is correct or not. The method
of accumulating changes in memory for some period before writing them to the
log is used effectively in many filesystems including ext3 and ext4. Hence
no time is spent in this document trying to convince the reader that the
concept is sound. Instead it is simply considered a "solved problem" and as
such implementing it in XFS is purely an exercise in software engineering.</p><p>The fundamental requirements for delayed logging in XFS are simple:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Reduce the amount of metadata written to the log by at least
           an order of magnitude.
</li><li class="listitem">
Supply sufficient statistics to validate Requirement #1.
</li><li class="listitem">
Supply sufficient new tracing infrastructure to be able to debug
           problems with the new code.
</li><li class="listitem">
No on-disk format change (metadata or log format).
</li><li class="listitem">
Enable and disable with a mount option.
</li><li class="listitem">
No performance regressions for synchronous transaction workloads.
</li></ol></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_delayed_logging_design"></a>3.3. Delayed Logging Design</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_storing_changes"></a>3.3.1. Storing Changes</h3></div></div></div><p>The problem with accumulating changes at a logical level (i.e. just using the
existing log item dirty region tracking) is that when it comes to writing the
changes to the log buffers, we need to ensure that the object we are formatting
is not changing while we do this. This requires locking the object to prevent
concurrent modification. Hence flushing the logical changes to the log would
require us to lock every object, format them, and then unlock them again.</p><p>This introduces lots of scope for deadlocks with transactions that are already
running. For example, a transaction has object A locked and modified, but needs
the delayed logging tracking lock to commit the transaction. However, the
flushing thread has the delayed logging tracking lock already held, and is
trying to get the lock on object A to flush it to the log buffer. This appears
to be an unsolvable deadlock condition, and it was solving this problem that
was the barrier to implementing delayed logging for so long.</p><p>The solution is relatively simple - it just took a long time to recognise it.
Put simply, the current logging code formats the changes to each item into an
vector array that points to the changed regions in the item. The log write code
simply copies the memory these vectors point to into the log buffer during
transaction commit while the item is locked in the transaction. Instead of
using the log buffer as the destination of the formatting code, we can use an
allocated memory buffer big enough to fit the formatted vector.</p><p>If we then copy the vector into the memory buffer and rewrite the vector to
point to the memory buffer rather than the object itself, we now have a copy of
the changes in a format that is compatible with the log buffer writing code.
that does not require us to lock the item to access. This formatting and
rewriting can all be done while the object is locked during transaction commit,
resulting in a vector that is transactionally consistent and can be accessed
without needing to lock the owning item.</p><p>Hence we avoid the need to lock items when we need to flush outstanding
asynchronous transactions to the log. The differences between the existing
formatting method and the delayed logging formatting can be seen in the
diagram below.</p><p>Current format log vector:</p><pre class="literallayout">Object    +---------------------------------------------+
Vector 1      +----+
Vector 2                    +----+
Vector 3                                   +----------+</pre><p>After formatting:</p><pre class="literallayout">Log Buffer    +-V1-+-V2-+----V3----+</pre><p>Delayed logging vector:</p><pre class="literallayout">Object    +---------------------------------------------+
Vector 1      +----+
Vector 2                    +----+
Vector 3                                   +----------+</pre><p>After formatting:</p><pre class="literallayout">Memory Buffer +-V1-+-V2-+----V3----+
Vector 1      +----+
Vector 2           +----+
Vector 3                +----------+</pre><p>The memory buffer and associated vector need to be passed as a single object,
but still need to be associated with the parent object so if the object is
relogged we can replace the current memory buffer with a new memory buffer that
contains the latest changes.</p><p>The reason for keeping the vector around after we’ve formatted the memory
buffer is to support splitting vectors across log buffer boundaries correctly.
If we don’t keep the vector around, we do not know where the region boundaries
are in the item, so we’d need a new encapsulation method for regions in the log
buffer writing (i.e. double encapsulation). This would be an on-disk format
change and as such is not desirable.  It also means we’d have to write the log
region headers in the formatting stage, which is problematic as there is per
region state that needs to be placed into the headers during the log write.</p><p>Hence we need to keep the vector, but by attaching the memory buffer to it and
rewriting the vector addresses to point at the memory buffer we end up with a
self-describing object that can be passed to the log buffer write code to be
handled in exactly the same manner as the existing log vectors are handled.
Hence we avoid needing a new on-disk format to handle items that have been
relogged in memory.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_tracking_changes"></a>3.3.2. Tracking Changes</h3></div></div></div><p>Now that we can record transactional changes in memory in a form that allows
them to be used without limitations, we need to be able to track and accumulate
them so that they can be written to the log at some later point in time.  The
log item is the natural place to store this vector and buffer, and also makes sense
to be the object that is used to track committed objects as it will always
exist once the object has been included in a transaction.</p><p>The log item is already used to track the log items that have been written to
the log but not yet written to disk. Such log items are considered "active"
and as such are stored in the Active Item List (AIL) which is a LSN-ordered
double linked list. Items are inserted into this list during log buffer IO
completion, after which they are unpinned and can be written to disk. An object
that is in the AIL can be relogged, which causes the object to be pinned again
and then moved forward in the AIL when the log buffer IO completes for that
transaction.</p><p>Essentially, this shows that an item that is in the AIL can still be modified
and relogged, so any tracking must be separate to the AIL infrastructure. As
such, we cannot reuse the AIL list pointers for tracking committed items, nor
can we store state in any field that is protected by the AIL lock. Hence the
committed item tracking needs it’s own locks, lists and state fields in the log
item.</p><p>Similar to the AIL, tracking of committed items is done through a new list
called the Committed Item List (CIL).  The list tracks log items that have been
committed and have formatted memory buffers attached to them. It tracks objects
in transaction commit order, so when an object is relogged it is removed from
it’s place in the list and re-inserted at the tail. This is entirely arbitrary
and done to make it easy for debugging - the last items in the list are the
ones that are most recently modified. Ordering of the CIL is not necessary for
transactional integrity (as discussed in the next section) so the ordering is
done for convenience/sanity of the developers.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_checkpoints"></a>3.3.3. Checkpoints</h3></div></div></div><p>When we have a log synchronisation event, commonly known as a "log force",
all the items in the CIL must be written into the log via the log buffers.
We need to write these items in the order that they exist in the CIL, and they
need to be written as an atomic transaction. The need for all the objects to be
written as an atomic transaction comes from the requirements of relogging and
log replay - all the changes in all the objects in a given transaction must
either be completely replayed during log recovery, or not replayed at all. If
a transaction is not replayed because it is not complete in the log, then
no later transactions should be replayed, either.</p><p>To fulfill this requirement, we need to write the entire CIL in a single log
transaction. Fortunately, the XFS log code has no fixed limit on the size of a
transaction, nor does the log replay code. The only fundamental limit is that
the transaction cannot be larger than just under half the size of the log.  The
reason for this limit is that to find the head and tail of the log, there must
be at least one complete transaction in the log at any given time. If a
transaction is larger than half the log, then there is the possibility that a
crash during the write of a such a transaction could partially overwrite the
only complete previous transaction in the log. This will result in a recovery
failure and an inconsistent filesystem and hence we must enforce the maximum
size of a checkpoint to be slightly less than a half the log.</p><p>Apart from this size requirement, a checkpoint transaction looks no different
to any other transaction - it contains a transaction header, a series of
formatted log items and a commit record at the tail. From a recovery
perspective, the checkpoint transaction is also no different - just a lot
bigger with a lot more items in it. The worst case effect of this is that we
might need to tune the recovery transaction object hash size.</p><p>Because the checkpoint is just another transaction and all the changes to log
items are stored as log vectors, we can use the existing log buffer writing
code to write the changes into the log. To do this efficiently, we need to
minimise the time we hold the CIL locked while writing the checkpoint
transaction. The current log write code enables us to do this easily with the
way it separates the writing of the transaction contents (the log vectors) from
the transaction commit record, but tracking this requires us to have a
per-checkpoint context that travels through the log write process through to
checkpoint completion.</p><p>Hence a checkpoint has a context that tracks the state of the current
checkpoint from initiation to checkpoint completion. A new context is initiated
at the same time a checkpoint transaction is started. That is, when we remove
all the current items from the CIL during a checkpoint operation, we move all
those changes into the current checkpoint context. We then initialise a new
context and attach that to the CIL for aggregation of new transactions.</p><p>This allows us to unlock the CIL immediately after transfer of all the
committed items and effectively allow new transactions to be issued while we
are formatting the checkpoint into the log. It also allows concurrent
checkpoints to be written into the log buffers in the case of log force heavy
workloads, just like the existing transaction commit code does. This, however,
requires that we strictly order the commit records in the log so that
checkpoint sequence order is maintained during log replay.</p><p>To ensure that we can be writing an item into a checkpoint transaction at
the same time another transaction modifies the item and inserts the log item
into the new CIL, then checkpoint transaction commit code cannot use log items
to store the list of log vectors that need to be written into the transaction.
Hence log vectors need to be able to be chained together to allow them to be
detached from the log items. That is, when the CIL is flushed the memory
buffer and log vector attached to each log item needs to be attached to the
checkpoint context so that the log item can be released. In diagrammatic form,
the CIL would look like this before the flush:</p><pre class="screen">        CIL Head
           |
           V
        Log Item &lt;-&gt; log vector 1       -&gt; memory buffer
           |                            -&gt; vector array
           V
        Log Item &lt;-&gt; log vector 2       -&gt; memory buffer
           |                            -&gt; vector array
           V
        ......
           |
           V
        Log Item &lt;-&gt; log vector N-1     -&gt; memory buffer
           |                            -&gt; vector array
           V
        Log Item &lt;-&gt; log vector N       -&gt; memory buffer
                                        -&gt; vector array</pre><p>And after the flush the CIL head is empty, and the checkpoint context log
vector list would look like:</p><pre class="screen">        Checkpoint Context
           |
           V
        log vector 1    -&gt; memory buffer
           |            -&gt; vector array
           |            -&gt; Log Item
           V
        log vector 2    -&gt; memory buffer
           |            -&gt; vector array
           |            -&gt; Log Item
           V
        ......
           |
           V
        log vector N-1  -&gt; memory buffer
           |            -&gt; vector array
           |            -&gt; Log Item
           V
        log vector N    -&gt; memory buffer
                        -&gt; vector array
                        -&gt; Log Item</pre><p>Once this transfer is done, the CIL can be unlocked and new transactions can
start, while the checkpoint flush code works over the log vector chain to
commit the checkpoint.</p><p>Once the checkpoint is written into the log buffers, the checkpoint context is
attached to the log buffer that the commit record was written to along with a
completion callback. Log IO completion will call that callback, which can then
run transaction committed processing for the log items (i.e. insert into AIL
and unpin) in the log vector chain and then free the log vector chain and
checkpoint context.</p><p>Discussion Point: I am uncertain as to whether the log item is the most
efficient way to track vectors, even though it seems like the natural way to do
it. The fact that we walk the log items (in the CIL) just to chain the log
vectors and break the link between the log item and the log vector means that
we take a cache line hit for the log item list modification, then another for
the log vector chaining. If we track by the log vectors, then we only need to
break the link between the log item and the log vector, which means we should
dirty only the log item cachelines. Normally I wouldn’t be concerned about one
vs two dirty cachelines except for the fact I’ve seen upwards of 80,000 log
vectors in one checkpoint transaction. I’d guess this is a "measure and
compare" situation that can be done after a working and reviewed implementation
is in the dev tree….</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_checkpoint_sequencing"></a>3.3.4. Checkpoint Sequencing</h3></div></div></div><p>One of the key aspects of the XFS transaction subsystem is that it tags
committed transactions with the log sequence number of the transaction commit.
This allows transactions to be issued asynchronously even though there may be
future operations that cannot be completed until that transaction is fully
committed to the log. In the rare case that a dependent operation occurs (e.g.
re-using a freed metadata extent for a data extent), a special, optimised log
force can be issued to force the dependent transaction to disk immediately.</p><p>To do this, transactions need to record the LSN of the commit record of the
transaction. This LSN comes directly from the log buffer the transaction is
written into. While this works just fine for the existing transaction
mechanism, it does not work for delayed logging because transactions are not
written directly into the log buffers. Hence some other method of sequencing
transactions is required.</p><p>As discussed in the checkpoint section, delayed logging uses per-checkpoint
contexts, and as such it is simple to assign a sequence number to each
checkpoint. Because the switching of checkpoint contexts must be done
atomically, it is simple to ensure that each new context has a monotonically
increasing sequence number assigned to it without the need for an external
atomic counter - we can just take the current context sequence number and add
one to it for the new context.</p><p>Then, instead of assigning a log buffer LSN to the transaction commit LSN
during the commit, we can assign the current checkpoint sequence. This allows
operations that track transactions that have not yet completed know what
checkpoint sequence needs to be committed before they can continue. As a
result, the code that forces the log to a specific LSN now needs to ensure that
the log forces to a specific checkpoint.</p><p>To ensure that we can do this, we need to track all the checkpoint contexts
that are currently committing to the log. When we flush a checkpoint, the
context gets added to a "committing" list which can be searched. When a
checkpoint commit completes, it is removed from the committing list. Because
the checkpoint context records the LSN of the commit record for the checkpoint,
we can also wait on the log buffer that contains the commit record, thereby
using the existing log force mechanisms to execute synchronous forces.</p><p>It should be noted that the synchronous forces may need to be extended with
mitigation algorithms similar to the current log buffer code to allow
aggregation of multiple synchronous transactions if there are already
synchronous transactions being flushed. Investigation of the performance of the
current design is needed before making any decisions here.</p><p>The main concern with log forces is to ensure that all the previous checkpoints
are also committed to disk before the one we need to wait for. Therefore we
need to check that all the prior contexts in the committing list are also
complete before waiting on the one we need to complete. We do this
synchronisation in the log force code so that we don’t need to wait anywhere
else for such serialisation - it only matters when we do a log force.</p><p>The only remaining complexity is that a log force now also has to handle the
case where the forcing sequence number is the same as the current context. That
is, we need to flush the CIL and potentially wait for it to complete. This is a
simple addition to the existing log forcing code to check the sequence numbers
and push if required. Indeed, placing the current sequence checkpoint flush in
the log force code enables the current mechanism for issuing synchronous
transactions to remain untouched (i.e. commit an asynchronous transaction, then
force the log at the LSN of that transaction) and so the higher level code
behaves the same regardless of whether delayed logging is being used or not.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_checkpoint_log_space_accounting"></a>3.3.5. Checkpoint Log Space Accounting</h3></div></div></div><p>The big issue for a checkpoint transaction is the log space reservation for the
transaction. We don’t know how big a checkpoint transaction is going to be
ahead of time, nor how many log buffers it will take to write out, nor the
number of split log vector regions are going to be used. We can track the
amount of log space required as we add items to the commit item list, but we
still need to reserve the space in the log for the checkpoint.</p><p>A typical transaction reserves enough space in the log for the worst case space
usage of the transaction. The reservation accounts for log record headers,
transaction and region headers, headers for split regions, buffer tail padding,
etc. as well as the actual space for all the changed metadata in the
transaction. While some of this is fixed overhead, much of it is dependent on
the size of the transaction and the number of regions being logged (the number
of log vectors in the transaction).</p><p>An example of the differences would be logging directory changes versus logging
inode changes. If you modify lots of inode cores (e.g. chmod -R g+w *), then
there are lots of transactions that only contain an inode core and an inode log
format structure. That is, two vectors totaling roughly 150 bytes. If we modify
10,000 inodes, we have about 1.5MB of metadata to write in 20,000 vectors. Each
vector is 12 bytes, so the total to be logged is approximately 1.75MB. In
comparison, if we are logging full directory buffers, they are typically 4KB
each, so we in 1.5MB of directory buffers we’d have roughly 400 buffers and a
buffer format structure for each buffer - roughly 800 vectors or 1.51MB total
space.  From this, it should be obvious that a static log space reservation is
not particularly flexible and is difficult to select the "optimal value" for
all workloads.</p><p>Further, if we are going to use a static reservation, which bit of the entire
reservation does it cover? We account for space used by the transaction
reservation by tracking the space currently used by the object in the CIL and
then calculating the increase or decrease in space used as the object is
relogged. This allows for a checkpoint reservation to only have to account for
log buffer metadata used such as log header records.</p><p>However, even using a static reservation for just the log metadata is
problematic. Typically log record headers use at least 16KB of log space per
1MB of log space consumed (512 bytes per 32k) and the reservation needs to be
large enough to handle arbitrary sized checkpoint transactions. This
reservation needs to be made before the checkpoint is started, and we need to
be able to reserve the space without sleeping.  For a 8MB checkpoint, we need a
reservation of around 150KB, which is a non-trivial amount of space.</p><p>A static reservation needs to manipulate the log grant counters - we can take a
permanent reservation on the space, but we still need to make sure we refresh
the write reservation (the actual space available to the transaction) after
every checkpoint transaction completion. Unfortunately, if this space is not
available when required, then the regrant code will sleep waiting for it.</p><p>The problem with this is that it can lead to deadlocks as we may need to commit
checkpoints to be able to free up log space (refer back to the description of
rolling transactions for an example of this).  Hence we <span class="strong"><strong>must</strong></span> always have
space available in the log if we are to use static reservations, and that is
very difficult and complex to arrange. It is possible to do, but there is a
simpler way.</p><p>The simpler way of doing this is tracking the entire log space used by the
items in the CIL and using this to dynamically calculate the amount of log
space required by the log metadata. If this log metadata space changes as a
result of a transaction commit inserting a new memory buffer into the CIL, then
the difference in space required is removed from the transaction that causes
the change. Transactions at this level will <span class="strong"><strong>always</strong></span> have enough space
available in their reservation for this as they have already reserved the
maximal amount of log metadata space they require, and such a delta reservation
will always be less than or equal to the maximal amount in the reservation.</p><p>Hence we can grow the checkpoint transaction reservation dynamically as items
are added to the CIL and avoid the need for reserving and regranting log space
up front. This avoids deadlocks and removes a blocking point from the
checkpoint flush code.</p><p>As mentioned early, transactions can’t grow to more than half the size of the
log. Hence as part of the reservation growing, we need to also check the size
of the reservation against the maximum allowed transaction size. If we reach
the maximum threshold, we need to push the CIL to the log. This is effectively
a "background flush" and is done on demand. This is identical to
a CIL push triggered by a log force, only that there is no waiting for the
checkpoint commit to complete. This background push is checked and executed by
transaction commit code.</p><p>If the transaction subsystem goes idle while we still have items in the CIL,
they will be flushed by the periodic log force issued by the xfssyncd. This log
force will push the CIL to disk, and if the transaction subsystem stays idle,
allow the idle log to be covered (effectively marked clean) in exactly the same
manner that is done for the existing logging method. A discussion point is
whether this log force needs to be done more frequently than the current rate
which is once every 30s.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_log_item_pinning"></a>3.3.6. Log Item Pinning</h3></div></div></div><p>Currently log items are pinned during transaction commit while the items are
still locked. This happens just after the items are formatted, though it could
be done any time before the items are unlocked. The result of this mechanism is
that items get pinned once for every transaction that is committed to the log
buffers. Hence items that are relogged in the log buffers will have a pin count
for every outstanding transaction they were dirtied in. When each of these
transactions is completed, they will unpin the item once. As a result, the item
only becomes unpinned when all the transactions complete and there are no
pending transactions. Thus the pinning and unpinning of a log item is symmetric
as there is a 1:1 relationship with transaction commit and log item completion.</p><p>For delayed logging, however, we have an asymmetric transaction commit to
completion relationship. Every time an object is relogged in the CIL it goes
through the commit process without a corresponding completion being registered.
That is, we now have a many-to-one relationship between transaction commit and
log item completion. The result of this is that pinning and unpinning of the
log items becomes unbalanced if we retain the "pin on transaction commit, unpin
on transaction completion" model.</p><p>To keep pin/unpin symmetry, the algorithm needs to change to a "pin on
insertion into the CIL, unpin on checkpoint completion". In other words, the
pinning and unpinning becomes symmetric around a checkpoint context. We have to
pin the object the first time it is inserted into the CIL - if it is already in
the CIL during a transaction commit, then we do not pin it again. Because there
can be multiple outstanding checkpoint contexts, we can still see elevated pin
counts, but as each checkpoint completes the pin count will retain the correct
value according to it’s context.</p><p>Just to make matters more slightly more complex, this checkpoint level context
for the pin count means that the pinning of an item must take place under the
CIL commit/flush lock. If we pin the object outside this lock, we cannot
guarantee which context the pin count is associated with. This is because of
the fact pinning the item is dependent on whether the item is present in the
current CIL or not. If we don’t pin the CIL first before we check and pin the
object, we have a race with CIL being flushed between the check and the pin
(or not pinning, as the case may be). Hence we must hold the CIL flush/commit
lock to guarantee that we pin the items correctly.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_concurrent_scalability"></a>3.3.7. Concurrent Scalability</h3></div></div></div><p>A fundamental requirement for the CIL is that accesses through transaction
commits must scale to many concurrent commits. The current transaction commit
code does not break down even when there are transactions coming from 2048
processors at once. The current transaction code does not go any faster than if
there was only one CPU using it, but it does not slow down either.</p><p>As a result, the delayed logging transaction commit code needs to be designed
for concurrency from the ground up. It is obvious that there are serialisation
points in the design - the three important ones are:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">
Locking out new transaction commits while flushing the CIL
</li><li class="listitem">
Adding items to the CIL and updating item space accounting
</li><li class="listitem">
Checkpoint commit ordering
</li></ol></div><p>Looking at the transaction commit and CIL flushing interactions, it is clear
that we have a many-to-one interaction here. That is, the only restriction on
the number of concurrent transactions that can be trying to commit at once is
the amount of space available in the log for their reservations. The practical
limit here is in the order of several hundred concurrent transactions for a
128MB log, which means that it is generally one per CPU in a machine.</p><p>The amount of time a transaction commit needs to hold out a flush is a
relatively long period of time - the pinning of log items needs to be done
while we are holding out a CIL flush, so at the moment that means it is held
across the formatting of the objects into memory buffers (i.e. while memcpy()s
are in progress). Ultimately a two pass algorithm where the formatting is done
separately to the pinning of objects could be used to reduce the hold time of
the transaction commit side.</p><p>Because of the number of potential transaction commit side holders, the lock
really needs to be a sleeping lock - if the CIL flush takes the lock, we do not
want every other CPU in the machine spinning on the CIL lock. Given that
flushing the CIL could involve walking a list of tens of thousands of log
items, it will get held for a significant time and so spin contention is a
significant concern. Preventing lots of CPUs spinning doing nothing is the
main reason for choosing a sleeping lock even though nothing in either the
transaction commit or CIL flush side sleeps with the lock held.</p><p>It should also be noted that CIL flushing is also a relatively rare operation
compared to transaction commit for asynchronous transaction workloads - only
time will tell if using a read-write semaphore for exclusion will limit
transaction commit concurrency due to cache line bouncing of the lock on the
read side.</p><p>The second serialisation point is on the transaction commit side where items
are inserted into the CIL. Because transactions can enter this code
concurrently, the CIL needs to be protected separately from the above
commit/flush exclusion. It also needs to be an exclusive lock but it is only
held for a very short time and so a spin lock is appropriate here. It is
possible that this lock will become a contention point, but given the short
hold time once per transaction I think that contention is unlikely.</p><p>The final serialisation point is the checkpoint commit record ordering code
that is run as part of the checkpoint commit and log force sequencing. The code
path that triggers a CIL flush (i.e. whatever triggers the log force) will enter
an ordering loop after writing all the log vectors into the log buffers but
before writing the commit record. This loop walks the list of committing
checkpoints and needs to block waiting for checkpoints to complete their commit
record write. As a result it needs a lock and a wait variable. Log force
sequencing also requires the same lock, list walk, and blocking mechanism to
ensure completion of checkpoints.</p><p>These two sequencing operations can use the mechanism even though the
events they are waiting for are different. The checkpoint commit record
sequencing needs to wait until checkpoint contexts contain a commit LSN
(obtained through completion of a commit record write) while log force
sequencing needs to wait until previous checkpoint contexts are removed from
the committing list (i.e. they’ve completed). A simple wait variable and
broadcast wakeups (thundering herds) has been used to implement these two
serialisation queues. They use the same lock as the CIL, too. If we see too
much contention on the CIL lock, or too many context switches as a result of
the broadcast wakeups these operations can be put under a new spinlock and
given separate wait lists to reduce lock contention and the number of processes
woken by the wrong event.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_lifecycle_changes"></a>3.3.8. Lifecycle Changes</h3></div></div></div><p>The existing log item life cycle is as follows:</p><pre class="screen">        1. Transaction allocate
        2. Transaction reserve
        3. Lock item
        4. Join item to transaction
                If not already attached,
                        Allocate log item
                        Attach log item to owner item
                Attach log item to transaction
        5. Modify item
                Record modifications in log item
        6. Transaction commit
                Pin item in memory
                Format item into log buffer
                Write commit LSN into transaction
                Unlock item
                Attach transaction to log buffer

        &lt;log buffer IO dispatched&gt;
        &lt;log buffer IO completes&gt;

        7. Transaction completion
                Mark log item committed
                Insert log item into AIL
                        Write commit LSN into log item
                Unpin log item
        8. AIL traversal
                Lock item
                Mark log item clean
                Flush item to disk

        &lt;item IO completion&gt;

        9. Log item removed from AIL
                Moves log tail
                Item unlocked</pre><p>Essentially, steps 1-6 operate independently from step 7, which is also
independent of steps 8-9. An item can be locked in steps 1-6 or steps 8-9
at the same time step 7 is occurring, but only steps 1-6 or 8-9 can occur
at the same time. If the log item is in the AIL or between steps 6 and 7
and steps 1-6 are re-entered, then the item is relogged. Only when steps 8-9
are entered and completed is the object considered clean.</p><p>With delayed logging, there are new steps inserted into the life cycle:</p><pre class="screen">        1. Transaction allocate
        2. Transaction reserve
        3. Lock item
        4. Join item to transaction
                If not already attached,
                        Allocate log item
                        Attach log item to owner item
                Attach log item to transaction
        5. Modify item
                Record modifications in log item
        6. Transaction commit
                Pin item in memory if not pinned in CIL
                Format item into log vector + buffer
                Attach log vector and buffer to log item
                Insert log item into CIL
                Write CIL context sequence into transaction
                Unlock item

        &lt;next log force&gt;

        7. CIL push
                lock CIL flush
                Chain log vectors and buffers together
                Remove items from CIL
                unlock CIL flush
                write log vectors into log
                sequence commit records
                attach checkpoint context to log buffer

        &lt;log buffer IO dispatched&gt;
        &lt;log buffer IO completes&gt;

        8. Checkpoint completion
                Mark log item committed
                Insert item into AIL
                        Write commit LSN into log item
                Unpin log item
        9. AIL traversal
                Lock item
                Mark log item clean
                Flush item to disk
        &lt;item IO completion&gt;
        10. Log item removed from AIL
                Moves log tail
                Item unlocked</pre><p>From this, it can be seen that the only life cycle differences between the two
logging methods are in the middle of the life cycle - they still have the same
beginning and end and execution constraints. The only differences are in the
committing of the log items to the log itself and the completion processing.
Hence delayed logging should not introduce any constraints on log item
behaviour, allocation or freeing that don’t already exist.</p><p>As a result of this zero-impact "insertion" of delayed logging infrastructure
and the design of the internal structures to avoid on disk format changes, we
can basically switch between delayed logging and the existing mechanism with a
mount option. Fundamentally, there is no reason why the log manager would not
be able to swap methods automatically and transparently depending on load
characteristics, but this should not be necessary if delayed logging works as
designed.</p><p>EOF.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Reflink_Deduplication"></a>Chapter 4. Sharing Data Blocks</h2></div></div></div><p>On a traditional filesystem, there is a 1:1 mapping between a logical block
offset in a file and a physical block on disk, which is to say that physical
blocks are not shared.  However, there exist various use cases for being able
to share blocks between files — deduplicating files saves space on archival
systems; creating space-efficient clones of disk images for virtual machines
and containers facilitates efficient datacenters; and deferring the payment of
the allocation cost of a file system tree copy as long as possible makes
regular work faster.  In all of these cases, a write to one of the shared
copies <span class="strong"><strong>must</strong></span> not affect the other shared copies, which means that writes to
shared blocks must employ a copy-on-write strategy.  Sharing blocks in this
manner is commonly referred to as “reflinking”.</p><p>XFS implements block sharing in a fairly straightforward manner.  All existing
data fork structures remain unchanged, save for the addition of a
per-allocation group <a class="link" href="#Reference_Count_Btree" title="13.8. Reference Count B+tree">reference count B+tree</a>.  This
data structure tracks reference counts for all shared physical blocks, with a
few rules to maintain compatibility with existing code: If a block is free, it
will be tracked in the free space B+trees.  If a block is owned by a single
file, it appears in neither the free space nor the reference count B+trees.  If
a block is shared, it will appear in the reference count B+tree with a
reference count &gt;= 2.  The first two cases are established precedent in XFS, so
the third case is the only behavioral change.</p><p>When a filesystem block is shared, the block mapping in the destination file is
updated to point to that filesystem block and the reference count B+tree records
are updated to reflect the increased refcount.  If a shared block is written, a
new block will be allocated, the dirty data written to this new block, and the
file’s block mapping updated to point to the new block.  If a shared block is
unmapped, the reference count records are updated to reflect the decreased
refcount and the block is also freed if its reference count becomes zero.  This
enables users to create space efficient clones of disk images and to copy
filesystem subtrees quickly, using the standard Linux coreutils packages.</p><p>Deduplication employs the same mechanism to share blocks and copy them at write
time.  However, the kernel confirms that the contents of both files are
identical before updating the destination file’s mapping.  This enables XFS to
be used by userspace deduplication programs such as <code class="literal">duperemove</code>.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Reconstruction"></a>Chapter 5. Metadata Reconstruction</h2></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>This is a theoretical discussion of how reconstruction could work; none of this
is implemented as of 2015.</p></div><p>A simple UNIX filesystem can be thought of in terms of a directed acyclic graph.
To a first approximation, there exists a root directory node, which points to
other nodes.  Those other nodes can themselves be directories or they can be
files.  Each file, in turn, points to data blocks.</p><p>XFS adds a few more details to this picture:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The real root(s) of an XFS filesystem are the allocation group headers
(superblock, AGF, AGI, AGFL).
</li><li class="listitem">
Each allocation group’s headers point to various per-AG B+trees (free space,
inode, free inodes, free list, etc.)
</li><li class="listitem">
The free space B+trees point to unused extents;
</li><li class="listitem">
The inode B+trees point to blocks containing inode chunks;
</li><li class="listitem">
All superblocks point to the root directory and the log;
</li><li class="listitem">
Hardlinks mean that multiple directories can point to a single file node;
</li><li class="listitem">
File data block pointers are indexed by file offset;
</li><li class="listitem">
Files and directories can have a second collection of pointers to data blocks
which contain extended attributes;
</li><li class="listitem">
Large directories require multiple data blocks to store all the subpointers;
</li><li class="listitem">
Still larger directories use high-offset data blocks to store a B+tree of
hashes to directory entries;
</li><li class="listitem">
Large extended attribute forks similarly use high-offset data blocks to store
a B+tree of hashes to attribute keys; and
</li><li class="listitem">
Symbolic links can point to data blocks.
</li></ul></div><p>The beauty of this massive graph structure is that under normal circumstances,
everything known to the filesystem is discoverable (access controls
notwithstanding) from the root.  The major weakness of this structure of course
is that breaking a edge in the graph can render entire subtrees inaccessible.
<code class="literal">xfs_repair</code> “recovers” from broken directories by scanning for unlinked inodes
and connecting them to <code class="literal">/lost+found</code>, but this isn’t sufficiently general to
recover from breaks in other parts of the graph structure.  Wouldn’t it be
useful to have back pointers as a secondary data structure?  The current repair
strategy is to reconstruct whatever can be rebuilt, but to scrap anything that
doesn’t check out.</p><p>The <a class="link" href="#Reverse_Mapping_Btree" title="13.7. Reverse-Mapping B+tree">reverse-mapping B+tree</a> fills in part of the
puzzle.  Since it contains copies of every entry in each inode’s data and
attribute forks, we can fix a corrupted block map with these records.
Furthermore, if the inode B+trees become corrupt, it is possible to visit all
inode chunks using the reverse-mapping data.  Should XFS ever gain the ability
to store parent directory information in each inode, it also becomes possible
to resurrect damaged directory trees, which should reduce the complaints about
inodes ending up in <code class="literal">/lost+found</code>.  Everything else in the per-AG primary
metadata can already be reconstructed via <code class="literal">xfs_repair</code>.  Hopefully,
reconstruction will not turn out to be a fool’s errand.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_common_xfs_types"></a>Chapter 6. Common XFS Types</h2></div></div></div><p>All the following XFS types can be found in xfs_types.h. NULL values are always
-1 on disk (ie. all bits for the value set to one).</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>xfs_ino_t</strong></span>
</span></dt><dd>
Unsigned 64 bit absolute <a class="link" href="#Inode_Numbers" title="13.3.1. Inode Numbers">inode number</a>.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_off_t</strong></span>
</span></dt><dd>
Signed 64 bit file offset.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_daddr_t</strong></span>
</span></dt><dd>
Signed 64 bit disk address (sectors).
</dd><dt><span class="term">
<span class="strong"><strong>xfs_agnumber_t</strong></span>
</span></dt><dd>
Unsigned 32 bit <a class="link" href="#Allocation_Groups" title="Chapter 13. Allocation Groups">AG number</a>.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_agblock_t</strong></span>
</span></dt><dd>
Unsigned 32 bit AG relative block number.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_extlen_t</strong></span>
</span></dt><dd>
Unsigned 32 bit <a class="link" href="#Data_Extents" title="Chapter 17. Data Extents">extent</a> length in blocks.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_extnum_t</strong></span>
</span></dt><dd>
Signed 32 bit number of extents in a data fork.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_aextnum_t</strong></span>
</span></dt><dd>
Signed 16 bit number of extents in an attribute fork.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_dablk_t</strong></span>
</span></dt><dd>
Unsigned 32 bit block number for <a class="link" href="#Directories" title="Chapter 18. Directories">directories</a> and
<a class="link" href="#Extended_Attributes" title="Chapter 19. Extended Attributes">extended attributes</a>.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_dahash_t</strong></span>
</span></dt><dd>
Unsigned 32 bit hash of a directory file name or extended attribute name.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_fsblock_t</strong></span>
</span></dt><dd>
Unsigned 64 bit filesystem block number combining
<a class="link" href="#Allocation_Groups" title="Chapter 13. Allocation Groups">AG number</a> and block offset into the AG.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_rfsblock_t</strong></span>
</span></dt><dd>
Unsigned 64 bit raw filesystem block number.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_rtblock_t</strong></span>
</span></dt><dd>
Unsigned 64 bit extent number in the <a class="link" href="#Real-time_Devices" title="13.6. Real-time Devices">real-time</a>
sub-volume.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_fileoff_t</strong></span>
</span></dt><dd>
Unsigned 64 bit block offset into a file.
</dd><dt><span class="term">
<span class="strong"><strong>xfs_filblks_t</strong></span>
</span></dt><dd>
Unsigned 64 bit block count for a file.
</dd><dt><span class="term">
<span class="strong"><strong>uuid_t</strong></span>
</span></dt><dd>
16-byte universally unique identifier (UUID).
</dd><dt><span class="term">
<span class="strong"><strong>xfs_fsize_t</strong></span>
</span></dt><dd>
Signed 64 bit byte size of a file.
</dd></dl></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_magic_numbers"></a>Chapter 7. Magic Numbers</h2></div></div></div><p>These are the magic numbers that are known to XFS, along with links to the
relevant chapters.  Magic numbers tend to have consistent locations:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
32-bit magic numbers are always at offset zero in the block.
</li><li class="listitem">
16-bit magic numbers for the directory and attribute B+tree are at offset eight.
</li><li class="listitem">
The quota magic number is at offset zero.
</li><li class="listitem">
The inode magic is at the beginning of each inode.
</li></ul></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Hexadecimal   </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> ASCII </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Data structure</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x58465342</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XFSB</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Superblocks" title="13.1. Superblocks">Superblock</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_AGF_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x58414746</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XAGF</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#AG_Free_Space_Block" title="13.2.1. AG Free Space Block">Free Space</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_AGI_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x58414749</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XAGI</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Inode_Information" title="13.3.2. Inode Information">Inode Information</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_AGFL_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x5841464c</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XAFL</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#AG_Free_List" title="13.2.3. AG Free List">Free Space List</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DINODE_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x494e</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>IN</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Inode_Core" title="16.1. Inode Core">Inodes</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DQUOT_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x4451</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>DQ</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Quota_Inodes" title="15.1. Quota Inodes">Quota Inodes</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SYMLINK_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x58534c4d</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XSLM</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Extent_Symbolic_Links" title="20.2. Extent Symbolic Links">Symbolic Links</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ABTB_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x41425442</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>ABTB</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#AG_Free_Space_Btrees" title="13.2.2. AG Free Space B+trees">Free Space by Block B+tree</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ABTB_CRC_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x41423342</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>AB3B</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#AG_Free_Space_Btrees" title="13.2.2. AG Free Space B+trees">Free Space by Block B+tree</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ABTC_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x41425443</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>ABTC</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#AG_Free_Space_Btrees" title="13.2.2. AG Free Space B+trees">Free Space by Size B+tree</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ABTC_CRC_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x41423343</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>AB3C</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#AG_Free_Space_Btrees" title="13.2.2. AG Free Space B+trees">Free Space by Size B+tree</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_IBT_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x49414254</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>IABT</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Inode_Btrees" title="13.4. Inode B+trees">Inode B+tree</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_IBT_CRC_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x49414233</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>IAB3</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Inode_Btrees" title="13.4. Inode B+trees">Inode B+tree</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_FIBT_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x46494254</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>FIBT</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Inode_Btrees" title="13.4. Inode B+trees">Free Inode B+tree</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_FIBT_CRC_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x46494233</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>FIB3</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Inode_Btrees" title="13.4. Inode B+trees">Free Inode B+tree</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_BMAP_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x424d4150</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>BMAP</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Btree_Extent_List" title="17.2. B+tree Extent List">B+Tree Extent List</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_BMAP_CRC_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x424d4133</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>BMA3</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Btree_Extent_List" title="17.2. B+tree Extent List">B+Tree Extent List</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XLOG_HEADER_MAGIC_NUM</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0xfeedbabe</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Log_Records" title="14.1. Log Records">Log Records</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DA_NODE_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0xfebe</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Directory_Attribute_Internal_Node" title="11.2. Internal Nodes">Directory/Attribute Node</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DA3_NODE_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x3ebe</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Directory_Attribute_Internal_Node" title="11.2. Internal Nodes">Directory/Attribute Node</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR2_BLOCK_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x58443242</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XD2B</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Block_Directories" title="18.2. Block Directories">Block Directory Data</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_BLOCK_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x58444233</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XDB3</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Block_Directories" title="18.2. Block Directories">Block Directory Data</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR2_DATA_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x58443244</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XD2D</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Leaf_Directories" title="18.3. Leaf Directories">Leaf Directory Data</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_DATA_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x58444433</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XDD3</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Leaf_Directories" title="18.3. Leaf Directories">Leaf Directory Data</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR2_LEAF1_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0xd2f1</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Leaf_Directories" title="18.3. Leaf Directories">Leaf Directory</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_LEAF1_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x3df1</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Leaf_Directories" title="18.3. Leaf Directories">Leaf Directory</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR2_LEAFN_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0xd2ff</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Node_Directories" title="18.4. Node Directories">Node Directory</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_LEAFN_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x3dff</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Node_Directories" title="18.4. Node Directories">Node Directory</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR2_FREE_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x58443246</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XD2F</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Node_Directories" title="18.4. Node Directories">Node Directory Free Space</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_FREE_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x58444633</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XDF3</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Node_Directories" title="18.4. Node Directories">Node Directory Free Space</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ATTR_LEAF_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0xfbee</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Leaf_Attributes" title="19.2. Leaf Attributes">Leaf Attribute</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ATTR3_LEAF_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x3bee</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Leaf_Attributes" title="19.2. Leaf Attributes">Leaf Attribute</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ATTR3_RMT_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x5841524d</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XARM</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Remote_Values" title="19.5. Remote Attribute Values">Remote Attribute Value</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_CRC_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x524d4233</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>RMB3</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Reverse_Mapping_Btree" title="13.7. Reverse-Mapping B+tree">Reverse Mapping B+tree</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RTRMAP_CRC_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x4d415052</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>MAPR</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Real_time_Reverse_Mapping_Btree" title="15.2.3. Real-Time Reverse-Mapping B+tree">Real-Time Reverse Mapping B+tree</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_REFC_CRC_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x52334643</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>R3FC</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Reference_Count_Btree" title="13.8. Reference Count B+tree">Reference Count B+tree</a>, v5 only</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_MD_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>0x5846534d</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>XFSM</p></td><td style="" align="left" valign="top"><p><a class="link" href="#Metadata_Dumps" title="Chapter 21. Metadata Dumps">Metadata Dumps</a></p></td></tr></tbody></table></div><p>The magic numbers for log items are at offset zero in each log item, but items
are not aligned to blocks.</p><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Hexadecimal   </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> ASCII </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Data structure</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_HEADER_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x5452414e</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>TRAN</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Log_Transaction_Headers" title="14.3.1. Transaction Headers">Log Transactions</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_EFI</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1236</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#EFI_Log_Item" title="14.3.2. Intent to Free an Extent">Extent Freeing Intent Log Item</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_EFD</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1237</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#EFD_Log_Item" title="14.3.3. Completion of Intent to Free an Extent">Extent Freeing Done Log Item</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_IUNLINK</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1238</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unknown?</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_INODE</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x123b</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Inode_Log_Item" title="14.3.13. Inode Updates">Inode Updates Log Item</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_BUF</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x123c</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Buffer_Log_Item" title="14.3.15. Buffer Log Item">Buffer Writes Log Item</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_DQUOT</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x123d</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Quota_Update_Log_Item" title="14.3.17. Update Quota File">Update Quota Log Item</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_QUOTAOFF</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x123e</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Quota_Off_Log_Item" title="14.3.19. Disable Quota Log Item">Quota Off Log Item</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_ICREATE</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x123f</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Inode_Create_Log_Item" title="14.3.20. Inode Creation Log Item">Inode Creation Log Item</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_RUI</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1240</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#RUI_Log_Item" title="14.3.4. Reverse Mapping Updates Intent">Reverse Mapping Update Intent</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_RUD</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1241</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#RUD_Log_Item" title="14.3.5. Completion of Reverse Mapping Updates">Reverse Mapping Update Done</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_CUI</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1242</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#CUI_Log_Item" title="14.3.6. Reference Count Updates Intent">Reference Count Update Intent</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_CUD</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1243</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#CUD_Log_Item" title="14.3.7. Completion of Reference Count Updates">Reference Count Update Done</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_BUI</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1244</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#BUI_Log_Item" title="14.3.8. File Block Mapping Intent">File Block Mapping Update Intent</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_BUD</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1245</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#BUD_Log_Item" title="14.3.9. Completion of File Block Mapping Updates">File Block Mapping Update Done</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_ATTRI</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1246</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#ATTRI_Log_Item" title="14.3.10. Extended Attribute Update Intent">Extended Attribute Update Intent</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_ATTRD</code></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>0x1247</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p></p></td><td style="" align="left" valign="top"><p><a class="link" href="#ATTRD_Log_Item" title="14.3.11. Completion of Extended Attribute Updates">Extended Attribute Update Done</a></p></td></tr></tbody></table></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_theoretical_limits"></a>Chapter 8. Theoretical Limits</h2></div></div></div><p>XFS can create really big filesystems!</p><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Item                  </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> 1KiB blocks </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> 4KiB blocks </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> 64KiB blocks</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Blocks</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>52</sup></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>52</sup></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>52</sup></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Inodes</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>63</sup></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>63</sup></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>64</sup></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Allocation Groups</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>32</sup></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>32</sup></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>32</sup></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>File System Size</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>8EiB</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>8EiB</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>8EiB</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Blocks per AG</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>31</sup></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>31</sup></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>31</sup></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Inodes per AG</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>32</sup></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>32</sup></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>32</sup></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Max AG Size</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2TiB</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>8TiB</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>128TiB</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Blocks Per File</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>54</sup></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>54</sup></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>2<sup>54</sup></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>File Size</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>8EiB</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>8EiB</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>8EiB</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>Max Dir Size</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>32GiB</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>32GiB</p></td><td style="" align="left" valign="top"><p>32GiB</p></td></tr></tbody></table></div><p>Linux doesn’t support files or devices larger than 8EiB, so the block
limitations are largely ignorable.</p></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Testing"></a>Chapter 9. Testing Filesystem Changes</h2></div></div></div><p>People put a lot of trust in filesystems to preserve their data in a reliable
fashion.  To that end, it is very important that users and developers have
access to a suite of regression tests that can be used to prove correct
operation of any given filesystem code, or to analyze failures to fix problems
found in the code.  The XFS regression test suite, <code class="literal">xfstests</code>, is hosted at
<code class="literal">git://git.kernel.org/pub/scm/fs/xfs/xfstests-dev.git</code>.  Most tests apply to
filesystems in general, but the suite also contains tests for features specific
to each filesystem.</p><p>When fixing bugs, it is important to provide a testcase exposing the bug so
that the developers can avoid a future re-occurrence of the regression.
Furthermore, if you’re developing a new user-visible feature for XFS, please
help the rest of the development community to sustain and maintain the whole
codebase by providing generous test coverage to check its behavior.</p><p>When altering, adding, or removing an on-disk data structure, please remember
to update both the in-kernel structure size checks in <code class="literal">xfs_ondisk.h</code> and to
ensure that your changes are reflected in xfstest xfs/122.  These regression
tests enable us to detect compiler bugs, alignment problems, and anything
else that might result in the creation of incompatible filesystem images.</p></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="_global_structures"></a>Part II. Global Structures</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="_fixed_length_record_b_trees"></a>Chapter 10. Fixed Length Record B+trees</h2></div></div></div><p>XFS uses b+trees to index all metadata records.  This well known data structure
is used to provide efficient random and sequential access to metadata records
while minimizing seek times.  There are two btree formats: a short format
for records pertaining to a single allocation group, since all block pointers
in an AG are 32-bits in size; and a long format for records pertaining to a
file, since file data can have 64-bit block offsets.  Each b+tree block is
either a leaf node containing records, or an internal node containing keys and
pointers to other b+tree blocks.  The tree consists of a root block which may
point to some number of other blocks; blocks in the bottom level of the b+tree
contains only records.</p><p>Leaf blocks of both types of b+trees have the same general format: a header
describing the data in the block, and an array of records.  The specific header
formats are given in the next two sections, and the record format is provided
by the b+tree client itself.  The generic b+tree code does not have any
specific knowledge of the record format.</p><pre class="screen">+--------+------------+------------+
| header |   record   | records... |
+--------+------------+------------+</pre><p>Internal node blocks of both types of b+trees also have the same general
format: a header describing the data in the block, an array of keys, and an
array of pointers.  Each pointer may be associated with one or two keys.  The
first key uniquely identifies the first record accessible via the leftmost path
down the branch of the tree.</p><p>If the records in a b+tree are indexed by an interval, then a range of keys can
uniquely identify a single record.  For example, if a record covers blocks
12-16, then any one of the keys 12, 13, 14, 15, or 16 return the same record.
In this case, the key for the record describing "12-16" is 12.  If none of the
records overlap, we only need to store one key.</p><p>This is the format of a standard b+tree node:</p><pre class="screen">+--------+---------+---------+---------+---------+
| header |   key   | keys... |   ptr   | ptrs... |
+--------+---------+---------+---------+---------+</pre><p>If the b+tree records do not overlap, performing a b+tree lookup is simple.
Start with the root.  If it is a leaf block, perform a binary search of the
records until we find the record with a lower key than our search key.  If the
block is a node block, perform a binary search of the keys until we find a
key lower than our search key, then follow the pointer to the next block.
Repeat until we find a record.</p><p>However, if b+tree records contain intervals and are allowed to overlap, the
internal nodes of the b+tree become larger:</p><pre class="screen">+--------+---------+----------+---------+-------------+---------+---------+
| header | low key | high key | low key | high key... |   ptr   | ptrs... |
+--------+---------+----------+---------+-------------+---------+---------+</pre><p>The low keys are exactly the same as the keys in the non-overlapping b+tree.
High keys, however, are a little different.  Recall that a record with a key
consisting of an interval can be referenced by a number of keys.  Since the low
key of a record indexes the low end of that key range, the high key indexes the
high end of the key range.  Returning to the example above, the high key for
the record describing "12-16" is 16.  The high key recorded in a b+tree node
is the largest of the high keys of all records accessible under the subtree
rooted by the pointer.  For a level 1 node, this is the largest high key in
the pointed-to leaf node; for any other node, this is the largest of the high
keys in the pointed-to node.</p><p>Nodes and leaves use the same magic numbers.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Short_Format_Btrees"></a>10.1. Short Format B+trees</h2></div></div></div><p>Each allocation group uses a “short format” B+tree to index various
information about the allocation group.  The structure is called short format
because all block pointers are AG block numbers.  The trees use the following
header:</p><pre class="programlisting">struct xfs_btree_sblock {
     __be32                    bb_magic;
     __be16                    bb_level;
     __be16                    bb_numrecs;
     __be32                    bb_leftsib;
     __be32                    bb_rightsib;

     /* version 5 filesystem fields start here */
     __be64                    bb_blkno;
     __be64                    bb_lsn;
     uuid_t                    bb_uuid;
     __be32                    bb_owner;
     __le32                    bb_crc;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>bb_magic</strong></span>
</span></dt><dd>
Specifies the magic number for the per-AG B+tree block.
</dd><dt><span class="term">
<span class="strong"><strong>bb_level</strong></span>
</span></dt><dd>
The level of the tree in which this block is found.  If this value is 0, this
is a leaf block and contains records; otherwise, it is a node block and
contains keys and pointers.  Level values increase towards the root.
</dd><dt><span class="term">
<span class="strong"><strong>bb_numrecs</strong></span>
</span></dt><dd>
Number of records in this block.
</dd><dt><span class="term">
<span class="strong"><strong>bb_leftsib</strong></span>
</span></dt><dd>
AG block number of the left sibling of this B+tree node.
</dd><dt><span class="term">
<span class="strong"><strong>bb_rightsib</strong></span>
</span></dt><dd>
AG block number of the right sibling of this B+tree node.
</dd><dt><span class="term">
<span class="strong"><strong>bb_blkno</strong></span>
</span></dt><dd>
FS block number of this B+tree block.
</dd><dt><span class="term">
<span class="strong"><strong>bb_lsn</strong></span>
</span></dt><dd>
Log sequence number of the last write to this block.
</dd><dt><span class="term">
<span class="strong"><strong>bb_uuid</strong></span>
</span></dt><dd>
The UUID of this block, which must match either <code class="literal">sb_uuid</code> or <code class="literal">sb_meta_uuid</code>
depending on which features are set.
</dd><dt><span class="term">
<span class="strong"><strong>bb_owner</strong></span>
</span></dt><dd>
The AG number that this B+tree block ought to be in.
</dd><dt><span class="term">
<span class="strong"><strong>bb_crc</strong></span>
</span></dt><dd>
Checksum of the B+tree block.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Long_Format_Btrees"></a>10.2. Long Format B+trees</h2></div></div></div><p>Long format B+trees are similar to short format B+trees, except that their
block pointers are 64-bit filesystem block numbers instead of 32-bit AG block
numbers.  Because of this, long format b+trees can be (and usually are) rooted
in an inode’s data or attribute fork.  The nodes and leaves of this B+tree use
the <code class="literal">xfs_btree_lblock</code> declaration:</p><pre class="programlisting">struct xfs_btree_lblock {
     __be32                    bb_magic;
     __be16                    bb_level;
     __be16                    bb_numrecs;
     __be64                    bb_leftsib;
     __be64                    bb_rightsib;

     /* version 5 filesystem fields start here */
     __be64                    bb_blkno;
     __be64                    bb_lsn;
     uuid_t                    bb_uuid;
     __be64                    bb_owner;
     __le32                    bb_crc;
     __be32                    bb_pad;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>bb_magic</strong></span>
</span></dt><dd>
Specifies the magic number for the btree block.
</dd><dt><span class="term">
<span class="strong"><strong>bb_level</strong></span>
</span></dt><dd>
The level of the tree in which this block is found.  If this value is 0, this
is a leaf block and contains records; otherwise, it is a node block and
contains keys and pointers.
</dd><dt><span class="term">
<span class="strong"><strong>bb_numrecs</strong></span>
</span></dt><dd>
Number of records in this block.
</dd><dt><span class="term">
<span class="strong"><strong>bb_leftsib</strong></span>
</span></dt><dd>
FS block number of the left sibling of this B+tree node.
</dd><dt><span class="term">
<span class="strong"><strong>bb_rightsib</strong></span>
</span></dt><dd>
FS block number of the right sibling of this B+tree node.
</dd><dt><span class="term">
<span class="strong"><strong>bb_blkno</strong></span>
</span></dt><dd>
FS block number of this B+tree block.
</dd><dt><span class="term">
<span class="strong"><strong>bb_lsn</strong></span>
</span></dt><dd>
Log sequence number of the last write to this block.
</dd><dt><span class="term">
<span class="strong"><strong>bb_uuid</strong></span>
</span></dt><dd>
The UUID of this block, which must match either <code class="literal">sb_uuid</code> or <code class="literal">sb_meta_uuid</code>
depending on which features are set.
</dd><dt><span class="term">
<span class="strong"><strong>bb_owner</strong></span>
</span></dt><dd>
The AG number that this B+tree block ought to be in.
</dd><dt><span class="term">
<span class="strong"><strong>bb_crc</strong></span>
</span></dt><dd>
Checksum of the B+tree block.
</dd><dt><span class="term">
<span class="strong"><strong>bb_pad</strong></span>
</span></dt><dd>
Pads the structure to 64 bytes.
</dd></dl></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Directory_Attribute_Btree"></a>Chapter 11. Variable Length Record B+trees</h2></div></div></div><p>Directories and extended attributes are implemented as a simple
key-value record store inside the blocks pointed to by the data or
attribute fork of a file.  Blocks referenced by either data structure
are block offsets of an inode fork, not physical blocks.</p><p>Directory and attribute data are stored as a linear array of
variable-length records in the low blocks of a fork.  Both data types
share the property that record keys and record values are both arbitrary
and unique sequences of bytes.  See the respective sections about
<a class="link" href="#Directories" title="Chapter 18. Directories">directories</a> or <a class="link" href="#Extended_Attributes" title="Chapter 19. Extended Attributes">attributes</a>
for more information about the exact record formats.</p><p>The dir/attr b+tree (or "dabtree"), if present, computes a hash of the
record key to produce the b+tree key, and b+tree keys are used to index
the fork block in which the record may be found.  Unlike the
fixed-length b+trees, the variable length b+trees can index the same key
multiple times.  B+tree keypointers and records both take this format:</p><pre class="screen">+---------+--------------+
| hashval | before_block |
+---------+--------------+</pre><p>The "before block" is the block offset in the inode fork of the block in
which we can find the record whose hashed key is "hashval".  The hash
function is as follows:</p><pre class="programlisting">#define rol32(x,y)             (((x) &lt;&lt; (y)) | ((x) &gt;&gt; (32 - (y))))

xfs_dahash_t
xfs_da_hashname(const uint8_t *name, int namelen)
{
        xfs_dahash_t hash;

        /*
         * Do four characters at a time as long as we can.
         */
        for (hash = 0; namelen &gt;= 4; namelen -= 4, name += 4)
                hash = (name[0] &lt;&lt; 21) ^ (name[1] &lt;&lt; 14) ^ (name[2] &lt;&lt; 7) ^
                       (name[3] &lt;&lt; 0) ^ rol32(hash, 7 * 4);

        /*
         * Now do the rest of the characters.
         */
        switch (namelen) {
        case 3:
                return (name[0] &lt;&lt; 14) ^ (name[1] &lt;&lt; 7) ^ (name[2] &lt;&lt; 0) ^
                       rol32(hash, 7 * 3);
        case 2:
                return (name[0] &lt;&lt; 7) ^ (name[1] &lt;&lt; 0) ^ rol32(hash, 7 * 2);
        case 1:
                return (name[0] &lt;&lt; 0) ^ rol32(hash, 7 * 1);
        default: /* case 0: */
                return hash;
        }
}</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Directory_Attribute_Block_Header"></a>11.1. Block Headers</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Tree nodes, leaf and node <a class="link" href="#Directories" title="Chapter 18. Directories">directories</a>, and leaf and
node <a class="link" href="#Extended_Attributes" title="Chapter 19. Extended Attributes">extended attributes</a> use the
<code class="literal">xfs_da_blkinfo_t</code> filesystem block header.  The structure appears as
follows:
</li></ul></div><pre class="programlisting">typedef struct xfs_da_blkinfo {
     __be32                     forw;
     __be32                     back;
     __be16                     magic;
     __be16                     pad;
} xfs_da_blkinfo_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>forw</strong></span>
</span></dt><dd>
Logical block offset of the previous B+tree block at this level.
</dd><dt><span class="term">
<span class="strong"><strong>back</strong></span>
</span></dt><dd>
Logical block offset of the next B+tree block at this level.
</dd><dt><span class="term">
<span class="strong"><strong>magic</strong></span>
</span></dt><dd>
Magic number for this directory/attribute block.
</dd><dt><span class="term">
<span class="strong"><strong>pad</strong></span>
</span></dt><dd>
Padding to maintain alignment.
</dd></dl></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
On a v5 filesystem, the leaves use the <code class="literal">struct xfs_da3_blkinfo_t</code> filesystem
block header. This header is used in the same place as <code class="literal">xfs_da_blkinfo_t</code>:
</li></ul></div><pre class="programlisting">struct xfs_da3_blkinfo {
     /* these values are inside xfs_da_blkinfo */
     __be32                     forw;
     __be32                     back;
     __be16                     magic;
     __be16                     pad;

     __be32                     crc;
     __be64                     blkno;
     __be64                     lsn;
     uuid_t                     uuid;
     __be64                     owner;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>forw</strong></span>
</span></dt><dd>
Logical block offset of the previous B+tree block at this level.
</dd><dt><span class="term">
<span class="strong"><strong>back</strong></span>
</span></dt><dd>
Logical block offset of the next B+tree block at this level.
</dd><dt><span class="term">
<span class="strong"><strong>magic</strong></span>
</span></dt><dd>
Magic number for this directory/attribute block.
</dd><dt><span class="term">
<span class="strong"><strong>pad</strong></span>
</span></dt><dd>
Padding to maintain alignment.
</dd><dt><span class="term">
<span class="strong"><strong>crc</strong></span>
</span></dt><dd>
Checksum of the directory/attribute block.
</dd><dt><span class="term">
<span class="strong"><strong>blkno</strong></span>
</span></dt><dd>
Block number of this directory/attribute block.
</dd><dt><span class="term">
<span class="strong"><strong>lsn</strong></span>
</span></dt><dd>
Log sequence number of the last write to this block.
</dd><dt><span class="term">
<span class="strong"><strong>uuid</strong></span>
</span></dt><dd>
The UUID of this block, which must match either <code class="literal">sb_uuid</code> or <code class="literal">sb_meta_uuid</code>
depending on which features are set.
</dd><dt><span class="term">
<span class="strong"><strong>owner</strong></span>
</span></dt><dd>
The inode number that this directory/attribute block belongs to.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Directory_Attribute_Internal_Node"></a>11.2. Internal Nodes</h2></div></div></div><p>The nodes of a dabtree have the following format:</p><pre class="programlisting">typedef struct xfs_da_intnode {
     struct xfs_da_node_hdr {
           xfs_da_blkinfo_t     info;
           __uint16_t           count;
           __uint16_t           level;
     } hdr;
     struct xfs_da_node_entry {
           xfs_dahash_t         hashval;
           xfs_dablk_t          before;
     } btree[1];
} xfs_da_intnode_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>info</strong></span>
</span></dt><dd>
Directory/attribute block info.  The magic number is <code class="literal">XFS_DA_NODE_MAGIC</code>
(0xfebe).
</dd><dt><span class="term">
<span class="strong"><strong>count</strong></span>
</span></dt><dd>
Number of node entries in this block.
</dd><dt><span class="term">
<span class="strong"><strong>level</strong></span>
</span></dt><dd>
The level of this block in the B+tree.  Levels start at 1 for blocks
that point to directory or attribute data blocks and increase towards
the root.
</dd><dt><span class="term">
<span class="strong"><strong>hashval</strong></span>
</span></dt><dd>
The hash value of a particular record.
</dd><dt><span class="term">
<span class="strong"><strong>before</strong></span>
</span></dt><dd><p class="simpara">
The directory/attribute logical block containing all entries up to the
corresponding hash value.
</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
On a v5 filesystem, the directory/attribute node blocks have the following
structure:
</li></ul></div></dd></dl></div><pre class="programlisting">struct xfs_da3_intnode {
     struct xfs_da3_node_hdr {
           struct xfs_da3_blkinfo    info;
           __uint16_t                count;
           __uint16_t                level;
           __uint32_t                pad32;
     } hdr;
     struct xfs_da_node_entry {
           xfs_dahash_t              hashval;
           xfs_dablk_t               before;
     } btree[1];
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>info</strong></span>
</span></dt><dd>
Directory/attribute block info.  The magic number is <code class="literal">XFS_DA3_NODE_MAGIC</code>
(0x3ebe).
</dd><dt><span class="term">
<span class="strong"><strong>count</strong></span>
</span></dt><dd>
Number of node entries in this block.
</dd><dt><span class="term">
<span class="strong"><strong>level</strong></span>
</span></dt><dd>
The level of this block in the B+tree.  Levels start at 1 for blocks
that point to directory or attribute data blocks, and increase towards
the root.
</dd><dt><span class="term">
<span class="strong"><strong>pad32</strong></span>
</span></dt><dd>
Padding to maintain alignment.
</dd><dt><span class="term">
<span class="strong"><strong>hashval</strong></span>
</span></dt><dd>
The hash value of a particular record.
</dd><dt><span class="term">
<span class="strong"><strong>before</strong></span>
</span></dt><dd>
The directory/attribute logical block containing all entries up to the
corresponding hash value.
</dd></dl></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Timestamps"></a>Chapter 12. Timestamps</h2></div></div></div><p>XFS needs to be able to persist the concept of a point in time.  This chapter
discusses how timestamps are represented on disk.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Inode_Timestamps"></a>12.1. Inode Timestamps</h2></div></div></div><p>The filesystem preserves up to four different timestamps for each file stored
in the filesystem.  These quantities are: the time when the file was created
(<code class="literal">di_crtime</code>), the last time the file metadata were changed (<code class="literal">di_ctime</code>), the
last time the file contents were changed (<code class="literal">di_mtime</code>), and the last time the
file contents were accessed (<code class="literal">di_atime</code>).  The filesystem epoch is aligned with
the Unix epoch, which is to say that a value of all zeroes represents 00:00:00
UTC on January 1st, 1970.</p><p>Prior to the introduction of the bigtime feature, inode timestamps were
laid out as as segmented counter of seconds and nanoseconds:</p><pre class="programlisting">struct xfs_legacy_timestamp {
     __int32_t                 t_sec;
     __int32_t                 t_nsec;
};</pre><p>The smallest date this format can represent is 20:45:52 UTC on December 13st,
1901, and the largest date supported is 03:14:07 UTC on January 19, 2038.</p><p>With the introduction of the bigtime feature, the format is changed to
interpret the timestamp as a 64-bit count of nanoseconds since the smallest
date supported by the old encoding.  This means that the smallest date
supported is still 20:45:52 UTC on December 13st, 1901; but now the largest
date supported is 20:20:24 UTC on July 2nd, 2486.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Quota_Timers"></a>12.2. Quota Grace Period Expiration Timers</h2></div></div></div><p>XFS' quota control allows administrators to set a soft limit on each type of
resource that a regular user can consume: inodes, blocks, and realtime blocks.
The administrator can establish a grace period after which the soft limit
becomes a hard limit for the user.  Therefore, XFS needs to be able to store
the exact time when a grace period expires.</p><p>Prior to the introduction of the bigtime feature, quota grace period
expirations were unsigned 32-bit seconds counters, with the magic value zero
meaning that the soft limit has not been exceeded.  Therefore, the smallest
expiration date that can be expressed is 00:00:01 UTC on January 1st, 1970; and
the largest is 06:28:15 on February 7th, 2106.</p><p>With the introduction of the bigtime feature, the ondisk field now encodes the
upper 32 bits of an unsigned 34-bit seconds counter.  Zero is still a magic
value that means the soft limit has not been exceeded.  The smallest quota
expiration date is now 00:00:04 UTC on January 1st, 1970; and the largest is
20:20:24 UTC on July 2nd, 2486.  The format can encode slightly larger
expiration dates, but it was decided to end support for both timers at exactly
the same point.</p><p>The default grace periods are stored in the timer fields of the quota record
for id zero.  Since this quantity is an interval, these fields are always
interpreted as an unsigned 32 bit quantity.  Therefore, the longest possible
grace period is approximately 136 years, 29 weeks, 3 days, 6 hours, 28 minutes
and 15 seconds.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Allocation_Groups"></a>Chapter 13. Allocation Groups</h2></div></div></div><p>As mentioned earlier, XFS filesystems are divided into a number of equally
sized chunks called Allocation Groups. Each AG can almost be thought of as an
individual filesystem that maintains its own space usage. Each AG can be up to
one terabyte in size (512 bytes × 2<sup>31</sup>), regardless of the underlying device’s
sector size.</p><p>Each AG has the following characteristics:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
A super block describing overall filesystem info
</li><li class="listitem">
Free space management
</li><li class="listitem">
Inode allocation and tracking
</li><li class="listitem">
Reverse block-mapping index (optional)
</li><li class="listitem">
Data block reference count index (optional)
</li></ul></div><p>Having multiple AGs allows XFS to handle most operations in parallel without
degrading performance as the number of concurrent accesses increases.</p><p>The only global information maintained by the first AG (primary) is free space
across the filesystem and total inode counts. If the
<code class="literal">XFS_SB_VERSION2_LAZYSBCOUNTBIT</code> flag is set in the superblock, these are only
updated on-disk when the filesystem is cleanly unmounted (umount or shutdown).</p><p>Immediately after a <code class="literal">mkfs.xfs</code>, the primary AG has the following disk layout;
the subsequent AGs do not have any inodes allocated:</p><div class="figure"><a id="idm1648"></a><p class="title"><strong>Figure 13.1. Allocation group layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/6.png" alt="images/6.png" /></div></div></div><br class="figure-break" /><p>Each of these structures are expanded upon in the following sections.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Superblocks"></a>13.1. Superblocks</h2></div></div></div><p>Each AG starts with a superblock. The first one, in AG 0, is the primary
superblock which stores aggregate AG information. Secondary superblocks are
only used by xfs_repair when the primary superblock has been corrupted.  A
superblock is one sector in length.</p><p>The superblock is defined by the following structure. The description of each
field follows.</p><pre class="programlisting">struct xfs_sb
{
        __uint32_t              sb_magicnum;
        __uint32_t              sb_blocksize;
        xfs_rfsblock_t          sb_dblocks;
        xfs_rfsblock_t          sb_rblocks;
        xfs_rtblock_t           sb_rextents;
        uuid_t                  sb_uuid;
        xfs_fsblock_t           sb_logstart;
        xfs_ino_t               sb_rootino;
        xfs_ino_t               sb_rbmino;
        xfs_ino_t               sb_rsumino;
        xfs_agblock_t           sb_rextsize;
        xfs_agblock_t           sb_agblocks;
        xfs_agnumber_t          sb_agcount;
        xfs_extlen_t            sb_rbmblocks;
        xfs_extlen_t            sb_logblocks;
        __uint16_t              sb_versionnum;
        __uint16_t              sb_sectsize;
        __uint16_t              sb_inodesize;
        __uint16_t              sb_inopblock;
        char                    sb_fname[12];
        __uint8_t               sb_blocklog;
        __uint8_t               sb_sectlog;
        __uint8_t               sb_inodelog;
        __uint8_t               sb_inopblog;
        __uint8_t               sb_agblklog;
        __uint8_t               sb_rextslog;
        __uint8_t               sb_inprogress;
        __uint8_t               sb_imax_pct;
        __uint64_t              sb_icount;
        __uint64_t              sb_ifree;
        __uint64_t              sb_fdblocks;
        __uint64_t              sb_frextents;
        xfs_ino_t               sb_uquotino;
        xfs_ino_t               sb_gquotino;
        __uint16_t              sb_qflags;
        __uint8_t               sb_flags;
        __uint8_t               sb_shared_vn;
        xfs_extlen_t            sb_inoalignmt;
        __uint32_t              sb_unit;
        __uint32_t              sb_width;
        __uint8_t               sb_dirblklog;
        __uint8_t               sb_logsectlog;
        __uint16_t              sb_logsectsize;
        __uint32_t              sb_logsunit;
        __uint32_t              sb_features2;
        __uint32_t              sb_bad_features2;

        /* version 5 superblock fields start here */
        __uint32_t              sb_features_compat;
        __uint32_t              sb_features_ro_compat;
        __uint32_t              sb_features_incompat;
        __uint32_t              sb_features_log_incompat;

        __uint32_t              sb_crc;
        xfs_extlen_t            sb_spino_align;

        xfs_ino_t               sb_pquotino;
        xfs_lsn_t               sb_lsn;
        uuid_t                  sb_meta_uuid;
        xfs_ino_t               sb_rrmapino;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>sb_magicnum</strong></span>
</span></dt><dd>
Identifies the filesystem. Its value is <code class="literal">XFS_SB_MAGIC</code> “XFSB” (0x58465342).
</dd><dt><span class="term">
<span class="strong"><strong>sb_blocksize</strong></span>
</span></dt><dd>
The size of a basic unit of space allocation in bytes. Typically, this is 4096
(4KB) but can range from 512 to 65536 bytes.
</dd><dt><span class="term">
<span class="strong"><strong>sb_dblocks</strong></span>
</span></dt><dd>
Total number of blocks available for data and metadata on the filesystem.
</dd><dt><span class="term">
<span class="strong"><strong>sb_rblocks</strong></span>
</span></dt><dd>
Number blocks in the real-time disk device. Refer to
<a class="link" href="#Real-time_Devices" title="13.6. Real-time Devices">real-time sub-volumes</a> for more information.
</dd><dt><span class="term">
<span class="strong"><strong>sb_rextents</strong></span>
</span></dt><dd>
Number of extents on the real-time device.
</dd><dt><span class="term">
<span class="strong"><strong>sb_uuid</strong></span>
</span></dt><dd>
UUID (Universally Unique ID) for the filesystem. Filesystems can be mounted by
the UUID instead of device name.
</dd><dt><span class="term">
<span class="strong"><strong>sb_logstart</strong></span>
</span></dt><dd>
First block number for the journaling log if the log is internal (ie. not on a
separate disk device). For an external log device, this will be zero (the log
will also start on the first block on the log device).  The identity of the log
devices is not recorded in the filesystem, but the UUIDs of the filesystem and
the log device are compared to prevent corruption.
</dd><dt><span class="term">
<span class="strong"><strong>sb_rootino</strong></span>
</span></dt><dd>
Root inode number for the filesystem.  Normally, the root inode is at the
start of the first possible inode chunk in AG 0.  This is 128 when using a 4KB
block size.
</dd><dt><span class="term">
<span class="strong"><strong>sb_rbmino</strong></span>
</span></dt><dd>
Bitmap inode for real-time extents.
</dd><dt><span class="term">
<span class="strong"><strong>sb_rsumino</strong></span>
</span></dt><dd>
Summary inode for real-time bitmap.
</dd><dt><span class="term">
<span class="strong"><strong>sb_rextsize</strong></span>
</span></dt><dd>
Realtime extent size in blocks.
</dd><dt><span class="term">
<span class="strong"><strong>sb_agblocks</strong></span>
</span></dt><dd>
Size of each AG in blocks. For the actual size of the last AG, refer to the
<a class="link" href="#AG_Free_Space_Management" title="13.2. AG Free Space Management">free space</a> <code class="literal">agf_length</code> value.
</dd><dt><span class="term">
<span class="strong"><strong>sb_agcount</strong></span>
</span></dt><dd>
Number of AGs in the filesystem.
</dd><dt><span class="term">
<span class="strong"><strong>sb_rbmblocks</strong></span>
</span></dt><dd>
Number of real-time bitmap blocks.
</dd><dt><span class="term">
<span class="strong"><strong>sb_logblocks</strong></span>
</span></dt><dd>
Number of blocks for the journaling log.
</dd><dt><span class="term">
<span class="strong"><strong>sb_versionnum</strong></span>
</span></dt><dd>
Filesystem version number. This is a bitmask specifying the features enabled
when creating the filesystem. Any disk checking tools or drivers that do not
recognize any set bits must not operate upon the filesystem. Most of the flags
indicate features introduced over time. If the value of the lower nibble is &gt;=
4, the higher bits indicate feature flags as follows:
</dd></dl></div><div class="table"><a id="idm1746"></a><p class="title"><strong>Table 13.1. Version 4 Superblock version flags</strong></p><div class="table-contents"><table class="table" summary="Version 4 Superblock version flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION_ATTRBIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Set if any inode have extended attributes.  If this bit is set; the
<code class="literal">XFS_SB_VERSION2_ATTR2BIT</code> is not set; and the <code class="literal">attr2</code> mount flag is not
specified, the <code class="literal">di_forkoff</code> inode field will not be dynamically adjusted.
See the section about <a class="link" href="#Extended_Attribute_Versions" title="16.4.1. Extended Attribute Versions">extended attribute
versions</a> for more information.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION_NLINKBIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Set if any inodes use 32-bit di_nlink values.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION_QUOTABIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Quotas are enabled on the filesystem. This
also brings in the various quota fields in the superblock.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION_ALIGNBIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Set if sb_inoalignmt is used.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION_DALIGNBIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Set if sb_unit and sb_width are used.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION_SHAREDBIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Set if sb_shared_vn is used.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION_LOGV2BIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Version 2 journaling logs are used.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION_SECTORBIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Set if sb_sectsize is not 512.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION_EXTFLGBIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unwritten extents are used. This is always set.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION_DIRV2BIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Version 2 directories are used. This is always set.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION_MOREBITSBIT</code></p></td><td style="" align="left" valign="top"><p>Set if the sb_features2 field in the superblock contains more flags.</p></td></tr></tbody></table></div></div><br class="table-break" /><p>If the lower nibble of this value is 5, then this is a v5 filesystem; the
<code class="literal">XFS_SB_VERSION2_CRCBIT</code> feature must be set in <code class="literal">sb_features2</code>.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>sb_sectsize</strong></span>
</span></dt><dd>
Specifies the underlying disk sector size in bytes.  Typically this is 512 or
4096 bytes. This determines the minimum I/O alignment, especially for direct I/O.
</dd><dt><span class="term">
<span class="strong"><strong>sb_inodesize</strong></span>
</span></dt><dd>
Size of the inode in bytes. The default is 256 (2 inodes per standard sector)
but can be made as large as 2048 bytes when creating the filesystem.  On a v5
filesystem, the default and minimum inode size are both 512 bytes.
</dd><dt><span class="term">
<span class="strong"><strong>sb_inopblock</strong></span>
</span></dt><dd>
Number of inodes per block. This is equivalent to <code class="literal">sb_blocksize / sb_inodesize</code>.
</dd><dt><span class="term">
<span class="strong"><strong>sb_fname[12]</strong></span>
</span></dt><dd>
Name for the filesystem. This value can be used in the mount command.
</dd><dt><span class="term">
<span class="strong"><strong>sb_blocklog</strong></span>
</span></dt><dd>
log<sub>2</sub> value of <code class="literal">sb_blocksize</code>. In other terms, <code class="literal">sb_blocksize = 2<sup>sb_blocklog</sup></code>.
</dd><dt><span class="term">
<span class="strong"><strong>sb_sectlog</strong></span>
</span></dt><dd>
log<sub>2</sub> value of <code class="literal">sb_sectsize</code>.
</dd><dt><span class="term">
<span class="strong"><strong>sb_inodelog</strong></span>
</span></dt><dd>
log<sub>2</sub> value of <code class="literal">sb_inodesize</code>.
</dd><dt><span class="term">
<span class="strong"><strong>sb_inopblog</strong></span>
</span></dt><dd>
log<sub>2</sub> value of <code class="literal">sb_inopblock</code>.
</dd><dt><span class="term">
<span class="strong"><strong>sb_agblklog</strong></span>
</span></dt><dd>
log<sub>2</sub> value of <code class="literal">sb_agblocks</code> (rounded up). This value is used to generate inode
numbers and absolute block numbers defined in extent maps.
</dd><dt><span class="term">
<span class="strong"><strong>sb_rextslog</strong></span>
</span></dt><dd>
log<sub>2</sub> value of <code class="literal">sb_rextents</code>.
</dd><dt><span class="term">
<span class="strong"><strong>sb_inprogress</strong></span>
</span></dt><dd>
Flag specifying that the filesystem is being created.
</dd><dt><span class="term">
<span class="strong"><strong>sb_imax_pct</strong></span>
</span></dt><dd>
Maximum percentage of filesystem space that can be used for inodes. The default
value is 5%.
</dd><dt><span class="term">
<span class="strong"><strong>sb_icount</strong></span>
</span></dt><dd>
Global count for number inodes allocated on the filesystem. This is only
maintained in the first superblock.
</dd><dt><span class="term">
<span class="strong"><strong>sb_ifree</strong></span>
</span></dt><dd>
Global count of free inodes on the filesystem. This is only maintained in the
first superblock.
</dd><dt><span class="term">
<span class="strong"><strong>sb_fdblocks</strong></span>
</span></dt><dd>
Global count of free data blocks on the filesystem. This is only maintained in
the first superblock.
</dd><dt><span class="term">
<span class="strong"><strong>sb_frextents</strong></span>
</span></dt><dd>
Global count of free real-time extents on the filesystem. This is only
maintained in the first superblock.
</dd><dt><span class="term">
<span class="strong"><strong>sb_uquotino</strong></span>
</span></dt><dd>
Inode for user quotas. This and the following two quota fields only apply if
<code class="literal">XFS_SB_VERSION_QUOTABIT</code> flag is set in <code class="literal">sb_versionnum</code>. Refer to
<a class="link" href="#Quota_Inodes" title="15.1. Quota Inodes">quota inodes</a> for more information.
</dd><dt><span class="term">
<span class="strong"><strong>sb_gquotino</strong></span>
</span></dt><dd>
Inode for group or project quotas. Group and project quotas cannot be used at
the same time on v4 filesystems.  On a v5 filesystem, this inode always stores
group quota information.
</dd><dt><span class="term">
<span class="strong"><strong>sb_qflags</strong></span>
</span></dt><dd>
Quota flags. It can be a combination of the following flags:
</dd></dl></div><div class="table"><a id="idm1943"></a><p class="title"><strong>Table 13.2. Superblock quota flags</strong></p><div class="table-contents"><table class="table" summary="Superblock quota flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_UQUOTA_ACCT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>User quota accounting is enabled.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_UQUOTA_ENFD</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>User quotas are enforced.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_UQUOTA_CHKD</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>User quotas have been checked.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_PQUOTA_ACCT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Project quota accounting is enabled.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_OQUOTA_ENFD</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Other (group/project) quotas are enforced.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_OQUOTA_CHKD</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Other (group/project) quotas have been checked.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_GQUOTA_ACCT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Group quota accounting is enabled.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_GQUOTA_ENFD</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Group quotas are enforced.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_GQUOTA_CHKD</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Group quotas have been checked.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_PQUOTA_ENFD</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Project quotas are enforced.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_PQUOTA_CHKD</code></p></td><td style="" align="left" valign="top"><p>Project quotas have been checked.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>sb_flags</strong></span>
</span></dt><dd>
Miscellaneous flags.
</dd></dl></div><div class="table"><a id="idm2025"></a><p class="title"><strong>Table 13.3. Superblock flags</strong></p><div class="table-contents"><table class="table" summary="Superblock flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SBF_READONLY</code></p></td><td style="" align="left" valign="top"><p>Only read-only mounts allowed.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>sb_shared_vn</strong></span>
</span></dt><dd>
Reserved and must be zero (“vn” stands for version number).
</dd><dt><span class="term">
<span class="strong"><strong>sb_inoalignmt</strong></span>
</span></dt><dd>
Inode chunk alignment in fsblocks.  Prior to v5, the default value provided for
inode chunks to have an 8KiB alignment.  Starting with v5, the default value
scales with the multiple of the inode size over 256 bytes.  Concretely, this
means an alignment of 16KiB for 512-byte inodes, 32KiB for 1024-byte inodes,
etc.  If sparse inodes are enabled, the <code class="literal">ir_startino</code> field of each inode
B+tree record must be aligned to this block granularity, even if the inode
given by <code class="literal">ir_startino</code> itself is sparse.
</dd><dt><span class="term">
<span class="strong"><strong>sb_unit</strong></span>
</span></dt><dd>
Underlying stripe or raid unit in blocks.
</dd><dt><span class="term">
<span class="strong"><strong>sb_width</strong></span>
</span></dt><dd>
Underlying stripe or raid width in blocks.
</dd><dt><span class="term">
<span class="strong"><strong>sb_dirblklog</strong></span>
</span></dt><dd>
log<sub>2</sub> multiplier that determines the granularity of directory block allocations
in fsblocks.
</dd><dt><span class="term">
<span class="strong"><strong>sb_logsectlog</strong></span>
</span></dt><dd>
log<sub>2</sub> value of the log subvolume’s sector size. This is only used if the
journaling log is on a separate disk device (i.e. not internal).
</dd><dt><span class="term">
<span class="strong"><strong>sb_logsectsize</strong></span>
</span></dt><dd>
The log’s sector size in bytes if the filesystem uses an external log device.
</dd><dt><span class="term">
<span class="strong"><strong>sb_logsunit</strong></span>
</span></dt><dd>
The log device’s stripe or raid unit size. This only applies to version 2 logs
<code class="literal">XFS_SB_VERSION_LOGV2BIT</code> is set in <code class="literal">sb_versionnum</code>.
</dd><dt><span class="term">
<span class="strong"><strong>sb_features2</strong></span>
</span></dt><dd>
Additional version flags if <code class="literal">XFS_SB_VERSION_MOREBITSBIT</code> is set in
<code class="literal">sb_versionnum</code>. The currently defined additional features include:
</dd></dl></div><div class="table"><a id="idm2095"></a><p class="title"><strong>Table 13.4. Extended Version 4 Superblock flags</strong></p><div class="table-contents"><table class="table" summary="Extended Version 4 Superblock flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION2_LAZYSBCOUNTBIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Lazy global counters. Making a filesystem with this bit set can improve
performance. The global free space and inode counts are only updated in the
primary superblock when the filesystem is cleanly unmounted.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION2_ATTR2BIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Extended attributes version 2. Making a filesystem with this optimises the
inode layout of extended attributes.  If this bit is set and the <code class="literal">noattr2</code>
mount flag is not specified, the <code class="literal">di_forkoff</code> inode field will be dynamically
adjusted.  See the section about <a class="link" href="#Extended_Attribute_Versions" title="16.4.1. Extended Attribute Versions">extended
attribute versions</a> for more information.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION2_PARENTBIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Parent pointers. All inodes must have an extended attribute that points back to
its parent inode. The primary purpose for this information is in backup systems.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION2_PROJID32BIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>32-bit Project ID.  Inodes can be associated with a project ID number, which
can be used to enforce disk space usage quotas for a particular group of
directories.  This flag indicates that project IDs can be 32 bits in size.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION2_CRCBIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Metadata checksumming.  All metadata blocks have an extended header containing
the block checksum, a copy of the metadata UUID, the log sequence number of the
last update to prevent stale replays, and a back pointer to the owner of the
block.  This feature must be and can only be set if the lowest nibble of
<code class="literal">sb_versionnum</code> is set to 5.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_VERSION2_FTYPE</code></p></td><td style="" align="left" valign="top"><p>Directory file type.  Each directory entry records the type of the inode to
which the entry points.  This speeds up directory iteration by removing the
need to load every inode into memory.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>sb_bad_features2</strong></span>
</span></dt><dd>
This field mirrors <code class="literal">sb_features2</code>, due to past 64-bit alignment errors.
</dd><dt><span class="term">
<span class="strong"><strong>sb_features_compat</strong></span>
</span></dt><dd>
Read-write compatible feature flags.  The kernel can still read and write this
FS even if it doesn’t understand the flag.  Currently, there are no valid
flags.
</dd><dt><span class="term">
<span class="strong"><strong>sb_features_ro_compat</strong></span>
</span></dt><dd>
Read-only compatible feature flags.  The kernel can still read this FS even if
it doesn’t understand the flag.
</dd></dl></div><div class="table"><a id="idm2162"></a><p class="title"><strong>Table 13.5. Extended Version 5 Superblock Read-Only compatibility flags</strong></p><div class="table-contents"><table class="table" summary="Extended Version 5 Superblock Read-Only compatibility flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_FEAT_RO_COMPAT_FINOBT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Free inode B+tree.  Each allocation group contains a B+tree to track inode chunks
containing free inodes.  This is a performance optimization to reduce the time
required to allocate inodes.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_FEAT_RO_COMPAT_RMAPBT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Reverse mapping B+tree.  Each allocation group contains a B+tree containing
records mapping AG blocks to their owners.  See the section about
<a class="link" href="#Reconstruction" title="Chapter 5. Metadata Reconstruction">reconstruction</a> for more details.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_FEAT_RO_COMPAT_REFLINK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Reference count B+tree.  Each allocation group contains a B+tree to track the
reference counts of AG blocks.  This enables files to share data blocks safely.
See the section about <a class="link" href="#Reflink_Deduplication" title="Chapter 4. Sharing Data Blocks">reflink and deduplication</a> for
more details.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_FEAT_RO_COMPAT_INOBTCNT</code></p></td><td style="" align="left" valign="top"><p>Inode B+tree block counters.  Each allocation group’s inode (AGI) header
tracks the number of blocks in each of the inode B+trees.  This allows us
to have a slightly higher level of redundancy over the shape of the inode
btrees, and decreases the amount of time to compute the metadata B+tree
preallocations at mount time.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>sb_features_incompat</strong></span>
</span></dt><dd>
Read-write incompatible feature flags.  The kernel cannot read or write this
FS if it doesn’t understand the flag.
</dd></dl></div><div class="table"><a id="idm2204"></a><p class="title"><strong>Table 13.6. Extended Version 5 Superblock Read-Write incompatibility flags</strong></p><div class="table-contents"><table class="table" summary="Extended Version 5 Superblock Read-Write incompatibility flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_FEAT_INCOMPAT_FTYPE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Directory file type.  Each directory entry tracks the type of the inode to
which the entry points.  This is a performance optimization to remove the need
to load every inode into memory to iterate a directory.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_FEAT_INCOMPAT_SPINODES</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Sparse inodes.  This feature relaxes the requirement to allocate inodes in
chunks of 64.  When the free space is heavily fragmented, there might exist
plenty of free space but not enough contiguous free space to allocate a new
inode chunk.  With this feature, the user can continue to create files until
all free space is exhausted.</p>
<p>Unused space in the inode B+tree records are used to track which parts of the
inode chunk are not inodes.</p>
<p>See the chapter on <a class="link" href="#Sparse_Inodes" title="13.5. Sparse Inodes">Sparse Inodes</a> for more information.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_FEAT_INCOMPAT_META_UUID</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Metadata UUID.  The UUID stamped into each metadata block must match the value
in <code class="literal">sb_meta_uuid</code>.  This enables the administrator to change <code class="literal">sb_uuid</code> at will
without having to rewrite the entire filesystem.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_FEAT_INCOMPAT_BIGTIME</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Large timestamps.  Inode timestamps and quota expiration timers are extended to
support times through the year 2486.  See the section on
<a class="link" href="#Timestamps" title="Chapter 12. Timestamps">timestamps</a> for more information.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_FEAT_INCOMPAT_NEEDSREPAIR</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The filesystem is not in operable condition, and must be run through
xfs_repair before it can be mounted.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_FEAT_INCOMPAT_NREXT64</code></p></td><td style="" align="left" valign="top"><p>Large file fork extent counts.  This greatly expands the maximum number of
space mappings allowed in data and extended attribute file forks.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>sb_features_log_incompat</strong></span>
</span></dt><dd>
Read-write incompatible feature flags for the log.  The kernel cannot recover
the FS log if it doesn’t understand the flag.
</dd></dl></div><div class="table"><a id="idm2262"></a><p class="title"><strong>Table 13.7. Extended Version 5 Superblock Log incompatibility flags</strong></p><div class="table-contents"><table class="table" summary="Extended Version 5 Superblock Log incompatibility flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                                  </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_SB_FEAT_INCOMPAT_LOG_XATTRS</code></p></td><td style="" align="left" valign="top"><p>Extended attribute updates have been committed to the ondisk log.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>sb_crc</strong></span>
</span></dt><dd>
Superblock checksum.
</dd><dt><span class="term">
<span class="strong"><strong>sb_spino_align</strong></span>
</span></dt><dd>
Sparse inode alignment, in fsblocks.  Each chunk of inodes referenced by a
sparse inode B+tree record must be aligned to this block granularity.
</dd><dt><span class="term">
<span class="strong"><strong>sb_pquotino</strong></span>
</span></dt><dd>
Project quota inode.
</dd><dt><span class="term">
<span class="strong"><strong>sb_lsn</strong></span>
</span></dt><dd>
Log sequence number of the last superblock update.
</dd><dt><span class="term">
<span class="strong"><strong>sb_meta_uuid</strong></span>
</span></dt><dd>
If the <code class="literal">XFS_SB_FEAT_INCOMPAT_META_UUID</code> feature is set, then the UUID field in
all metadata blocks must match this UUID.  If not, the block header UUID field
must match <code class="literal">sb_uuid</code>.
</dd><dt><span class="term">
<span class="strong"><strong>sb_rrmapino</strong></span>
</span></dt><dd>
If the <code class="literal">XFS_SB_FEAT_RO_COMPAT_RMAPBT</code> feature is set and a real-time
device is present (<code class="literal">sb_rblocks</code> &gt; 0), this field points to an inode
that contains the root to the
<a class="link" href="#Real_time_Reverse_Mapping_Btree" title="15.2.3. Real-Time Reverse-Mapping B+tree">Real-Time Reverse Mapping B+tree</a>.
This field is zero otherwise.
</dd></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_superblock_example"></a>13.1.1. xfs_db Superblock Example</h3></div></div></div><p>A filesystem is made on a single disk with the following command:</p><pre class="screen"># mkfs.xfs -i attr=2 -n size=16384 -f /dev/sda7
meta-data=/dev/sda7              isize=256    agcount=16, agsize=3923122 blks
         =                       sectsz=512   attr=2
data     =                       bsize=4096   blocks=62769952, imaxpct=25
         =                       sunit=0      swidth=0 blks, unwritten=1
naming   =version 2              bsize=16384
log      =internal log           bsize=4096   blocks=30649, version=1
         =                       sectsz=512   sunit=0 blks
realtime =none                   extsz=65536  blocks=0, rtextents=0</pre><p>And in xfs_db, inspecting the superblock:</p><pre class="screen">xfs_db&gt; sb
xfs_db&gt; p
magicnum = 0x58465342
blocksize = 4096
dblocks = 62769952
rblocks = 0
rextents = 0
uuid = 32b24036-6931-45b4-b68c-cd5e7d9a1ca5
logstart = 33554436
rootino = 128
rbmino = 129
rsumino = 130
rextsize = 16
agblocks = 3923122
agcount = 16
rbmblocks = 0
logblocks = 30649
versionnum = 0xb084
sectsize = 512
inodesize = 256
inopblock = 16
fname = "\000\000\000\000\000\000\000\000\000\000\000\000"
blocklog = 12
sectlog = 9
inodelog = 8
inopblog = 4
agblklog = 22
rextslog = 0
inprogress = 0
imax_pct = 25
icount = 64
ifree = 61
fdblocks = 62739235
frextents = 0
uquotino = 0
gquotino = 0
qflags = 0
flags = 0
shared_vn = 0
inoalignmt = 2
unit = 0
width = 0
dirblklog = 2
logsectlog = 0
logsectsize = 0
logsunit = 0
features2 = 8</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="AG_Free_Space_Management"></a>13.2. AG Free Space Management</h2></div></div></div><p>The XFS filesystem tracks free space in an allocation group using two B+trees.
One B+tree tracks space by block number, the second by the size of the free
space block. This scheme allows XFS to find quickly free space near a given
block or of a given size.</p><p>All block numbers, indexes, and counts are AG relative.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="AG_Free_Space_Block"></a>13.2.1. AG Free Space Block</h3></div></div></div><p>The second sector in an AG contains the information about the two free space
B+trees and associated free space information for the AG. The “AG Free Space
Block” also knows as the <code class="literal">AGF</code>, uses the following structure:</p><pre class="programlisting">struct xfs_agf {
     __be32              agf_magicnum;
     __be32              agf_versionnum;
     __be32              agf_seqno;
     __be32              agf_length;
     __be32              agf_roots[XFS_BTNUM_AGF];
     __be32              agf_levels[XFS_BTNUM_AGF];
     __be32              agf_flfirst;
     __be32              agf_fllast;
     __be32              agf_flcount;
     __be32              agf_freeblks;
     __be32              agf_longest;
     __be32              agf_btreeblks;

     /* version 5 filesystem fields start here */
     uuid_t              agf_uuid;
     __be32              agf_rmap_blocks;
     __be32              agf_refcount_blocks;
     __be32              agf_refcount_root;
     __be32              agf_refcount_level;
     __be64              agf_spare64[14];

     /* unlogged fields, written during buffer writeback. */
     __be64              agf_lsn;
     __be32              agf_crc;
     __be32              agf_spare2;
};</pre><p>The rest of the bytes in the sector are zeroed. <code class="literal">XFS_BTNUM_AGF</code> is set to 3:
index 0 for the free space B+tree indexed by block number; index 1 for the free
space B+tree indexed by extent size; and index 2 for the reverse-mapping
B+tree.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>agf_magicnum</strong></span>
</span></dt><dd>
Specifies the magic number for the AGF sector: “XAGF” (0x58414746).
</dd><dt><span class="term">
<span class="strong"><strong>agf_versionnum</strong></span>
</span></dt><dd>
Set to <code class="literal">XFS_AGF_VERSION</code> which is currently 1.
</dd><dt><span class="term">
<span class="strong"><strong>agf_seqno</strong></span>
</span></dt><dd>
Specifies the AG number for the sector.
</dd><dt><span class="term">
<span class="strong"><strong>agf_length</strong></span>
</span></dt><dd>
Specifies the size of the AG in filesystem blocks. For all AGs except the last,
this must be equal to the superblock’s <code class="literal">sb_agblocks</code> value. For the last AG,
this could be less than the <code class="literal">sb_agblocks</code> value. It is this value that should
be used to determine the size of the AG.
</dd><dt><span class="term">
<span class="strong"><strong>agf_roots</strong></span>
</span></dt><dd>
Specifies the block number for the root of the two free space B+trees and the
reverse-mapping B+tree, if enabled.
</dd><dt><span class="term">
<span class="strong"><strong>agf_levels</strong></span>
</span></dt><dd>
Specifies the level or depth of the two free space B+trees and the
reverse-mapping B+tree, if enabled.  For a fresh AG, this value will be one,
and the “roots” will point to a single leaf of level 0.
</dd><dt><span class="term">
<span class="strong"><strong>agf_flfirst</strong></span>
</span></dt><dd>
Specifies the index of the first “free list” block. Free lists are covered in
more detail later on.
</dd><dt><span class="term">
<span class="strong"><strong>agf_fllast</strong></span>
</span></dt><dd>
Specifies the index of the last “free list” block.
</dd><dt><span class="term">
<span class="strong"><strong>agf_flcount</strong></span>
</span></dt><dd>
Specifies the number of blocks in the “free list”.
</dd><dt><span class="term">
<span class="strong"><strong>agf_freeblks</strong></span>
</span></dt><dd>
Specifies the current number of free blocks in the AG.
</dd><dt><span class="term">
<span class="strong"><strong>agf_longest</strong></span>
</span></dt><dd>
Specifies the number of blocks of longest contiguous free space in the AG.
</dd><dt><span class="term">
<span class="strong"><strong>agf_btreeblks</strong></span>
</span></dt><dd>
Specifies the number of blocks used for the free space B+trees. This is only
used if the <code class="literal">XFS_SB_VERSION2_LAZYSBCOUNTBIT</code> bit is set in <code class="literal">sb_features2</code>.
</dd><dt><span class="term">
<span class="strong"><strong>agf_uuid</strong></span>
</span></dt><dd>
The UUID of this block, which must match either <code class="literal">sb_uuid</code> or <code class="literal">sb_meta_uuid</code>
depending on which features are set.
</dd><dt><span class="term">
<span class="strong"><strong>agf_rmap_blocks</strong></span>
</span></dt><dd>
The size of the reverse mapping B+tree in this allocation group, in blocks.
</dd><dt><span class="term">
<span class="strong"><strong>agf_refcount_blocks</strong></span>
</span></dt><dd>
The size of the reference count B+tree in this allocation group, in blocks.
</dd><dt><span class="term">
<span class="strong"><strong>agf_refcount_root</strong></span>
</span></dt><dd>
Block number for the root of the reference count B+tree, if enabled.
</dd><dt><span class="term">
<span class="strong"><strong>agf_refcount_level</strong></span>
</span></dt><dd>
Depth of the reference count B+tree, if enabled.
</dd><dt><span class="term">
<span class="strong"><strong>agf_spare64</strong></span>
</span></dt><dd>
Empty space in the logged part of the AGF sector, for use for future features.
</dd><dt><span class="term">
<span class="strong"><strong>agf_lsn</strong></span>
</span></dt><dd>
Log sequence number of the last AGF write.
</dd><dt><span class="term">
<span class="strong"><strong>agf_crc</strong></span>
</span></dt><dd>
Checksum of the AGF sector.
</dd><dt><span class="term">
<span class="strong"><strong>agf_spare2</strong></span>
</span></dt><dd>
Empty space in the unlogged part of the AGF sector.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="AG_Free_Space_Btrees"></a>13.2.2. AG Free Space B+trees</h3></div></div></div><p>The two Free Space B+trees store a sorted array of block offset and block
counts in the leaves of the B+tree. The first B+tree is sorted by the offset,
the second by the count or size.</p><p>Leaf nodes contain a sorted array of offset/count pairs which are also used for
node keys:</p><pre class="programlisting">struct xfs_alloc_rec {
     __be32                    ar_startblock;
     __be32                    ar_blockcount;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>ar_startblock</strong></span>
</span></dt><dd>
AG block number of the start of the free space.
</dd><dt><span class="term">
<span class="strong"><strong>ar_blockcount</strong></span>
</span></dt><dd>
Length of the free space.
</dd></dl></div><p>Node pointers are an AG relative block pointer:</p><pre class="programlisting">typedef __be32 xfs_alloc_ptr_t;</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
As the free space tracking is AG relative, all the block numbers are only
32-bits.
</li><li class="listitem">
The <code class="literal">bb_magic</code> value depends on the B+tree: “ABTB” (0x41425442) for the block
offset B+tree, “ABTC” (0x41425443) for the block count B+tree.  On a v5
filesystem, these are “AB3B” (0x41423342) and “AB3C” (0x41423343),
respectively.
</li><li class="listitem">
The <code class="literal">xfs_btree_sblock_t</code> header is used for intermediate B+tree node as well
as the leaves.
</li><li class="listitem">
For a typical 4KB filesystem block size, the offset for the <code class="literal">xfs_alloc_ptr_t</code>
array would be <code class="literal">0xab0</code> (2736 decimal).
</li><li class="listitem">
There are a series of macros in <code class="literal">xfs_btree.h</code> for deriving the offsets,
counts, maximums, etc for the B+trees used in XFS.
</li></ul></div><p>The following diagram shows a single level B+tree which consists of one leaf:</p><div class="figure"><a id="idm2479"></a><p class="title"><strong>Figure 13.2. Freespace B+tree with one leaf.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/15a.png" alt="images/15a.png" /></div></div></div><br class="figure-break" /><p>With the intermediate nodes, the associated leaf pointers are stored in a
separate array about two thirds into the block. The following diagram
illustrates a 2-level B+tree for a free space B+tree:</p><div class="figure"><a id="idm2487"></a><p class="title"><strong>Figure 13.3. Multi-level freespace B+tree.</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/15b.png" alt="images/15b.png" /></div></div></div><br class="figure-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="AG_Free_List"></a>13.2.3. AG Free List</h3></div></div></div><p>The AG Free List is located in the 4<sup>th</sup> sector of each AG and is known as the
AGFL. It is an array of AG relative block pointers for reserved space for
growing the free space B+trees. This space cannot be used for general user data
including inodes, data, directories and extended attributes.</p><p>With a freshly made filesystem, 4 blocks are reserved immediately after the free
space B+tree root blocks (blocks 4 to 7). As they are used up as the free space
fragments, additional blocks will be reserved from the AG and added to the free
list array.  This size may increase as features are added.</p><p>As the free list array is located within a single sector, a typical device will
have space for 128 elements in the array (512 bytes per sector, 4 bytes per AG
relative block pointer). The actual size can be determined by using the
<code class="literal">XFS_AGFL_SIZE</code> macro.</p><p>Active elements in the array are specified by the
<a class="link" href="#AG_Free_Space_Block" title="13.2.1. AG Free Space Block">AGF’s</a> <code class="literal">agf_flfirst</code>, <code class="literal">agf_fllast</code> and <code class="literal">agf_flcount</code>
values. The array is managed as a circular list.</p><p>On a v5 filesystem, the following header precedes the free list entries:</p><pre class="programlisting">struct xfs_agfl {
     __be32              agfl_magicnum;
     __be32              agfl_seqno;
     uuid_t              agfl_uuid;
     __be64              agfl_lsn;
     __be32              agfl_crc;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>agfl_magicnum</strong></span>
</span></dt><dd>
Specifies the magic number for the AGFL sector: "XAFL" (0x5841464c).
</dd><dt><span class="term">
<span class="strong"><strong>agfl_seqno</strong></span>
</span></dt><dd>
Specifies the AG number for the sector.
</dd><dt><span class="term">
<span class="strong"><strong>agfl_uuid</strong></span>
</span></dt><dd>
The UUID of this block, which must match either <code class="literal">sb_uuid</code> or <code class="literal">sb_meta_uuid</code>
depending on which features are set.
</dd><dt><span class="term">
<span class="strong"><strong>agfl_lsn</strong></span>
</span></dt><dd>
Log sequence number of the last AGFL write.
</dd><dt><span class="term">
<span class="strong"><strong>agfl_crc</strong></span>
</span></dt><dd>
Checksum of the AGFL sector.
</dd></dl></div><p>On a v4 filesystem there is no header; the array of free block numbers begins
at the beginning of the sector.</p><div class="figure"><a id="idm2537"></a><p class="title"><strong>Figure 13.4. AG Free List layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/16.png" alt="images/16.png" /></div></div></div><br class="figure-break" /><p>The presence of these reserved blocks guarantees that the free space B+trees
can be updated if any blocks are freed by extent changes in a full AG.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_xfs_db_agf_example"></a>xfs_db AGF Example</h4></div></div></div><p>These examples are derived from an AG that has been deliberately fragmented.
The AGF:</p><pre class="screen">xfs_db&gt; agf 0
xfs_db&gt; p
magicnum = 0x58414746
versionnum = 1
seqno = 0
length = 3923122
bnoroot = 7
cntroot = 83343
bnolevel = 2
cntlevel = 2
flfirst = 22
fllast = 27
flcount = 6
freeblks = 3654234
longest = 3384327
btreeblks = 0</pre><p>In the AGFL, the active elements are from 22 to 27 inclusive which are obtained
from the <code class="literal">flfirst</code> and <code class="literal">fllast</code> values from the <code class="literal">agf</code> in the previous example:</p><pre class="screen">xfs_db&gt; agfl 0
xfs_db&gt; p
bno[0-127] = 0:4 1:5 2:6 3:7 4:83342 5:83343 6:83344 7:83345 8:83346 9:83347
             10:4 11:5 12:80205 13:80780 14:81496 15:81766 16:83346 17:4 18:5
             19:80205 20:82449 21:81496 22:81766 23:82455 24:80780 25:5
             26:80205 27:83344</pre><p>The root block of the free space B+tree sorted by block offset is found in the
AGF’s <code class="literal">bnoroot</code> value:</p><pre class="screen">xfs_db&gt; fsblock 7
xfs_db&gt; type bnobt
xfs_db&gt; p
magic = 0x41425442
level = 1
numrecs = 4
leftsib = null
rightsib = null
keys[1-4] = [startblock,blockcount]
           1:[12,16] 2:[184586,3] 3:[225579,1] 4:[511629,1]
ptrs[1-4] = 1:2 2:83347 3:6 4:4</pre><p>Blocks 2, 83347, 6 and 4 contain the leaves for the free space B+tree by
starting block. Block 2 would contain offsets 12 up to but not including 184586
while block 4 would have all offsets from 511629 to the end of the AG.</p><p>The root block of the free space B+tree sorted by block count is found in the
AGF’s <code class="literal">cntroot</code> value:</p><pre class="screen">xfs_db&gt; fsblock 83343
xfs_db&gt; type cntbt
xfs_db&gt; p
magic = 0x41425443
level = 1
numrecs = 4
leftsib = null
rightsib = null
keys[1-4] = [blockcount,startblock]
           1:[1,81496] 2:[1,511729] 3:[3,191875] 4:[6,184595]
ptrs[1-4] = 1:3 2:83345 3:83342 4:83346</pre><p>The leaf in block 3, in this example, would only contain single block counts.
The offsets are sorted in ascending order if the block count is the same.</p><p>Inspecting the leaf in block 83346, we can see the largest block at the end:</p><pre class="screen">xfs_db&gt; fsblock 83346
xfs_db&gt; type cntbt
xfs_db&gt; p
magic = 0x41425443
level = 0
numrecs = 344
leftsib = 83342
rightsib = null
recs[1-344] = [startblock,blockcount]
           1:[184595,6] 2:[187573,6] 3:[187776,6]
           ...
           342:[513712,755] 343:[230317,258229] 344:[538795,3384327]</pre><p>The longest block count (3384327) must be the same as the AGF’s <code class="literal">longest</code> value.</p></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="AG_Inode_Management"></a>13.3. AG Inode Management</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Inode_Numbers"></a>13.3.1. Inode Numbers</h3></div></div></div><p>Inode numbers in XFS come in two forms: AG relative and absolute.</p><p>AG relative inode numbers always fit within 32 bits. The number of bits actually
used is determined by the sum of the <a class="link" href="#Superblocks" title="13.1. Superblocks">superblock’s</a> <code class="literal">sb_inoplog</code>
and <code class="literal">sb_agblklog</code> values. Relative inode numbers are found within the AG’s inode
structures.</p><p>Absolute inode numbers include the AG number in the high bits, above the bits
used for the AG relative inode number. Absolute inode numbers are found in
<a class="link" href="#Directories" title="Chapter 18. Directories">directory</a> entries and the superblock.</p><div class="figure"><a id="idm2577"></a><p class="title"><strong>Figure 13.5. Inode number formats</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/18.png" alt="images/18.png" /></div></div></div><br class="figure-break" /></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Inode_Information"></a>13.3.2. Inode Information</h3></div></div></div><p>Each AG manages its own inodes. The third sector in the AG contains information
about the AG’s inodes and is known as the AGI.</p><p>The AGI uses the following structure:</p><pre class="programlisting">struct xfs_agi {
     __be32              agi_magicnum;
     __be32              agi_versionnum;
     __be32              agi_seqno
     __be32              agi_length;
     __be32              agi_count;
     __be32              agi_root;
     __be32              agi_level;
     __be32              agi_freecount;
     __be32              agi_newino;
     __be32              agi_dirino;
     __be32              agi_unlinked[64];

     /*
      * v5 filesystem fields start here; this marks the end of logging region 1
      * and start of logging region 2.
      */
     uuid_t              agi_uuid;
     __be32              agi_crc;
     __be32              agi_pad32;
     __be64              agi_lsn;

     __be32              agi_free_root;
     __be32              agi_free_level;

     __be32              agi_iblocks;
     __be32              agi_fblocks;

}</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>agi_magicnum</strong></span>
</span></dt><dd>
Specifies the magic number for the AGI sector: “XAGI” (0x58414749).
</dd><dt><span class="term">
<span class="strong"><strong>agi_versionnum</strong></span>
</span></dt><dd>
Set to <code class="literal">XFS_AGI_VERSION</code> which is currently 1.
</dd><dt><span class="term">
<span class="strong"><strong>agi_seqno</strong></span>
</span></dt><dd>
Specifies the AG number for the sector.
</dd><dt><span class="term">
<span class="strong"><strong>agi_length</strong></span>
</span></dt><dd>
Specifies the size of the AG in filesystem blocks.
</dd><dt><span class="term">
<span class="strong"><strong>agi_count</strong></span>
</span></dt><dd>
Specifies the number of inodes allocated for the AG.
</dd><dt><span class="term">
<span class="strong"><strong>agi_root</strong></span>
</span></dt><dd>
Specifies the block number in the AG containing the root of the inode B+tree.
</dd><dt><span class="term">
<span class="strong"><strong>agi_level</strong></span>
</span></dt><dd>
Specifies the number of levels in the inode B+tree.
</dd><dt><span class="term">
<span class="strong"><strong>agi_freecount</strong></span>
</span></dt><dd>
Specifies the number of free inodes in the AG.
</dd><dt><span class="term">
<span class="strong"><strong>agi_newino</strong></span>
</span></dt><dd>
Specifies AG-relative inode number of the most recently allocated chunk.
</dd><dt><span class="term">
<span class="strong"><strong>agi_dirino</strong></span>
</span></dt><dd>
Deprecated and not used, this is always set to NULL (-1).
</dd><dt><span class="term">
<span class="strong"><strong>agi_unlinked[64]</strong></span>
</span></dt><dd>
Hash table of unlinked (deleted) inodes that are still being referenced. Refer
to <a class="link" href="#Unlinked_Pointer" title="16.2. Unlinked Pointer">unlinked list pointers</a> for more information.
</dd><dt><span class="term">
<span class="strong"><strong>agi_uuid</strong></span>
</span></dt><dd>
The UUID of this block, which must match either <code class="literal">sb_uuid</code> or <code class="literal">sb_meta_uuid</code>
depending on which features are set.
</dd><dt><span class="term">
<span class="strong"><strong>agi_crc</strong></span>
</span></dt><dd>
Checksum of the AGI sector.
</dd><dt><span class="term">
<span class="strong"><strong>agi_pad32</strong></span>
</span></dt><dd>
Padding field, otherwise unused.
</dd><dt><span class="term">
<span class="strong"><strong>agi_lsn</strong></span>
</span></dt><dd>
Log sequence number of the last write to this block.
</dd><dt><span class="term">
<span class="strong"><strong>agi_free_root</strong></span>
</span></dt><dd>
Specifies the block number in the AG containing the root of the free inode
B+tree.
</dd><dt><span class="term">
<span class="strong"><strong>agi_free_level</strong></span>
</span></dt><dd>
Specifies the number of levels in the free inode B+tree.
</dd><dt><span class="term">
<span class="strong"><strong>agi_iblocks</strong></span>
</span></dt><dd>
The number of blocks in the inode B+tree, including the root.
This field is zero if the <code class="literal">XFS_SB_FEAT_RO_COMPAT_INOBTCNT</code> feature is not
enabled.
</dd><dt><span class="term">
<span class="strong"><strong>agi_fblocks</strong></span>
</span></dt><dd>
The number of blocks in the free inode B+tree, including the root.
This field is zero if the <code class="literal">XFS_SB_FEAT_RO_COMPAT_INOBTCNT</code> feature is not
enabled.
</dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Inode_Btrees"></a>13.4. Inode B+trees</h2></div></div></div><p>Inodes are traditionally allocated in chunks of 64, and a B+tree is used to
track these chunks of inodes as they are allocated and freed. The block
containing root of the B+tree is defined by the AGI’s <code class="literal">agi_root</code> value.  If the
<code class="literal">XFS_SB_FEAT_RO_COMPAT_FINOBT</code> feature is enabled, a second B+tree is used to
track the chunks containing free inodes; this is an optimization to speed up
inode allocation.</p><p>The B+tree header for the nodes and leaves use the <code class="literal">xfs_btree_sblock</code> structure
which is the same as the header used in the <a class="link" href="#AG_Free_Space_Btrees" title="13.2.2. AG Free Space B+trees">AGF
B+trees</a>.</p><p>The magic number of the inode B+tree is “IABT” (0x49414254).  On a v5
filesystem, the magic number is “IAB3” (0x49414233).</p><p>The magic number of the free inode B+tree is “FIBT” (0x46494254).  On a v5
filesystem, the magic number is “FIB3” (0x46494254).</p><p>Leaves contain an array of the following structure:</p><pre class="programlisting">struct xfs_inobt_rec {
     __be32                    ir_startino;
     __be32                    ir_freecount;
     __be64                    ir_free;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>ir_startino</strong></span>
</span></dt><dd>
The lowest-numbered inode in this chunk.
</dd><dt><span class="term">
<span class="strong"><strong>ir_freecount</strong></span>
</span></dt><dd>
Number of free inodes in this chunk.
</dd><dt><span class="term">
<span class="strong"><strong>ir_free</strong></span>
</span></dt><dd>
A 64 element bitmap showing which inodes in this chunk are free.
</dd></dl></div><p>Nodes contain key/pointer pairs using the following types:</p><pre class="programlisting">struct xfs_inobt_key {
     __be32                     ir_startino;
};
typedef __be32 xfs_inobt_ptr_t;</pre><p>The following diagram illustrates a single level inode B+tree:</p><div class="figure"><a id="idm2722"></a><p class="title"><strong>Figure 13.6. Single Level inode B+tree</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/20a.png" alt="images/20a.png" /></div></div></div><br class="figure-break" /><p>And a 2-level inode B+tree:</p><div class="figure"><a id="idm2730"></a><p class="title"><strong>Figure 13.7. Multi-Level inode B+tree</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/20b.png" alt="images/20b.png" /></div></div></div><br class="figure-break" /><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_agi_example"></a>13.4.1. xfs_db AGI Example</h3></div></div></div><p>This is an AGI of a freshly populated filesystem:</p><pre class="screen">xfs_db&gt; agi 0
xfs_db&gt; p
magicnum = 0x58414749
versionnum = 1
seqno = 0
length = 825457
count = 5440
root = 3
level = 1
freecount = 9
newino = 5792
dirino = null
unlinked[0-63] =
uuid = 3dfa1e5c-5a5f-4ca2-829a-000e453600fe
lsn = 0x1000032c2
crc = 0x14cb7e5c (correct)
free_root = 4
free_level = 1</pre><p>From this example, we see that the inode B+tree is rooted at AG block 3 and
that the free inode B+tree is rooted at AG block 4.  Let’s look at the
inode B+tree:</p><pre class="screen">xfs_db&gt; addr root
xfs_db&gt; p
magic = 0x49414233
level = 0
numrecs = 85
leftsib = null
rightsib = null
bno = 24
lsn = 0x1000032c2
uuid = 3dfa1e5c-5a5f-4ca2-829a-000e453600fe
owner = 0
crc = 0x768f9592 (correct)
recs[1-85] = [startino,freecount,free]
        1:[96,0,0] 2:[160,0,0] 3:[224,0,0] 4:[288,0,0]
        5:[352,0,0] 6:[416,0,0] 7:[480,0,0] 8:[544,0,0]
        9:[608,0,0] 10:[672,0,0] 11:[736,0,0] 12:[800,0,0]
        ...
        85:[5792,9,0xff80000000000000]</pre><p>Most of the inode chunks on this filesystem are totally full, since the <code class="literal">free</code>
value is zero.  This means that we ought to expect inode 160 to be linked
somewhere in the directory structure.  However, notice that 0xff80000000000000
in record 85 — this means that we would expect inode 5847 to be free.  Moving
on to the free inode B+tree, we see that this is indeed the case:</p><pre class="screen">xfs_db&gt; addr free_root
xfs_db&gt; p
magic = 0x46494233
level = 0
numrecs = 1
leftsib = null
rightsib = null
bno = 32
lsn = 0x1000032c2
uuid = 3dfa1e5c-5a5f-4ca2-829a-000e453600fe
owner = 0
crc = 0x338af88a (correct)
recs[1] = [startino,freecount,free] 1:[5792,9,0xff80000000000000]</pre><p>Observe also that the AGI’s <code class="literal">agi_newino</code> points to this chunk, which has never
been fully allocated.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Sparse_Inodes"></a>13.5. Sparse Inodes</h2></div></div></div><p>As mentioned in the previous section, XFS allocates inodes in chunks of 64.  If
there are no free extents large enough to hold a full chunk of 64 inodes, the
inode allocation fails and XFS claims to have run out of space.  On a
filesystem with highly fragmented free space, this can lead to out of space
errors long before the filesystem runs out of free blocks.</p><p>The sparse inode feature tracks inode chunks in the inode B+tree as if they
were full chunks but uses some previously unused bits in the freecount field to
track which parts of the inode chunk are not allocated for use as inodes.  This
allows XFS to allocate inodes one block at a time if absolutely necessary.</p><p>The inode and free inode B+trees operate in the same manner as they do without
the sparse inode feature; the B+tree header for the nodes and leaves use the
<code class="literal">xfs_btree_sblock</code> structure which is the same as the header used in the
<a class="link" href="#AG_Free_Space_Btrees" title="13.2.2. AG Free Space B+trees">AGF B+trees</a>.</p><p>It is theoretically possible for a sparse inode B+tree record to reference
multiple non-contiguous inode chunks.</p><p>Leaves contain an array of the following structure:</p><pre class="programlisting">struct xfs_inobt_rec {
     __be32                    ir_startino;
     __be16                    ir_holemask;
     __u8                      ir_count;
     __u8                      ir_freecount;
     __be64                    ir_free;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>ir_startino</strong></span>
</span></dt><dd>
The lowest-numbered inode in this chunk, rounded down to the nearest multiple
of 64, even if the start of this chunk is sparse.
</dd><dt><span class="term">
<span class="strong"><strong>ir_holemask</strong></span>
</span></dt><dd>
A 16 element bitmap showing which parts of the chunk are not allocated to
inodes.  Each bit represents four inodes; if a bit is marked here, the
corresponding bits in ir_free must also be marked.
</dd><dt><span class="term">
<span class="strong"><strong>ir_count</strong></span>
</span></dt><dd>
Number of inodes allocated to this chunk.
</dd><dt><span class="term">
<span class="strong"><strong>ir_freecount</strong></span>
</span></dt><dd>
Number of free inodes in this chunk.
</dd><dt><span class="term">
<span class="strong"><strong>ir_free</strong></span>
</span></dt><dd>
A 64 element bitmap showing which inodes in this chunk are not available for
allocation.
</dd></dl></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_sparse_inode_agi_example"></a>13.5.1. xfs_db Sparse Inode AGI Example</h3></div></div></div><p>This example derives from an AG that has been deliberately fragmented.  The
inode B+tree:</p><pre class="screen">xfs_db&gt; agi 0
xfs_db&gt; p
magicnum = 0x58414749
versionnum = 1
seqno = 0
length = 6400
count = 10432
root = 2381
level = 2
freecount = 0
newino = 14912
dirino = null
unlinked[0-63] =
uuid = b9b4623b-f678-4d48-8ce7-ce08950e3cd6
lsn = 0x600000ac4
crc = 0xef550dbc (correct)
free_root = 4
free_level = 1</pre><p>This AGI was formatted on a v5 filesystem; notice the extra v5 fields.  So far
everything else looks much the same as always.</p><pre class="screen">xfs_db&gt; addr root
magic = 0x49414233
level = 1
numrecs = 2
leftsib = null
rightsib = null
bno = 19048
lsn = 0x50000192b
uuid = b9b4623b-f678-4d48-8ce7-ce08950e3cd6
owner = 0
crc = 0xd98cd2ca (correct)
keys[1-2] = [startino] 1:[128] 2:[35136]
ptrs[1-2] = 1:3 2:2380
xfs_db&gt; addr ptrs[1]
xfs_db&gt; p
magic = 0x49414233
level = 0
numrecs = 159
leftsib = null
rightsib = 2380
bno = 24
lsn = 0x600000ac4
uuid = b9b4623b-f678-4d48-8ce7-ce08950e3cd6
owner = 0
crc = 0x836768a6 (correct)
recs[1-159] = [startino,holemask,count,freecount,free]
        1:[128,0,64,0,0]
        2:[14912,0xff,32,0,0xffffffff]
        3:[15040,0,64,0,0]
        4:[15168,0xff00,32,0,0xffffffff00000000]
        5:[15296,0,64,0,0]
        6:[15424,0xff,32,0,0xffffffff]
        7:[15552,0,64,0,0]
        8:[15680,0xff00,32,0,0xffffffff00000000]
        9:[15808,0,64,0,0]
        10:[15936,0xff,32,0,0xffffffff]</pre><p>Here we see the difference in the inode B+tree records.  For example, in record
2, we see that the holemask has a value of 0xff.  This means that the first
sixteen inodes in this chunk record do not actually map to inode blocks; the
first inode in this chunk is actually inode 14944:</p><pre class="screen">xfs_db&gt; inode 14912
Metadata corruption detected at block 0x3a40/0x2000
...
Metadata CRC error detected for ino 14912
xfs_db&gt; p core.magic
core.magic = 0
xfs_db&gt; inode 14944
xfs_db&gt; p core.magic
core.magic = 0x494e</pre><p>The chunk record also indicates that this chunk has 32 inodes, and that the
missing inodes are also “free”.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Real-time_Devices"></a>13.6. Real-time Devices</h2></div></div></div><p>The performance of the standard XFS allocator varies depending on the internal
state of the various metadata indices enabled on the filesystem.  For
applications which need to minimize the jitter of allocation latency, XFS
supports the notion of a “real-time device”.  This is a special device
separate from the regular filesystem where extent allocations are tracked with
a bitmap and free space is indexed with a two-dimensional array.  If an inode
is flagged with <code class="literal">XFS_DIFLAG_REALTIME</code>, its data will live on the real time
device.  The metadata for real time devices is discussed in the section about
<a class="link" href="#Real-time_Inodes" title="15.2. Real-time Inodes">real time inodes</a>.</p><p>By placing the real time device (and the journal) on separate high-performance
storage devices, it is possible to reduce most of the unpredictability in I/O
response times that come from metadata operations.</p><p>None of the XFS per-AG B+trees are involved with real time files.  It is not
possible for real time files to share data blocks.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Reverse_Mapping_Btree"></a>13.7. Reverse-Mapping B+tree</h2></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>This data structure is under construction!  Details may change.</p></div><p>If the feature is enabled, each allocation group has its own reverse
block-mapping B+tree, which grows in the free space like the free space
B+trees.  As mentioned in the chapter about
<a class="link" href="#Reconstruction" title="Chapter 5. Metadata Reconstruction">reconstruction</a>, this data structure is another piece of
the puzzle necessary to reconstruct the data or attribute fork of a file from
reverse-mapping records; we can also use it to double-check allocations to
ensure that we are not accidentally cross-linking blocks, which can cause
severe damage to the filesystem.</p><p>This B+tree is only present if the <code class="literal">XFS_SB_FEAT_RO_COMPAT_RMAPBT</code>
feature is enabled.  The feature requires a version 5 filesystem.</p><p>Each record in the reverse-mapping B+tree has the following structure:</p><pre class="programlisting">struct xfs_rmap_rec {
     __be32                     rm_startblock;
     __be32                     rm_blockcount;
     __be64                     rm_owner;
     __be64                     rm_fork:1;
     __be64                     rm_bmbt:1;
     __be64                     rm_unwritten:1;
     __be64                     rm_unused:7;
     __be64                     rm_offset:54;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>rm_startblock</strong></span>
</span></dt><dd>
AG block number of this record.
</dd><dt><span class="term">
<span class="strong"><strong>rm_blockcount</strong></span>
</span></dt><dd>
The length of this extent.
</dd><dt><span class="term">
<span class="strong"><strong>rm_owner</strong></span>
</span></dt><dd>
A 64-bit number describing the owner of this extent.  This is typically the
absolute inode number, but can also correspond to one of the following:
</dd></dl></div><div class="table"><a id="idm2826"></a><p class="title"><strong>Table 13.8. Special owner values</strong></p><div class="table-contents"><table class="table" summary="Special owner values" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Value                         </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_OWN_NULL</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>No owner.  This should never appear on disk.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_OWN_UNKNOWN</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unknown owner; for EFI recovery.  This should never appear on disk.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_OWN_FS</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Allocation group headers</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_OWN_LOG</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>XFS log blocks</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_OWN_AG</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Per-allocation group B+tree blocks.  This means free space B+tree blocks, blocks on the freelist, and reverse-mapping B+tree blocks.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_OWN_INOBT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Per-allocation group inode B+tree blocks.  This includes free inode B+tree blocks.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_OWN_INODES</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Inode chunks</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_OWN_REFC</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Per-allocation group refcount B+tree blocks.  This will be used for reflink support.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_OWN_COW</code></p></td><td style="" align="left" valign="top"><p>Blocks that have been reserved for a copy-on-write operation that has not completed.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>rm_fork</strong></span>
</span></dt><dd>
If <code class="literal">rm_owner</code> describes an inode, this can be 1 if this record is for an
attribute fork.
</dd><dt><span class="term">
<span class="strong"><strong>rm_bmbt</strong></span>
</span></dt><dd>
If <code class="literal">rm_owner</code> describes an inode, this can be 1 to signify that this record is
for a block map B+tree block.  In this case, <code class="literal">rm_offset</code> has no meaning.
</dd><dt><span class="term">
<span class="strong"><strong>rm_unwritten</strong></span>
</span></dt><dd>
A flag indicating that the extent is unwritten.  This corresponds to the flag in
the <a class="link" href="#Data_Extents" title="Chapter 17. Data Extents">extent record</a> format which means <code class="literal">XFS_EXT_UNWRITTEN</code>.
</dd><dt><span class="term">
<span class="strong"><strong>rm_offset</strong></span>
</span></dt><dd>
The 54-bit logical file block offset, if <code class="literal">rm_owner</code> describes an inode.
Meaningless otherwise.
</dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The single-bit flag values <code class="literal">rm_unwritten</code>, <code class="literal">rm_fork</code>, and <code class="literal">rm_bmbt</code> are packed
into the larger fields in the C structure definition.</p></div><p>The key has the following structure:</p><pre class="programlisting">struct xfs_rmap_key {
     __be32                     rm_startblock;
     __be64                     rm_owner;
     __be64                     rm_fork:1;
     __be64                     rm_bmbt:1;
     __be64                     rm_reserved:1;
     __be64                     rm_unused:7;
     __be64                     rm_offset:54;
};</pre><p>For the reverse-mapping B+tree on a filesystem that supports sharing of file
data blocks, the key definition is larger than the usual AG block number.  On a
classic XFS filesystem, each block has only one owner, which means that
<code class="literal">rm_startblock</code> is sufficient to uniquely identify each record.  However,
shared block support (reflink) on XFS breaks that assumption; now filesystem
blocks can be linked to any logical block offset of any file inode.  Therefore,
the key must include the owner and offset information to preserve the 1 to 1
relation between key and record.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
As the reference counting is AG relative, all the block numbers are only
32-bits.
</li><li class="listitem">
The <code class="literal">bb_magic</code> value is "RMB3" (0x524d4233).
</li><li class="listitem">
The <code class="literal">xfs_btree_sblock_t</code> header is used for intermediate B+tree node as well
as the leaves.
</li><li class="listitem">
Each pointer is associated with two keys.  The first of these is the "low
key", which is the key of the smallest record accessible through the pointer.
This low key has the same meaning as the key in all other btrees.  The second
key is the high key, which is the maximum of the largest key that can be used
to access a given record underneath the pointer.  Recall that each record
in the reverse mapping b+tree describes an interval of physical blocks mapped
to an interval of logical file block offsets; therefore, it makes sense that
a range of keys can be used to find to a record.
</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_rmapbt_example"></a>13.7.1. xfs_db rmapbt Example</h3></div></div></div><p>This example shows a reverse-mapping B+tree from a freshly populated root
filesystem:</p><pre class="screen">xfs_db&gt; agf 0
xfs_db&gt; addr rmaproot
xfs_db&gt; p
magic = 0x524d4233
level = 1
numrecs = 43
leftsib = null
rightsib = null
bno = 56
lsn = 0x3000004c8
uuid = 1977221d-8345-464e-b1f4-aa2ea36895f4
owner = 0
crc = 0x7cf8be6f (correct)
keys[1-43] = [startblock,owner,offset]
keys[1-43] = [startblock,owner,offset,attrfork,bmbtblock,startblock_hi,owner_hi,
             offset_hi,attrfork_hi,bmbtblock_hi]
        1:[0,-3,0,0,0,351,4418,66,0,0]
        2:[417,285,0,0,0,827,4419,2,0,0]
        3:[829,499,0,0,0,2352,573,55,0,0]
        4:[1292,710,0,0,0,32168,262923,47,0,0]
        5:[32215,-5,0,0,0,34655,2365,3411,0,0]
        6:[34083,1161,0,0,0,34895,265220,1,0,1]
        7:[34896,256191,0,0,0,36522,-9,0,0,0]
        ...
        41:[50998,326734,0,0,0,51430,-5,0,0,0]
        42:[51431,327010,0,0,0,51600,325722,11,0,0]
        43:[51611,327112,0,0,0,94063,23522,28375272,0,0]
ptrs[1-43] = 1:5 2:6 3:8 4:9 5:10 6:11 7:418 ... 41:46377 42:48784 43:49522</pre><p>We arbitrarily pick pointer 17 to traverse downwards:</p><pre class="screen">xfs_db&gt; addr ptrs[17]
xfs_db&gt; p
magic = 0x524d4233
level = 0
numrecs = 168
leftsib = 36284
rightsib = 37617
bno = 294760
lsn = 0x200002761
uuid = 1977221d-8345-464e-b1f4-aa2ea36895f4
owner = 0
crc = 0x2dad3fbe (correct)
recs[1-168] = [startblock,blockcount,owner,offset,extentflag,attrfork,bmbtblock]
        1:[40326,1,259615,0,0,0,0] 2:[40327,1,-5,0,0,0,0]
        3:[40328,2,259618,0,0,0,0] 4:[40330,1,259619,0,0,0,0]
        ...
        127:[40540,1,324266,0,0,0,0] 128:[40541,1,324266,8388608,0,0,0]
        129:[40542,2,324266,1,0,0,0] 130:[40544,32,-7,0,0,0,0]</pre><p>Several interesting things pop out here.  The first record shows that inode
259,615 has mapped AG block 40,326 at offset 0.  We confirm this by looking at
the block map for that inode:</p><pre class="screen">xfs_db&gt; inode 259615
xfs_db&gt; bmap
data offset 0 startblock 40326 (0/40326) count 1 flag 0</pre><p>Next, notice records 127 and 128, which describe neighboring AG blocks that are
mapped to non-contiguous logical blocks in inode 324,266.  Given the logical
offset of 8,388,608 we surmise that this is a leaf directory, but let us
confirm:</p><pre class="screen">xfs_db&gt; inode 324266
xfs_db&gt; p core.mode
core.mode = 040755
xfs_db&gt; bmap
data offset 0 startblock 40540 (0/40540) count 1 flag 0
data offset 1 startblock 40542 (0/40542) count 2 flag 0
data offset 3 startblock 40576 (0/40576) count 1 flag 0
data offset 8388608 startblock 40541 (0/40541) count 1 flag 0
xfs_db&gt; p core.mode
core.mode = 0100644
xfs_db&gt; dblock 0
xfs_db&gt; p dhdr.hdr.magic
dhdr.hdr.magic = 0x58444433
xfs_db&gt; dblock 8388608
xfs_db&gt; p lhdr.info.hdr.magic
lhdr.info.hdr.magic = 0x3df1</pre><p>Indeed, this inode 324,266 appears to be a leaf directory, as it has regular
directory data blocks at low offsets, and a single leaf block.</p><p>Notice further the two reverse-mapping records with negative owners.  An owner
of -7 corresponds to <code class="literal">XFS_RMAP_OWN_INODES</code>, which is an inode chunk, and an
owner code of -5 corresponds to <code class="literal">XFS_RMAP_OWN_AG</code>, which covers free space
B+trees and free space.  Let’s see if block 40,544 is part of an inode chunk:</p><pre class="screen">xfs_db&gt; blockget
xfs_db&gt; fsblock 40544
xfs_db&gt; blockuse
block 40544 (0/40544) type inode
xfs_db&gt; stack
1:
        byte offset 166068224, length 4096
        buffer block 324352 (fsbno 40544), 8 bbs
        inode 324266, dir inode 324266, type data
xfs_db&gt; type inode
xfs_db&gt; p
core.magic = 0x494e</pre><p>Our suspicions are confirmed.  Let’s also see if 40,327 is part of a free space
tree:</p><pre class="screen">xfs_db&gt; fsblock 40327
xfs_db&gt; blockuse
block 40327 (0/40327) type btrmap
xfs_db&gt; type rmapbt
xfs_db&gt; p
magic = 0x524d4233</pre><p>As you can see, the reverse block-mapping B+tree is an important secondary
metadata structure, which can be used to reconstruct damaged primary metadata.
Now let’s look at an extend rmap btree:</p><pre class="screen">xfs_db&gt; agf 0
xfs_db&gt; addr rmaproot
xfs_db&gt; p
magic = 0x34524d42
level = 1
numrecs = 5
leftsib = null
rightsib = null
bno = 6368
lsn = 0x100000d1b
uuid = 400f0928-6b88-4c37-af1e-cef1f8911f3f
owner = 0
crc = 0x8d4ace05 (correct)
keys[1-5] = [startblock,owner,offset,attrfork,bmbtblock,startblock_hi,owner_hi,offset_hi,attrfork_hi,bmbtblock_hi]
1:[0,-3,0,0,0,705,132,681,0,0]
2:[24,5761,0,0,0,548,5761,524,0,0]
3:[24,5929,0,0,0,380,5929,356,0,0]
4:[24,6097,0,0,0,212,6097,188,0,0]
5:[24,6277,0,0,0,807,-7,0,0,0]
ptrs[1-5] = 1:5 2:771 3:9 4:10 5:11</pre><p>The second pointer stores both the low key [24,5761,0,0,0] and the high key
[548,5761,524,0,0], which means that we can expect block 771 to contain records
starting at physical block 24, inode 5761, offset zero; and that one of the
records can be used to find a reverse mapping for physical block 548, inode
5761, and offset 524:</p><pre class="screen">xfs_db&gt; addr ptrs[2]
xfs_db&gt; p
magic = 0x34524d42
level = 0
numrecs = 168
leftsib = 5
rightsib = 9
bno = 6168
lsn = 0x100000d1b
uuid = 400f0928-6b88-4c37-af1e-cef1f8911f3f
owner = 0
crc = 0xd58eff0e (correct)
recs[1-168] = [startblock,blockcount,owner,offset,extentflag,attrfork,bmbtblock]
1:[24,525,5761,0,0,0,0]
2:[24,524,5762,0,0,0,0]
3:[24,523,5763,0,0,0,0]
...
166:[24,360,5926,0,0,0,0]
167:[24,359,5927,0,0,0,0]
168:[24,358,5928,0,0,0,0]</pre><p>Observe that the first record in the block starts at physical block 24, inode
5761, offset zero, just as we expected.  Note that this first record is also
indexed by the highest key as provided in the node block; physical block 548,
inode 5761, offset 524 is the very last block mapped by this record.  Furthermore,
note that record 168, despite being the last record in this block, has a lower
maximum key (physical block 382, inode 5928, offset 23) than the first record.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Reference_Count_Btree"></a>13.8. Reference Count B+tree</h2></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>This data structure is under construction!  Details may change.</p></div><p>To support the sharing of file data blocks (reflink), each allocation group has
its own reference count B+tree, which grows in the allocated space like the
inode B+trees.  This data could be collected by performing an interval query of
the reverse-mapping B+tree, but doing so would come at a huge performance
penalty.  Therefore, this data structure is a cache of computable information.</p><p>This B+tree is only present if the <code class="literal">XFS_SB_FEAT_RO_COMPAT_REFLINK</code>
feature is enabled.  The feature requires a version 5 filesystem.</p><p>Each record in the reference count B+tree has the following structure:</p><pre class="programlisting">struct xfs_refcount_rec {
     __be32                     rc_startblock;
     __be32                     rc_blockcount;
     __be32                     rc_refcount;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>rc_startblock</strong></span>
</span></dt><dd>
AG block number of this record.  The high bit is set for all records
referring to an extent that is being used to stage a copy on write
operation.  This reduces recovery time during mount operations.  The
reference count of these staging events must only be 1.
</dd><dt><span class="term">
<span class="strong"><strong>rc_blockcount</strong></span>
</span></dt><dd>
The length of this extent.
</dd><dt><span class="term">
<span class="strong"><strong>rc_refcount</strong></span>
</span></dt><dd>
Number of mappings of this filesystem extent.
</dd></dl></div><p>Node pointers are an AG relative block pointer:</p><pre class="programlisting">struct xfs_refcount_key {
     __be32                     rc_startblock;
};</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
As the reference counting is AG relative, all the block numbers are only
32-bits.
</li><li class="listitem">
The <code class="literal">bb_magic</code> value is "R3FC" (0x52334643).
</li><li class="listitem">
The <code class="literal">xfs_btree_sblock_t</code> header is used for intermediate B+tree node as well
as the leaves.
</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_refcntbt_example"></a>13.8.1. xfs_db refcntbt Example</h3></div></div></div><p>For this example, an XFS filesystem was populated with a root filesystem and
a deduplication program was run to create shared blocks:</p><pre class="screen">xfs_db&gt; agf 0
xfs_db&gt; addr refcntroot
xfs_db&gt; p
magic = 0x52334643
level = 1
numrecs = 6
leftsib = null
rightsib = null
bno = 36892
lsn = 0x200004ec2
uuid = f1f89746-e00b-49c9-96b3-ecef0f2f14ae
owner = 0
crc = 0x75f35128 (correct)
keys[1-6] = [startblock] 1:[14] 2:[65633] 3:[65780] 4:[94571] 5:[117201] 6:[152442]
ptrs[1-6] = 1:7 2:25836 3:25835 4:18447 5:18445 6:18449
xfs_db&gt; addr ptrs[3]
xfs_db&gt; p
magic = 0x52334643
level = 0
numrecs = 80
leftsib = 25836
rightsib = 18447
bno = 51670
lsn = 0x200004ec2
uuid = f1f89746-e00b-49c9-96b3-ecef0f2f14ae
owner = 0
crc = 0xc3962813 (correct)
recs[1-80] = [startblock,blockcount,refcount,cowflag]
        1:[65780,1,2,0] 2:[65781,1,3,0] 3:[65785,2,2,0] 4:[66640,1,2,0]
        5:[69602,4,2,0] 6:[72256,16,2,0] 7:[72871,4,2,0] 8:[72879,20,2,0]
        9:[73395,4,2,0] 10:[75063,4,2,0] 11:[79093,4,2,0] 12:[86344,16,2,0]
        ...
        80:[35235,10,1,1]</pre><p>Notice record 80.  The copy on write flag is set and the reference count is
1, which indicates that the extent 35,235 - 35,244 are being used to stage a
copy on write activity.  The "cowflag" field is the high bit of rc_startblock.</p><p>Record 6 in the reference count B+tree for AG 0 indicates that the AG extent
starting at block 72,256 and running for 16 blocks has a reference count of 2.
This means that there are two files sharing the block:</p><pre class="screen">xfs_db&gt; blockget -n
xfs_db&gt; fsblock 72256
xfs_db&gt; blockuse
block 72256 (0/72256) type rldata inode 25169197</pre><p>The blockuse type changes to “rldata” to indicate that the block is shared
data.  Unfortunately, blockuse only tells us about one block owner.  If we
happen to have enabled the reverse-mapping B+tree, we can use it to find all
inodes that own this block:</p><pre class="screen">xfs_db&gt; agf 0
xfs_db&gt; addr rmaproot
...
xfs_db&gt; addr ptrs[3]
...
xfs_db&gt; addr ptrs[7]
xfs_db&gt; p
magic = 0x524d4233
level = 0
numrecs = 22
leftsib = 65057
rightsib = 65058
bno = 291478
lsn = 0x200004ec2
uuid = f1f89746-e00b-49c9-96b3-ecef0f2f14ae
owner = 0
crc = 0xed7da3f7 (correct)
recs[1-22] = [startblock,blockcount,owner,offset,extentflag,attrfork,bmbtblock]
        1:[68957,8,3201,0,0,0,0] 2:[68965,4,25260953,0,0,0,0]
        ...
        18:[72232,58,3227,0,0,0,0] 19:[72256,16,25169197,24,0,0,0]
        20:[72290,75,3228,0,0,0,0] 21:[72365,46,3229,0,0,0,0]</pre><p>Records 18 and 19 intersect the block 72,256; they tell us that inodes 3,227
and 25,169,197 both claim ownership.  Let us confirm this:</p><pre class="screen">xfs_db&gt; inode 25169197
xfs_db&gt; bmap
data offset 0 startblock 12632259 (3/49347) count 24 flag 0
data offset 24 startblock 72256 (0/72256) count 16 flag 0
data offset 40 startblock 12632299 (3/49387) count 18 flag 0
xfs_db&gt; inode 3227
xfs_db&gt; bmap
data offset 0 startblock 72232 (0/72232) count 58 flag 0</pre><p>Inodes 25,169,197 and 3,227 both contain mappings to block 0/72,256.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Journaling_Log"></a>Chapter 14. Journaling Log</h2></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Only v2 log format is covered here.</p></div><p>The XFS journal exists on disk as a reserved extent of blocks within the
filesystem, or as a separate journal device.  The journal itself can be thought
of as a series of log records; each log record contains a part of or a whole
transaction.  A transaction consists of a series of log operation headers
(“log items”), formatting structures, and raw data.  The first operation in a
transaction establishes the transaction ID and the last operation is a commit
record.  The operations recorded between the start and commit operations
represent the metadata changes made by the transaction.  If the commit
operation is missing, the transaction is incomplete and cannot be recovered.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Log_Records"></a>14.1. Log Records</h2></div></div></div><p>The XFS log is split into a series of log records.  Log records seem to
correspond to an in-core log buffer, which can be up to 256KiB in size.  Each
record has a log sequence number, which is the same LSN recorded in the v5
metadata integrity fields.</p><p>Log sequence numbers are a 64-bit quantity consisting of two 32-bit quantities.
The upper 32 bits are the “cycle number”, which increments every time XFS
cycles through the log.  The lower 32 bits are the “block number”, which is
assigned when a transaction is committed, and should correspond to the block
offset within the log.</p><p>A log record begins with the following header, which occupies 512 bytes on
disk:</p><pre class="programlisting">typedef struct xlog_rec_header {
     __be32                    h_magicno;
     __be32                    h_cycle;
     __be32                    h_version;
     __be32                    h_len;
     __be64                    h_lsn;
     __be64                    h_tail_lsn;
     __le32                    h_crc;
     __be32                    h_prev_block;
     __be32                    h_num_logops;
     __be32                    h_cycle_data[XLOG_HEADER_CYCLE_SIZE / BBSIZE];
     /* new fields */
     __be32                    h_fmt;
     uuid_t                    h_fs_uuid;
     __be32                    h_size;
} xlog_rec_header_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>h_magicno</strong></span>
</span></dt><dd>
The magic number of log records, 0xfeedbabe.
</dd><dt><span class="term">
<span class="strong"><strong>h_cycle</strong></span>
</span></dt><dd>
Cycle number of this log record.
</dd><dt><span class="term">
<span class="strong"><strong>h_version</strong></span>
</span></dt><dd>
Log record version, currently 2.
</dd><dt><span class="term">
<span class="strong"><strong>h_len</strong></span>
</span></dt><dd>
Length of the log record, in bytes.  Must be aligned to a 64-bit boundary.
</dd><dt><span class="term">
<span class="strong"><strong>h_lsn</strong></span>
</span></dt><dd>
Log sequence number of this record.
</dd><dt><span class="term">
<span class="strong"><strong>h_tail_lsn</strong></span>
</span></dt><dd>
Log sequence number of the first log record with uncommitted buffers.
</dd><dt><span class="term">
<span class="strong"><strong>h_crc</strong></span>
</span></dt><dd>
Checksum of the log record header, the cycle data, and the log records
themselves.
</dd><dt><span class="term">
<span class="strong"><strong>h_prev_block</strong></span>
</span></dt><dd>
Block number of the previous log record.
</dd><dt><span class="term">
<span class="strong"><strong>h_num_logops</strong></span>
</span></dt><dd>
The number of log operations in this record.
</dd><dt><span class="term">
<span class="strong"><strong>h_cycle_data</strong></span>
</span></dt><dd>
The first u32 of each log sector must contain the cycle number.  Since log
item buffers are formatted without regard to this requirement, the original
contents of the first four bytes of each sector in the log are copied into the
corresponding element of this array.  After that, the first four bytes of those
sectors are stamped with the cycle number.  This process is reversed at
recovery time.  If there are more sectors in this log record than there are
slots in this array, the cycle data continues for as many sectors are needed;
each sector is formatted as type <code class="literal">xlog_rec_ext_header</code>.
</dd><dt><span class="term">
<span class="strong"><strong>h_fmt</strong></span>
</span></dt><dd>
Format of the log record.  This is one of the following values:
</dd></dl></div><div class="table"><a id="idm3075"></a><p class="title"><strong>Table 14.1. Log record formats</strong></p><div class="table-contents"><table class="table" summary="Log record formats" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Format value        </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Log format</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XLOG_FMT_UNKNOWN</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unknown.  Perhaps this log is corrupt.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XLOG_FMT_LINUX_LE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Little-endian Linux.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XLOG_FMT_LINUX_BE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Big-endian Linux.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XLOG_FMT_IRIX_BE</code></p></td><td style="" align="left" valign="top"><p>Big-endian Irix.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>h_fs_uuid</strong></span>
</span></dt><dd>
Filesystem UUID.
</dd><dt><span class="term">
<span class="strong"><strong>h_size</strong></span>
</span></dt><dd>
In-core log record size.  This is somewhere between 16 and 256KiB, with 32KiB
being the default.
</dd></dl></div><p>As mentioned earlier, if this log record is longer than 256 sectors, the cycle
data overflows into the next sector(s) in the log.  Each of those sectors is
formatted as follows:</p><pre class="programlisting">typedef struct xlog_rec_ext_header {
    __be32                     xh_cycle;
    __be32                     xh_cycle_data[XLOG_HEADER_CYCLE_SIZE / BBSIZE];
} xlog_rec_ext_header_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>xh_cycle</strong></span>
</span></dt><dd>
Cycle number of this log record.  Should match <code class="literal">h_cycle</code>.
</dd><dt><span class="term">
<span class="strong"><strong>xh_cycle_data</strong></span>
</span></dt><dd>
Overflow cycle data.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Log_Operations"></a>14.2. Log Operations</h2></div></div></div><p>Within a log record, log operations are recorded as a series consisting of an
operation header immediately followed by a data region.  The operation header
has the following format:</p><pre class="programlisting">typedef struct xlog_op_header {
     __be32                    oh_tid;
     __be32                    oh_len;
     __u8                      oh_clientid;
     __u8                      oh_flags;
     __u16                     oh_res2;
} xlog_op_header_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>oh_tid</strong></span>
</span></dt><dd>
Transaction ID of this operation.
</dd><dt><span class="term">
<span class="strong"><strong>oh_len</strong></span>
</span></dt><dd>
Number of bytes in the data region.
</dd><dt><span class="term">
<span class="strong"><strong>oh_clientid</strong></span>
</span></dt><dd>
The originator of this operation.  This can be one of the following:
</dd></dl></div><div class="table"><a id="idm3154"></a><p class="title"><strong>Table 14.2. Log Operation Client ID</strong></p><div class="table-contents"><table class="table" summary="Log Operation Client ID" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Client ID         </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Originator</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANSACTION</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Operation came from a transaction.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_VOLUME</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>???</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LOG</code></p></td><td style="" align="left" valign="top"><p>???</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>oh_flags</strong></span>
</span></dt><dd>
Specifies flags associated with this operation.  This can be a combination of
the following values (though most likely only one will be set at a time):
</dd></dl></div><div class="table"><a id="idm3188"></a><p class="title"><strong>Table 14.3. Log Operation Flags</strong></p><div class="table-contents"><table class="table" summary="Log Operation Flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                  </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XLOG_START_TRANS</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Start a new transaction.  The next operation header should describe a transaction header.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XLOG_COMMIT_TRANS</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Commit this transaction.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XLOG_CONTINUE_TRANS</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Continue this trans into new log record.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XLOG_WAS_CONT_TRANS</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>This transaction started in a previous log record.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XLOG_END_TRANS</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>End of a continued transaction.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XLOG_UNMOUNT_TRANS</code></p></td><td style="" align="left" valign="top"><p>Transaction to unmount a filesystem.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>oh_res2</strong></span>
</span></dt><dd>
Padding.
</dd></dl></div><p>The data region follows immediately after the operation header and is exactly
<code class="literal">oh_len</code> bytes long.  These payloads are in host-endian order, which means that
one cannot replay the log from an unclean XFS filesystem on a system with a
different byte order.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Log_Items"></a>14.3. Log Items</h2></div></div></div><p>Following are the types of log item payloads that can follow an
<code class="literal">xlog_op_header</code>.  Except for buffer data and inode cores, all log items have a
magic number to distinguish themselves.  Buffer data items only appear after
<code class="literal">xfs_buf_log_format</code> items; and inode core items only appear after
<code class="literal">xfs_inode_log_format</code> items.</p><div class="table"><a id="idm3248"></a><p class="title"><strong>Table 14.4. Log Operation Magic Numbers</strong></p><div class="table-contents"><table class="table" summary="Log Operation Magic Numbers" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Magic                         </th><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Hexadecimal   </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Operation Type</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_HEADER_MAGIC</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x5452414e</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Log_Transaction_Headers" title="14.3.1. Transaction Headers">Log Transaction Header</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_EFI</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1236</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#EFI_Log_Item" title="14.3.2. Intent to Free an Extent">Extent Freeing Intent</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_EFD</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1237</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#EFD_Log_Item" title="14.3.3. Completion of Intent to Free an Extent">Extent Freeing Done</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_IUNLINK</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1238</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unknown?</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_INODE</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x123b</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Inode_Log_Item" title="14.3.13. Inode Updates">Inode Updates</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_BUF</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x123c</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Buffer_Log_Item" title="14.3.15. Buffer Log Item">Buffer Writes</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_DQUOT</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x123d</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Quota_Update_Log_Item" title="14.3.17. Update Quota File">Update Quota</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_QUOTAOFF</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x123e</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Quota_Off_Log_Item" title="14.3.19. Disable Quota Log Item">Quota Off</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_ICREATE</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x123f</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#Inode_Create_Log_Item" title="14.3.20. Inode Creation Log Item">Inode Creation</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_RUI</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1240</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#RUI_Log_Item" title="14.3.4. Reverse Mapping Updates Intent">Reverse Mapping Update Intent</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_RUD</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1241</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#RUD_Log_Item" title="14.3.5. Completion of Reverse Mapping Updates">Reverse Mapping Update Done</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_CUI</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1242</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#CUI_Log_Item" title="14.3.6. Reference Count Updates Intent">Reference Count Update Intent</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_CUD</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1243</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#CUD_Log_Item" title="14.3.7. Completion of Reference Count Updates">Reference Count Update Done</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_BUI</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1244</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#BUI_Log_Item" title="14.3.8. File Block Mapping Intent">File Block Mapping Update Intent</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_BUD</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1245</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#BUD_Log_Item" title="14.3.9. Completion of File Block Mapping Updates">File Block Mapping Update Done</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_ATTRI</code></p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0x1246</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><a class="link" href="#ATTRI_Log_Item" title="14.3.10. Extended Attribute Update Intent">Extended Attribute Update Intent</a></p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_LI_ATTRD</code></p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>0x1247</p></td><td style="" align="left" valign="top"><p><a class="link" href="#ATTRD_Log_Item" title="14.3.11. Completion of Extended Attribute Updates">Extended Attribute Update Done</a></p></td></tr></tbody></table></div></div><br class="table-break" /><p>Note that all log items (except for transaction headers) MUST start with
the following header structure.  The type and size fields are baked into
each log item header, but there is not a separately defined header.</p><pre class="programlisting">struct xfs_log_item {
     __uint16_t                magic;
     __uint16_t                size;
};</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Log_Transaction_Headers"></a>14.3.1. Transaction Headers</h3></div></div></div><p>A transaction header is an operation payload that starts a transaction.</p><pre class="programlisting">typedef struct xfs_trans_header {
     uint                      th_magic;
     uint                      th_type;
     __int32_t                 th_tid;
     uint                      th_num_items;
} xfs_trans_header_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>th_magic</strong></span>
</span></dt><dd>
The signature of a transaction header, “TRAN” (0x5452414e).  Note that this
value is in host-endian order, not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>th_type</strong></span>
</span></dt><dd>
Transaction type.  This is one of the following values:
</dd></dl></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Type                         </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_SETATTR_NOT_SIZE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Set an inode attribute that isn’t the inode’s size.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_SETATTR_SIZE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Setting the size attribute of an inode.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_INACTIVE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Freeing blocks from an unlinked inode.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_CREATE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Create a file.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_CREATE_TRUNC</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unused?</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_TRUNCATE_FILE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Truncate a quota file.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_REMOVE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Remove a file.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_LINK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Link an inode into a directory.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_RENAME</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Rename a path.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_MKDIR</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Create a directory.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_RMDIR</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Remove a directory.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_SYMLINK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Create a symbolic link.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_SET_DMATTRS</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Set the DMAPI attributes of an inode.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_GROWFS</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Expand the filesystem.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_STRAT_WRITE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Convert an unwritten extent or delayed-allocate some blocks to handle a write.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_DIOSTRAT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Allocate some blocks to handle a direct I/O write.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_WRITEID</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Update an inode’s preallocation flag.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_ADDAFORK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Add an attribute fork to an inode.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_ATTRINVAL</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Erase the attribute fork of an inode.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_ATRUNCATE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unused?</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_ATTR_SET</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Set an extended attribute.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_ATTR_RM</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Remove an extended attribute.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_ATTR_FLAG</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unused?</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_CLEAR_AGI_BUCKET</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Clear a bad inode pointer in the AGI unlinked inode hash bucket.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_SB_CHANGE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Write the superblock to disk.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_QM_QUOTAOFF</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Start disabling quotas.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_QM_DQALLOC</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Allocate a disk quota structure.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_QM_SETQLIM</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Adjust quota limits.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_QM_DQCLUSTER</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unused?</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_QM_QINOCREATE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Create a (quota) inode with reference taken.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_QM_QUOTAOFF_END</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Finish disabling quotas.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_FSYNC_TS</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Update only inode timestamps.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_GROWFSRT_ALLOC</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Grow the realtime bitmap and summary data for growfs.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_GROWFSRT_ZERO</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Zero space in the realtime bitmap and summary data.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_GROWFSRT_FREE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Free space in the realtime bitmap and summary data.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_SWAPEXT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Swap data fork of two inodes.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_CHECKPOINT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Checkpoint the log.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_ICREATE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Unknown?</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_TRANS_CREATE_TMPFILE</code></p></td><td style="" align="left" valign="top"><p>Create a temporary file.</p></td></tr></tbody></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>th_tid</strong></span>
</span></dt><dd>
Transaction ID.
</dd><dt><span class="term">
<span class="strong"><strong>th_num_items</strong></span>
</span></dt><dd>
The number of operations appearing after this operation, not including the
commit operation.  In effect, this tracks the number of metadata change
operations in this transaction.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="EFI_Log_Item"></a>14.3.2. Intent to Free an Extent</h3></div></div></div><p>The next two operation types work together to handle the freeing of filesystem
blocks.  Naturally, the ranges of blocks to be freed can be expressed in terms
of extents:</p><pre class="programlisting">typedef struct xfs_extent_32 {
     __uint64_t                ext_start;
     __uint32_t                ext_len;
} __attribute__((packed)) xfs_extent_32_t;

typedef struct xfs_extent_64 {
     __uint64_t                ext_start;
     __uint32_t                ext_len;
     __uint32_t                ext_pad;
} xfs_extent_64_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>ext_start</strong></span>
</span></dt><dd>
Start block of this extent.
</dd><dt><span class="term">
<span class="strong"><strong>ext_len</strong></span>
</span></dt><dd>
Length of this extent.
</dd></dl></div><p>The “extent freeing intent” operation comes first; it tells the log that XFS
wants to free some extents.  This record is crucial for correct log recovery
because it prevents the log from replaying blocks that are subsequently freed.
If the log lacks a corresponding “extent freeing done” operation, the
recovery process will free the extents.</p><pre class="programlisting">typedef struct xfs_efi_log_format {
     __uint16_t                efi_type;
     __uint16_t                efi_size;
     __uint32_t                efi_nextents;
     __uint64_t                efi_id;
     xfs_extent_t              efi_extents[1];
} xfs_efi_log_format_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>efi_type</strong></span>
</span></dt><dd>
The signature of an EFI operation, 0x1236.  This value is in host-endian order,
not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>efi_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>efi_nextents</strong></span>
</span></dt><dd>
Number of extents to free.
</dd><dt><span class="term">
<span class="strong"><strong>efi_id</strong></span>
</span></dt><dd>
A 64-bit number that binds the corresponding EFD log item to this EFI log item.
</dd><dt><span class="term">
<span class="strong"><strong>efi_extents</strong></span>
</span></dt><dd>
Variable-length array of extents to be freed.  The array length is given by
<code class="literal">efi_nextents</code>.  The record type will be either <code class="literal">xfs_extent_64_t</code> or
<code class="literal">xfs_extent_32_t</code>; this can be determined from the log item size (<code class="literal">oh_len</code>) and
the number of extents (<code class="literal">efi_nextents</code>).
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="EFD_Log_Item"></a>14.3.3. Completion of Intent to Free an Extent</h3></div></div></div><p>The “extent freeing done” operation complements the “extent freeing intent”
operation.  This second operation indicates that the block freeing actually
happened, so that log recovery needn’t try to free the blocks.  Typically, the
operations to update the free space B+trees follow immediately after the EFD.</p><pre class="programlisting">typedef struct xfs_efd_log_format {
     __uint16_t                efd_type;
     __uint16_t                efd_size;
     __uint32_t                efd_nextents;
     __uint64_t                efd_efi_id;
     xfs_extent_t              efd_extents[1];
} xfs_efd_log_format_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>efd_type</strong></span>
</span></dt><dd>
The signature of an EFD operation, 0x1237.  This value is in host-endian order,
not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>efd_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>efd_nextents</strong></span>
</span></dt><dd>
Number of extents to free.
</dd><dt><span class="term">
<span class="strong"><strong>efd_id</strong></span>
</span></dt><dd>
A 64-bit number that binds the corresponding EFI log item to this EFD log item.
</dd><dt><span class="term">
<span class="strong"><strong>efd_extents</strong></span>
</span></dt><dd>
Variable-length array of extents to be freed.  The array length is given by
<code class="literal">efd_nextents</code>.  The record type will be either <code class="literal">xfs_extent_64_t</code> or
<code class="literal">xfs_extent_32_t</code>; this can be determined from the log item size (<code class="literal">oh_len</code>) and
the number of extents (<code class="literal">efd_nextents</code>).
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="RUI_Log_Item"></a>14.3.4. Reverse Mapping Updates Intent</h3></div></div></div><p>The next two operation types work together to handle deferred reverse mapping
updates.  Naturally, the mappings to be updated can be expressed in terms of
mapping extents:</p><pre class="programlisting">struct xfs_map_extent {
     __uint64_t                me_owner;
     __uint64_t                me_startblock;
     __uint64_t                me_startoff;
     __uint32_t                me_len;
     __uint32_t                me_flags;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>me_owner</strong></span>
</span></dt><dd>
Owner of this reverse mapping.  See the values in the section about
<a class="link" href="#Reverse_Mapping_Btree" title="13.7. Reverse-Mapping B+tree">reverse mapping</a> for more information.
</dd><dt><span class="term">
<span class="strong"><strong>me_startblock</strong></span>
</span></dt><dd>
Filesystem block of this mapping.
</dd><dt><span class="term">
<span class="strong"><strong>me_startoff</strong></span>
</span></dt><dd>
Logical block offset of this mapping.
</dd><dt><span class="term">
<span class="strong"><strong>me_len</strong></span>
</span></dt><dd>
The length of this mapping.
</dd><dt><span class="term">
<span class="strong"><strong>me_flags</strong></span>
</span></dt><dd>
The lower byte of this field is a type code indicating what sort of
reverse mapping operation we want.  The upper three bytes are flag bits.
</dd></dl></div><div class="table"><a id="idm3797"></a><p class="title"><strong>Table 14.5. Reverse mapping update log intent types</strong></p><div class="table-contents"><table class="table" summary="Reverse mapping update log intent types" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Value                         </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_EXTENT_MAP</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Add a reverse mapping for file data.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_EXTENT_MAP_SHARED</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Add a reverse mapping for file data for a file with shared blocks.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_EXTENT_UNMAP</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Remove a reverse mapping for file data.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_EXTENT_UNMAP_SHARED</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Remove a reverse mapping for file data for a file with shared blocks.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_EXTENT_CONVERT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Convert a reverse mapping for file data between unwritten and normal.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_EXTENT_CONVERT_SHARED</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Convert a reverse mapping for file data between unwritten and normal for a file with shared blocks.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_EXTENT_ALLOC</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Add a reverse mapping for non-file data.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_EXTENT_FREE</code></p></td><td style="" align="left" valign="top"><p>Remove a reverse mapping for non-file data.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idm3855"></a><p class="title"><strong>Table 14.6. Reverse mapping update log intent flags</strong></p><div class="table-contents"><table class="table" summary="Reverse mapping update log intent flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Value                         </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_EXTENT_ATTR_FORK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Extent is for the attribute fork.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_EXTENT_BMBT_BLOCK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Extent is for a block mapping btree block.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_RMAP_EXTENT_UNWRITTEN</code></p></td><td style="" align="left" valign="top"><p>Extent is unwritten.</p></td></tr></tbody></table></div></div><br class="table-break" /><p>The “rmap update intent” operation comes first; it tells the log that XFS
wants to update some reverse mappings.  This record is crucial for correct log
recovery because it enables us to spread a complex metadata update across
multiple transactions while ensuring that a crash midway through the complex
update will be replayed fully during log recovery.</p><pre class="programlisting">struct xfs_rui_log_format {
     __uint16_t                rui_type;
     __uint16_t                rui_size;
     __uint32_t                rui_nextents;
     __uint64_t                rui_id;
     struct xfs_map_extent     rui_extents[1];
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>rui_type</strong></span>
</span></dt><dd>
The signature of an RUI operation, 0x1240.  This value is in host-endian order,
not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>rui_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>rui_nextents</strong></span>
</span></dt><dd>
Number of reverse mappings.
</dd><dt><span class="term">
<span class="strong"><strong>rui_id</strong></span>
</span></dt><dd>
A 64-bit number that binds the corresponding RUD log item to this RUI log item.
</dd><dt><span class="term">
<span class="strong"><strong>rui_extents</strong></span>
</span></dt><dd>
Variable-length array of reverse mappings to update.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="RUD_Log_Item"></a>14.3.5. Completion of Reverse Mapping Updates</h3></div></div></div><p>The “reverse mapping update done” operation complements the “reverse mapping
update intent” operation.  This second operation indicates that the update
actually happened, so that log recovery needn’t replay the update.  The RUD and
the actual updates are typically found in a new transaction following the
transaction in which the RUI was logged.</p><pre class="programlisting">struct xfs_rud_log_format {
      __uint16_t               rud_type;
      __uint16_t               rud_size;
      __uint32_t               __pad;
      __uint64_t               rud_rui_id;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>rud_type</strong></span>
</span></dt><dd>
The signature of an RUD operation, 0x1241.  This value is in host-endian order,
not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>rud_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>rud_rui_id</strong></span>
</span></dt><dd>
A 64-bit number that binds the corresponding RUI log item to this RUD log item.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="CUI_Log_Item"></a>14.3.6. Reference Count Updates Intent</h3></div></div></div><p>The next two operation types work together to handle reference count updates.
Naturally, the ranges of extents having reference count updates can be
expressed in terms of physical extents:</p><pre class="programlisting">struct xfs_phys_extent {
     __uint64_t                pe_startblock;
     __uint32_t                pe_len;
     __uint32_t                pe_flags;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>pe_startblock</strong></span>
</span></dt><dd>
Filesystem block of this extent.
</dd><dt><span class="term">
<span class="strong"><strong>pe_len</strong></span>
</span></dt><dd>
The length of this extent.
</dd><dt><span class="term">
<span class="strong"><strong>pe_flags</strong></span>
</span></dt><dd>
The lower byte of this field is a type code indicating what sort of
reverse mapping operation we want.  The upper three bytes are flag bits.
</dd></dl></div><div class="table"><a id="idm3951"></a><p class="title"><strong>Table 14.7. Reference count update log intent types</strong></p><div class="table-contents"><table class="table" summary="Reference count update log intent types" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Value                           </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_REFCOUNT_EXTENT_INCREASE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Increase the reference count for this extent.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_REFCOUNT_EXTENT_DECREASE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Decrease the reference count for this extent.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_REFCOUNT_EXTENT_ALLOC_COW</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Reserve an extent for staging copy on write.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_REFCOUNT_EXTENT_FREE_COW</code></p></td><td style="" align="left" valign="top"><p>Unreserve an extent for staging copy on write.</p></td></tr></tbody></table></div></div><br class="table-break" /><p>The “reference count update intent” operation comes first; it tells the log
that XFS wants to update some reference counts.  This record is crucial for
correct log recovery because it enables us to spread a complex metadata update
across multiple transactions while ensuring that a crash midway through the
complex update will be replayed fully during log recovery.</p><pre class="programlisting">struct xfs_cui_log_format {
     __uint16_t                cui_type;
     __uint16_t                cui_size;
     __uint32_t                cui_nextents;
     __uint64_t                cui_id;
     struct xfs_map_extent     cui_extents[1];
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>cui_type</strong></span>
</span></dt><dd>
The signature of an CUI operation, 0x1242.  This value is in host-endian order,
not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>cui_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>cui_nextents</strong></span>
</span></dt><dd>
Number of reference count updates.
</dd><dt><span class="term">
<span class="strong"><strong>cui_id</strong></span>
</span></dt><dd>
A 64-bit number that binds the corresponding RUD log item to this RUI log item.
</dd><dt><span class="term">
<span class="strong"><strong>cui_extents</strong></span>
</span></dt><dd>
Variable-length array of reference count update information.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="CUD_Log_Item"></a>14.3.7. Completion of Reference Count Updates</h3></div></div></div><p>The “reference count update done” operation complements the “reference count
update intent” operation.  This second operation indicates that the update
actually happened, so that log recovery needn’t replay the update.  The CUD and
the actual updates are typically found in a new transaction following the
transaction in which the CUI was logged.</p><pre class="programlisting">struct xfs_cud_log_format {
      __uint16_t               cud_type;
      __uint16_t               cud_size;
      __uint32_t               __pad;
      __uint64_t               cud_cui_id;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>cud_type</strong></span>
</span></dt><dd>
The signature of an RUD operation, 0x1243.  This value is in host-endian order,
not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>cud_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>cud_cui_id</strong></span>
</span></dt><dd>
A 64-bit number that binds the corresponding CUI log item to this CUD log item.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="BUI_Log_Item"></a>14.3.8. File Block Mapping Intent</h3></div></div></div><p>The next two operation types work together to handle deferred file block
mapping updates.  The extents to be mapped are expressed via the
<code class="literal">xfs_map_extent</code> structure discussed in the section about
<a class="link" href="#RUI_Log_Item" title="14.3.4. Reverse Mapping Updates Intent">reverse mapping intents</a>.</p><p>The lower byte of the <code class="literal">me_flags</code> field is a type code indicating what sort of
file block mapping operation we want.  The upper three bytes are flag bits.</p><div class="table"><a id="idm4040"></a><p class="title"><strong>Table 14.8. File block mapping update log intent types</strong></p><div class="table-contents"><table class="table" summary="File block mapping update log intent types" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Value                         </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_BMAP_EXTENT_MAP</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Add a mapping for file data.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_BMAP_EXTENT_UNMAP</code></p></td><td style="" align="left" valign="top"><p>Remove a mapping for file data.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="table"><a id="idm4062"></a><p class="title"><strong>Table 14.9. File block mapping update log intent flags</strong></p><div class="table-contents"><table class="table" summary="File block mapping update log intent flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Value                         </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_BMAP_EXTENT_ATTR_FORK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Extent is for the attribute fork.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_BMAP_EXTENT_UNWRITTEN</code></p></td><td style="" align="left" valign="top"><p>Extent is unwritten.</p></td></tr></tbody></table></div></div><br class="table-break" /><p>The “file block mapping update intent” operation comes first; it tells the
log that XFS wants to map or unmap some extents in a file.  This record is
crucial for correct log recovery because it enables us to spread a complex
metadata update across multiple transactions while ensuring that a crash midway
through the complex update will be replayed fully during log recovery.</p><pre class="programlisting">struct xfs_bui_log_format {
     __uint16_t                bui_type;
     __uint16_t                bui_size;
     __uint32_t                bui_nextents;
     __uint64_t                bui_id;
     struct xfs_map_extent     bui_extents[1];
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>bui_type</strong></span>
</span></dt><dd>
The signature of an BUI operation, 0x1244.  This value is in host-endian order,
not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>bui_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>bui_nextents</strong></span>
</span></dt><dd>
Number of file mappings.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>bui_id</strong></span>
</span></dt><dd>
A 64-bit number that binds the corresponding BUD log item to this BUI log item.
</dd><dt><span class="term">
<span class="strong"><strong>bui_extents</strong></span>
</span></dt><dd>
Variable-length array of file block mappings to update.  There should only
be one mapping present.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="BUD_Log_Item"></a>14.3.9. Completion of File Block Mapping Updates</h3></div></div></div><p>The “file block mapping update done” operation complements the “file block
mapping update intent” operation.  This second operation indicates that the
update actually happened, so that log recovery needn’t replay the update.  The
BUD and the actual updates are typically found in a new transaction following
the transaction in which the BUI was logged.</p><pre class="programlisting">struct xfs_bud_log_format {
      __uint16_t               bud_type;
      __uint16_t               bud_size;
      __uint32_t               __pad;
      __uint64_t               bud_bui_id;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>bud_type</strong></span>
</span></dt><dd>
The signature of an BUD operation, 0x1245.  This value is in host-endian order,
not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>bud_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>bud_bui_id</strong></span>
</span></dt><dd>
A 64-bit number that binds the corresponding BUI log item to this BUD log item.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ATTRI_Log_Item"></a>14.3.10. Extended Attribute Update Intent</h3></div></div></div><p>The next two operation types work together to handle atomic extended attribute
updates.</p><p>The lower byte of the <code class="literal">alfi_op_flags</code> field is a type code indicating what sort
of file block mapping operation we want.</p><div class="table"><a id="idm4137"></a><p class="title"><strong>Table 14.10. Extended attribute update log intent types</strong></p><div class="table-contents"><table class="table" summary="Extended attribute update log intent types" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Value                         </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ATTRI_OP_FLAGS_SET</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Set a key/value pair.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ATTRI_OP_FLAGS_REMOVE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Remove a key/value pair.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ATTRI_OP_FLAGS_REPLACE</code></p></td><td style="" align="left" valign="top"><p>Replace one key/value pair with another.</p></td></tr></tbody></table></div></div><br class="table-break" /><p>The “extended attribute update intent” operation comes first; it tells the
log that XFS wants to update one of a file’s extended attributes.  This record
is crucial for correct log recovery because it enables us to spread a complex
metadata update across multiple transactions while ensuring that a crash midway
through the complex update will be replayed fully during log recovery.</p><pre class="programlisting">struct xfs_attri_log_format {
     uint16_t                  alfi_type;
     uint16_t                  alfi_size;
     uint32_t                  __pad;
     uint64_t                  alfi_id;
     uint64_t                  alfi_ino;
     uint32_t                  alfi_op_flags;
     uint32_t                  alfi_name_len;
     uint32_t                  alfi_value_len;
     uint32_t                  alfi_attr_filter;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>alfi_type</strong></span>
</span></dt><dd>
The signature of an ATTRI operation, 0x1246.  This value is in host-endian
order, not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>alfi_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>alfi_id</strong></span>
</span></dt><dd>
A 64-bit number that binds the corresponding ATTRD log item to this ATTRI log
item.
</dd><dt><span class="term">
<span class="strong"><strong>alfi_ino</strong></span>
</span></dt><dd>
Inode number of the file being updated.
</dd><dt><span class="term">
<span class="strong"><strong>alfi_op_flags</strong></span>
</span></dt><dd>
The operation being performed.  The lower byte must be one of the
<code class="literal">XFS_ATTRI_OP_FLAGS_*</code> flags defined above.  The upper bytes must be zero.
</dd><dt><span class="term">
<span class="strong"><strong>alfi_name_len</strong></span>
</span></dt><dd>
Length of the name of the extended attribute.  This must not be zero.
The attribute name itself is captured in the next log item.
</dd><dt><span class="term">
<span class="strong"><strong>alfi_value_len</strong></span>
</span></dt><dd>
Length of the value of the extended attribute.  This must be zero for remove
operations, and nonzero for set and replace operations.  The attribute value
itself is captured in the log item immediately after the item containing the
name.
</dd><dt><span class="term">
<span class="strong"><strong>alfi_attr_filter</strong></span>
</span></dt><dd>
Attribute namespace filter flags.  This must be one of <code class="literal">ATTR_ROOT</code>,
<code class="literal">ATTR_SECURE</code>, or <code class="literal">ATTR_INCOMPLETE</code>.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="ATTRD_Log_Item"></a>14.3.11. Completion of Extended Attribute Updates</h3></div></div></div><p>The “extended attribute update done” operation complements the “extended
attribute update intent” operation.  This second operation indicates that the
update actually happened, so that log recovery needn’t replay the update.  The
ATTRD and the actual updates are typically found in a new transaction following
the transaction in which the ATTRI was logged.</p><pre class="programlisting">struct xfs_attrd_log_format {
      __uint16_t               alfd_type;
      __uint16_t               alfd_size;
      __uint32_t               __pad;
      __uint64_t               alfd_alf_id;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>alfd_type</strong></span>
</span></dt><dd>
The signature of an ATTRD operation, 0x1247.  This value is in host-endian
order, not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>alfd_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>alfd_alf_id</strong></span>
</span></dt><dd>
A 64-bit number that binds the corresponding ATTRI log item to this ATTRD log
item.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_extended_attribute_name_and_value"></a>14.3.12. Extended Attribute Name and Value</h3></div></div></div><p>These regions contain the name and value components of the extended attribute
being updated, as needed.  There are no magic numbers; each region contains the
data and nothing else.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Inode_Log_Item"></a>14.3.13. Inode Updates</h3></div></div></div><p>This operation records changes to an inode record.  There are several types of
inode updates, each corresponding to different parts of the inode record.
Allowing updates to proceed at a sub-inode granularity reduces contention for
the inode, since different parts of the inode can be updated simultaneously.</p><p>The actual buffer data are stored in subsequent log items.</p><p>The inode log format header is as follows:</p><pre class="programlisting">typedef struct xfs_inode_log_format_64 {
     __uint16_t                ilf_type;
     __uint16_t                ilf_size;
     __uint32_t                ilf_fields;
     __uint16_t                ilf_asize;
     __uint16_t                ilf_dsize;
     __uint32_t                ilf_pad;
     __uint64_t                ilf_ino;
     union {
          __uint32_t           ilfu_rdev;
          uuid_t               ilfu_uuid;
     } ilf_u;
     __int64_t                 ilf_blkno;
     __int32_t                 ilf_len;
     __int32_t                 ilf_boffset;
} xfs_inode_log_format_64_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>ilf_type</strong></span>
</span></dt><dd>
The signature of an inode update operation, 0x123b.  This value is in
host-endian order, not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>ilf_size</strong></span>
</span></dt><dd>
Number of operations involved in this update, including this format operation.
</dd><dt><span class="term">
<span class="strong"><strong>ilf_fields</strong></span>
</span></dt><dd>
Specifies which parts of the inode are being updated.  This can be certain
combinations of the following:
</dd></dl></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                 </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Inode changes to log include:</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_CORE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The standard inode fields.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_DDATA</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Data fork’s local data.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_DEXT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Data fork’s extent list.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_DBROOT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Data fork’s B+tree root.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_DEV</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Data fork’s device number.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_UUID</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Data fork’s UUID contents.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_ADATA</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Attribute fork’s local data.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_AEXT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Attribute fork’s extent list.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_ABROOT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Attribute fork’s B+tree root.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_DOWNER</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Change the data fork owner on replay.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_AOWNER</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Change the attr fork owner on replay.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_TIMESTAMP</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Timestamps are dirty, but not necessarily anything else.  Should never appear on disk.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_NONCORE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>( <code class="literal">XFS_ILOG_DDATA</code> | <code class="literal">XFS_ILOG_DEXT</code> | <code class="literal">XFS_ILOG_DBROOT</code> | <code class="literal">XFS_ILOG_DEV</code> | <code class="literal">XFS_ILOG_UUID</code> | <code class="literal">XFS_ILOG_ADATA</code> | <code class="literal">XFS_ILOG_AEXT</code> | <code class="literal">XFS_ILOG_ABROOT</code> | <code class="literal">XFS_ILOG_DOWNER</code> | <code class="literal">XFS_ILOG_AOWNER</code> )</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_DFORK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>( <code class="literal">XFS_ILOG_DDATA</code> | <code class="literal">XFS_ILOG_DEXT</code> | <code class="literal">XFS_ILOG_DBROOT</code> )</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_AFORK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>( <code class="literal">XFS_ILOG_ADATA</code> | <code class="literal">XFS_ILOG_AEXT</code> | <code class="literal">XFS_ILOG_ABROOT</code> )</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ILOG_ALL</code></p></td><td style="" align="left" valign="top"><p>( <code class="literal">XFS_ILOG_CORE</code> | <code class="literal">XFS_ILOG_DDATA</code> | <code class="literal">XFS_ILOG_DEXT</code> | <code class="literal">XFS_ILOG_DBROOT</code> | <code class="literal">XFS_ILOG_DEV</code> | <code class="literal">XFS_ILOG_UUID</code> | <code class="literal">XFS_ILOG_ADATA</code> | <code class="literal">XFS_ILOG_AEXT</code> | <code class="literal">XFS_ILOG_ABROOT</code> | <code class="literal">XFS_ILOG_TIMESTAMP</code> | <code class="literal">XFS_ILOG_DOWNER</code> | <code class="literal">XFS_ILOG_AOWNER</code> )</p></td></tr></tbody></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>ilf_asize</strong></span>
</span></dt><dd>
Size of the attribute fork, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>ilf_dsize</strong></span>
</span></dt><dd>
Size of the data fork, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>ilf_ino</strong></span>
</span></dt><dd>
Absolute node number.
</dd><dt><span class="term">
<span class="strong"><strong>ilfu_rdev</strong></span>
</span></dt><dd>
Device number information, for a device file update.
</dd><dt><span class="term">
<span class="strong"><strong>ilfu_uuid</strong></span>
</span></dt><dd>
UUID, for a UUID update?
</dd><dt><span class="term">
<span class="strong"><strong>ilf_blkno</strong></span>
</span></dt><dd>
Block number of the inode buffer, in sectors.
</dd><dt><span class="term">
<span class="strong"><strong>ilf_len</strong></span>
</span></dt><dd>
Length of inode buffer, in sectors.
</dd><dt><span class="term">
<span class="strong"><strong>ilf_boffset</strong></span>
</span></dt><dd>
Byte offset of the inode in the buffer.
</dd></dl></div><p>Be aware that there is a nearly identical <code class="literal">xfs_inode_log_format_32</code> which may
appear on disk.  It is the same as <code class="literal">xfs_inode_log_format_64</code>, except that it is
missing the <code class="literal">ilf_pad</code> field and is 52 bytes long as opposed to 56 bytes.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Inode_Data_Log_Item"></a>14.3.14. Inode Data Log Item</h3></div></div></div><p>This region contains the new contents of a part of an inode, as described in
the <a class="link" href="#Inode_Log_Item" title="14.3.13. Inode Updates">previous section</a>.  There are no magic numbers.</p><p>If <code class="literal">XFS_ILOG_CORE</code> is set in <code class="literal">ilf_fields</code>, the corresponding data buffer must
be in the format <code class="literal">struct xfs_icdinode</code>, which has the same format as the first
96 bytes of an <a class="link" href="#On-disk_Inode" title="Chapter 16. On-disk Inode">inode</a>, but is recorded in host byte order.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Buffer_Log_Item"></a>14.3.15. Buffer Log Item</h3></div></div></div><p>This operation writes parts of a buffer to disk.  The regions to write are
tracked in the data map; the actual buffer data are stored in subsequent log
items.</p><pre class="programlisting">typedef struct xfs_buf_log_format {
     unsigned short            blf_type;
     unsigned short            blf_size;
     ushort                    blf_flags;
     ushort                    blf_len;
     __int64_t                 blf_blkno;
     unsigned int              blf_map_size;
     unsigned int              blf_data_map[XFS_BLF_DATAMAP_SIZE];
} xfs_buf_log_format_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>blf_type</strong></span>
</span></dt><dd>
Magic number to specify a buffer log item, 0x123c.
</dd><dt><span class="term">
<span class="strong"><strong>blf_size</strong></span>
</span></dt><dd>
Number of buffer data items following this item.
</dd><dt><span class="term">
<span class="strong"><strong>blf_flags</strong></span>
</span></dt><dd>
Specifies flags associated with the buffer item.  This can be any of the
following:
</dd></dl></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                 </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_BLF_INODE_BUF</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Inode buffer.  These must be recovered before replaying items that change this buffer.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_BLF_CANCEL</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Don’t recover this buffer, blocks are being freed.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_BLF_UDQUOT_BUF</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>User quota buffer, don’t recover if there’s a subsequent quotaoff.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_BLF_PDQUOT_BUF</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Project quota buffer, don’t recover if there’s a subsequent quotaoff.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_BLF_GDQUOT_BUF</code></p></td><td style="" align="left" valign="top"><p>Group quota buffer, don’t recover if there’s a subsequent quotaoff.</p></td></tr></tbody></table></div><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>blf_len</strong></span>
</span></dt><dd>
Number of sectors affected by this buffer.
</dd><dt><span class="term">
<span class="strong"><strong>blf_blkno</strong></span>
</span></dt><dd>
Block number to write, in sectors.
</dd><dt><span class="term">
<span class="strong"><strong>blf_map_size</strong></span>
</span></dt><dd>
The size of <code class="literal">blf_data_map</code>, in 32-bit words.
</dd><dt><span class="term">
<span class="strong"><strong>blf_data_map</strong></span>
</span></dt><dd>
This variable-sized array acts as a dirty bitmap for the logged buffer.  Each
1 bit represents a dirty region in the buffer, and each run of 1 bits
corresponds to a subsequent log item containing the new contents of the buffer
area.  Each bit represents <code class="literal">XFS_BLF_CHUNK</code> (i.e. 128) bytes.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Buffer_Data_Log_Item"></a>14.3.16. Buffer Data Log Item</h3></div></div></div><p>This region contains the new contents of a part of a buffer, as described in
the <a class="link" href="#Buffer_Log_Item" title="14.3.15. Buffer Log Item">previous section</a>.  There are no magic numbers.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Quota_Update_Log_Item"></a>14.3.17. Update Quota File</h3></div></div></div><p>This updates a block in a quota file.  The buffer data must be in the next log
item.</p><pre class="programlisting">typedef struct xfs_dq_logformat {
     __uint16_t                qlf_type;
     __uint16_t                qlf_size;
     xfs_dqid_t                qlf_id;
     __int64_t                 qlf_blkno;
     __int32_t                 qlf_len;
     __uint32_t                qlf_boffset;
} xfs_dq_logformat_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>qlf_type</strong></span>
</span></dt><dd>
The signature of an inode create operation, 0x123e.  This value is in
host-endian order, not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>qlf_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 2.
</dd><dt><span class="term">
<span class="strong"><strong>qlf_id</strong></span>
</span></dt><dd>
The user/group/project ID to alter.
</dd><dt><span class="term">
<span class="strong"><strong>qlf_blkno</strong></span>
</span></dt><dd>
Block number of the quota buffer, in sectors.
</dd><dt><span class="term">
<span class="strong"><strong>qlf_len</strong></span>
</span></dt><dd>
Length of the quota buffer, in sectors.
</dd><dt><span class="term">
<span class="strong"><strong>qlf_boffset</strong></span>
</span></dt><dd>
Buffer offset of the quota data to update, in bytes.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Quota_Update_Data_Log_Item"></a>14.3.18. Quota Update Data Log Item</h3></div></div></div><p>This region contains the new contents of a part of a buffer, as described in
the <a class="link" href="#Quota_Update_Log_Item" title="14.3.17. Update Quota File">previous section</a>.  There are no magic numbers.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Quota_Off_Log_Item"></a>14.3.19. Disable Quota Log Item</h3></div></div></div><p>A request to disable quota controls has the following format:</p><pre class="programlisting">typedef struct xfs_qoff_logformat {
     unsigned short            qf_type;
     unsigned short            qf_size;
     unsigned int              qf_flags;
     char                      qf_pad[12];
} xfs_qoff_logformat_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>qf_type</strong></span>
</span></dt><dd>
The signature of an inode create operation, 0x123d.  This value is in
host-endian order, not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>qf_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>qf_flags</strong></span>
</span></dt><dd>
Specifies which quotas are being turned off.  Can be a combination of the
following:
</dd></dl></div><div class="informaltable"><table class="informaltable" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                 </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Quota type to disable</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_UQUOTA_ACCT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>User quotas.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_PQUOTA_ACCT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Project quotas.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_GQUOTA_ACCT</code></p></td><td style="" align="left" valign="top"><p>Group quotas.</p></td></tr></tbody></table></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Inode_Create_Log_Item"></a>14.3.20. Inode Creation Log Item</h3></div></div></div><p>This log item is created when inodes are allocated in-core.  When replaying
this item, the specified inode records will be zeroed and some of the inode
fields populated with default values.</p><pre class="programlisting">struct xfs_icreate_log {
     __uint16_t                icl_type;
     __uint16_t                icl_size;
     __be32                    icl_ag;
     __be32                    icl_agbno;
     __be32                    icl_count;
     __be32                    icl_isize;
     __be32                    icl_length;
     __be32                    icl_gen;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>icl_type</strong></span>
</span></dt><dd>
The signature of an inode create operation, 0x123f.  This value is in
host-endian order, not big-endian like the rest of XFS.
</dd><dt><span class="term">
<span class="strong"><strong>icl_size</strong></span>
</span></dt><dd>
Size of this log item.  Should be 1.
</dd><dt><span class="term">
<span class="strong"><strong>icl_ag</strong></span>
</span></dt><dd>
AG number of the inode chunk to create.
</dd><dt><span class="term">
<span class="strong"><strong>icl_agbno</strong></span>
</span></dt><dd>
AG block number of the inode chunk.
</dd><dt><span class="term">
<span class="strong"><strong>icl_count</strong></span>
</span></dt><dd>
Number of inodes to initialize.
</dd><dt><span class="term">
<span class="strong"><strong>icl_isize</strong></span>
</span></dt><dd>
Size of each inode, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>icl_length</strong></span>
</span></dt><dd>
Length of the extent being initialized, in blocks.
</dd><dt><span class="term">
<span class="strong"><strong>icl_gen</strong></span>
</span></dt><dd>
Inode generation number to write into the new inodes.
</dd></dl></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_xfs_logprint_example"></a>14.4. xfs_logprint Example</h2></div></div></div><p>Here’s an example of dumping the XFS log contents with <code class="literal">xfs_logprint</code>:</p><pre class="screen"># xfs_logprint /dev/sda
xfs_logprint: /dev/sda contains a mounted and writable filesystem
xfs_logprint:
    data device: 0xfc03
    log device: 0xfc03 daddr: 900931640 length: 879816

cycle: 48       version: 2              lsn: 48,0       tail_lsn: 47,879760
length of Log Record: 19968     prev offset: 879808             num ops: 53
uuid: 24afeec2-f418-46a2-a573-10091f5e200e   format: little endian linux
h_size: 32768</pre><p>This is the log record header.</p><pre class="screen">Oper (0): tid: 30483aec  len: 0  clientid: TRANS  flags: START</pre><p>This operation indicates that we’re starting a transaction, so the next
operation should record the transaction header.</p><pre class="screen">Oper (1): tid: 30483aec  len: 16  clientid: TRANS  flags: none
TRAN:    type: CHECKPOINT       tid: 30483aec       num_items: 50</pre><p>This operation records a transaction header.  There should be fifty operations
in this transaction and the transaction ID is 0x30483aec.</p><pre class="screen">Oper (2): tid: 30483aec  len: 24  clientid: TRANS  flags: none
BUF:  #regs: 2   start blkno: 145400496 (0x8aaa2b0)  len: 8  bmap size: 1  flags: 0x2000
Oper (3): tid: 30483aec  len: 3712  clientid: TRANS  flags: none
BUF DATA
...
Oper (4): tid: 30483aec  len: 24  clientid: TRANS  flags: none
BUF:  #regs: 3   start blkno: 59116912 (0x3860d70)  len: 8  bmap size: 1  flags: 0x2000
Oper (5): tid: 30483aec  len: 128  clientid: TRANS  flags: none
BUF DATA
 0 43544241 49010000 fa347000 2c357000 3a40b200 13000000 2343c200 13000000
 8 3296d700 13000000 375deb00 13000000 8a551501 13000000 56be1601 13000000
10 af081901 13000000 ec741c01 13000000 9e911c01 13000000 69073501 13000000
18 4e539501 13000000  6549501 13000000 5d0e7f00 14000000 c6908200 14000000

Oper (6): tid: 30483aec  len: 640  clientid: TRANS  flags: none
BUF DATA
 0 7f47c800 21000000 23c0e400 21000000 2d0dfe00 21000000 e7060c01 21000000
 8 34b91801 21000000 9cca9100 22000000 26e69800 22000000 4c969900 22000000
...
90 1cf69900 27000000 42f79c00 27000000  6a99e00 27000000  6a99e00 27000000
98  6a99e00 27000000  6a99e00 27000000  6a99e00 27000000  6a99e00 27000000</pre><p>Operations 4-6 describe two updates to a single dirty buffer at disk address
59,116,912.  The first chunk of dirty data is 128 bytes long.  Notice how the
first four bytes of the first chunk is 0x43544241?  Remembering that log items
are in host byte order, reverse that to 0x41425443, which is the magic number
for the free space B+tree ordered by size.</p><p>The second chunk is 640 bytes.  There are more buffer changes, so we’ll skip
ahead a few operations:</p><pre class="screen">Oper (19): tid: 30483aec  len: 56  clientid: TRANS  flags: none
INODE: #regs: 2   ino: 0x63a73b4e  flags: 0x1   dsize: 40
        blkno: 1412688704  len: 16  boff: 7168
Oper (20): tid: 30483aec  len: 96  clientid: TRANS  flags: none
INODE CORE
magic 0x494e mode 0100600 version 2 format 3
nlink 1 uid 1000 gid 1000
atime 0x5633d58d mtime 0x563a391b ctime 0x563a391b
size 0x109dc8 nblocks 0x111 extsize 0x0 nextents 0x1b
naextents 0x0 forkoff 0 dmevmask 0x0 dmstate 0x0
flags 0x0 gen 0x389071be</pre><p>This is an update to the core of inode 0x63a73b4e.  There were similar inode
core updates after this, so we’ll skip ahead a bit:</p><pre class="screen">Oper (32): tid: 30483aec  len: 56  clientid: TRANS  flags: none
INODE: #regs: 3   ino: 0x4bde428  flags: 0x5   dsize: 16
        blkno: 79553568  len: 16  boff: 4096
Oper (33): tid: 30483aec  len: 96  clientid: TRANS  flags: none
INODE CORE
magic 0x494e mode 0100644 version 2 format 2
nlink 1 uid 1000 gid 1000
atime 0x563a3924 mtime 0x563a3931 ctime 0x563a3931
size 0x1210 nblocks 0x2 extsize 0x0 nextents 0x1
naextents 0x0 forkoff 0 dmevmask 0x0 dmstate 0x0
flags 0x0 gen 0x2829c6f9
Oper (34): tid: 30483aec  len: 16  clientid: TRANS  flags: none
EXTENTS inode data</pre><p>This inode update changes both the core and also the data fork.  Since we’re
changing the block map, it’s unsurprising that one of the subsequent operations
is an EFI:</p><pre class="screen">Oper (37): tid: 30483aec  len: 32  clientid: TRANS  flags: none
EFI:  #regs: 1    num_extents: 1  id: 0xffff8801147b5c20
(s: 0x720daf, l: 1)
\----------------------------------------------------------------------------
Oper (38): tid: 30483aec  len: 32  clientid: TRANS  flags: none
EFD:  #regs: 1    num_extents: 1  id: 0xffff8801147b5c20
\----------------------------------------------------------------------------
Oper (39): tid: 30483aec  len: 24  clientid: TRANS  flags: none
BUF:  #regs: 2   start blkno: 8 (0x8)  len: 8  bmap size: 1  flags: 0x2800
Oper (40): tid: 30483aec  len: 128  clientid: TRANS  flags: none
AGF Buffer: XAGF
ver: 1  seq#: 0  len: 56308224
root BNO: 18174905  CNT: 18175030
level BNO: 2  CNT: 2
1st: 41  last: 46  cnt: 6  freeblks: 35790503  longest: 19343245
\----------------------------------------------------------------------------
Oper (41): tid: 30483aec  len: 24  clientid: TRANS  flags: none
BUF:  #regs: 3   start blkno: 145398760 (0x8aa9be8)  len: 8  bmap size: 1  flags: 0x2000
Oper (42): tid: 30483aec  len: 128  clientid: TRANS  flags: none
BUF DATA
Oper (43): tid: 30483aec  len: 128  clientid: TRANS  flags: none
BUF DATA
\----------------------------------------------------------------------------
Oper (44): tid: 30483aec  len: 24  clientid: TRANS  flags: none
BUF:  #regs: 3   start blkno: 145400224 (0x8aaa1a0)  len: 8  bmap size: 1  flags: 0x2000
Oper (45): tid: 30483aec  len: 128  clientid: TRANS  flags: none
BUF DATA
Oper (46): tid: 30483aec  len: 3584  clientid: TRANS  flags: none
BUF DATA
\----------------------------------------------------------------------------
Oper (47): tid: 30483aec  len: 24  clientid: TRANS  flags: none
BUF:  #regs: 3   start blkno: 59066216 (0x3854768)  len: 8  bmap size: 1  flags: 0x2000
Oper (48): tid: 30483aec  len: 128  clientid: TRANS  flags: none
BUF DATA
Oper (49): tid: 30483aec  len: 768  clientid: TRANS  flags: none
BUF DATA</pre><p>Here we see an EFI, followed by an EFD, followed by updates to the AGF and the
free space B+trees.  Most probably, we just unmapped a few blocks from a file.</p><pre class="screen">Oper (50): tid: 30483aec  len: 56  clientid: TRANS  flags: none
INODE: #regs: 2   ino: 0x3906f20  flags: 0x1   dsize: 16
        blkno: 59797280  len: 16  boff: 0
Oper (51): tid: 30483aec  len: 96  clientid: TRANS  flags: none
INODE CORE
magic 0x494e mode 0100644 version 2 format 2
nlink 1 uid 1000 gid 1000
atime 0x563a3938 mtime 0x563a3938 ctime 0x563a3938
size 0x0 nblocks 0x0 extsize 0x0 nextents 0x0
naextents 0x0 forkoff 0 dmevmask 0x0 dmstate 0x0
flags 0x0 gen 0x35ed661
\----------------------------------------------------------------------------
Oper (52): tid: 30483aec  len: 0  clientid: TRANS  flags: COMMIT</pre><p>One more inode core update and this transaction commits.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Internal_Inodes"></a>Chapter 15. Internal Inodes</h2></div></div></div><p>XFS allocates several inodes when a filesystem is created. These are internal
and not accessible from the standard directory structure. These inodes are only
accessible from the superblock.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Quota_Inodes"></a>15.1. Quota Inodes</h2></div></div></div><p>Prior to version 5 filesystems, two inodes can be allocated for quota
management.  The first inode will be used for user quotas.  The second inode
will be used for group quotas or project quotas, depending on mount options.
Group and project quotas are mutually exclusive features in these environments.</p><p>In version 5 or later filesystems, each quota type is allocated its own inode,
making it possible to use group and project quota management simultaneously.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Project quota’s primary purpose is to track and monitor disk usage for
directories. For this to occur, the directory inode must have the
<code class="literal">XFS_DIFLAG_PROJINHERIT</code> flag set so all inodes created underneath the directory
inherit the project ID.
</li><li class="listitem">
Inodes and blocks owned by ID zero do not have enforced quotas, but only quota
accounting.
</li><li class="listitem">
Extended attributes do not contribute towards the ID’s quota.
</li><li class="listitem">
To access each ID’s quota information in the file, seek to the ID offset
multiplied by the size of <code class="literal">xfs_dqblk_t</code> (136 bytes).
</li></ul></div><div class="figure"><a id="idm4700"></a><p class="title"><strong>Figure 15.1. Quota inode layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/76.png" alt="images/76.png" /></div></div></div><br class="figure-break" /><p>Quota information is stored in the data extents of the reserved quota
inodes as an array of the <code class="literal">xfs_dqblk</code> structures, where there is one array
element for each ID in the system:</p><pre class="programlisting">struct xfs_disk_dquot {
     __be16                d_magic;
     __u8                  d_version;
     __u8                  d_flags;
     __be32                d_id;
     __be64                d_blk_hardlimit;
     __be64                d_blk_softlimit;
     __be64                d_ino_hardlimit;
     __be64                d_ino_softlimit;
     __be64                d_bcount;
     __be64                d_icount;
     __be32                d_itimer;
     __be32                d_btimer;
     __be16                d_iwarns;
     __be16                d_bwarns;
     __be32                d_pad0;
     __be64                d_rtb_hardlimit;
     __be64                d_rtb_softlimit;
     __be64                d_rtbcount;
     __be32                d_rtbtimer;
     __be16                d_rtbwarns;
     __be16                d_pad;
};
struct xfs_dqblk {
     struct xfs_disk_dquot dd_diskdq;
     char                  dd_fill[4];

     /* version 5 filesystem fields begin here */
     __be32                dd_crc;
     __be64                dd_lsn;
     uuid_t                dd_uuid;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>d_magic</strong></span>
</span></dt><dd>
Specifies the signature where these two bytes are 0x4451 (<code class="literal">XFS_DQUOT_MAGIC</code>),
or “DQ” in ASCII.
</dd><dt><span class="term">
<span class="strong"><strong>d_version</strong></span>
</span></dt><dd>
The structure version, currently this is 1 (<code class="literal">XFS_DQUOT_VERSION</code>).
</dd><dt><span class="term">
<span class="strong"><strong>d_flags</strong></span>
</span></dt><dd>
Specifies which type of ID the structure applies to:
</dd></dl></div><pre class="programlisting">#define XFS_DQ_USER  0x0001
#define XFS_DQ_PROJ  0x0002
#define XFS_DQ_GROUP 0x0004</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>d_id</strong></span>
</span></dt><dd>
The ID for the quota structure. This will be a uid, gid or projid based on the
value of <code class="literal">d_flags</code>.
</dd><dt><span class="term">
<span class="strong"><strong>d_blk_hardlimit</strong></span>
</span></dt><dd>
The hard limit for the number of filesystem blocks the ID can own. The
ID will not be able to use more space than this limit. If it is attempted,
<code class="literal">ENOSPC</code> will be returned.
</dd><dt><span class="term">
<span class="strong"><strong>d_blk_softlimit</strong></span>
</span></dt><dd>
The soft limit for the number of filesystem blocks the ID can own.
The ID can temporarily use more space than by <code class="literal">d_blk_softlimit</code> up to
<code class="literal">d_blk_hardlimit</code>. If the space is not freed by the time limit specified by ID
zero’s <code class="literal">d_btimer</code> value, the ID will be denied more space until the total
blocks owned goes below <code class="literal">d_blk_softlimit</code>.
</dd><dt><span class="term">
<span class="strong"><strong>d_ino_hardlimit</strong></span>
</span></dt><dd>
The hard limit for the number of inodes the ID can own. The ID will
not be able to create or own any more inodes if <code class="literal">d_icount</code> reaches this value.
</dd><dt><span class="term">
<span class="strong"><strong>d_ino_softlimit</strong></span>
</span></dt><dd>
The soft limit for the number of inodes the ID can own. The ID can
temporarily create or own more inodes than specified by <code class="literal">d_ino_softlimit</code> up to
<code class="literal">d_ino_hardlimit</code>. If the inode count is not reduced by the time limit specified
by ID zero’s <code class="literal">d_itimer</code> value, the ID will be denied from creating or owning more
inodes until the count goes below <code class="literal">d_ino_softlimit</code>.
</dd><dt><span class="term">
<span class="strong"><strong>d_bcount</strong></span>
</span></dt><dd>
How many filesystem blocks are actually owned by the ID.
</dd><dt><span class="term">
<span class="strong"><strong>d_icount</strong></span>
</span></dt><dd>
How many inodes are actually owned by the ID.
</dd><dt><span class="term">
<span class="strong"><strong>d_itimer</strong></span>
</span></dt><dd>
Specifies the time when the ID’s <code class="literal">d_icount</code> exceeded <code class="literal">d_ino_softlimit</code>. The soft
limit will turn into a hard limit after the elapsed time exceeds ID zero’s
<code class="literal">d_itimer</code> value. When d_icount goes back below <code class="literal">d_ino_softlimit</code>, <code class="literal">d_itimer</code>
is reset back to zero.
</dd></dl></div><p>If the <code class="literal">XFS_SB_FEAT_INCOMPAT_BIGTIME</code> feature is enabled, the 32 bits used by
the timestamp field are interpreted as the upper 32 bits of an 34-bit unsigned
seconds counter.  See the section about <a class="link" href="#Quota_Timers" title="12.2. Quota Grace Period Expiration Timers">quota expiration
timers</a> for more details.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>d_btimer</strong></span>
</span></dt><dd>
Specifies the time when the ID’s <code class="literal">d_bcount</code> exceeded <code class="literal">d_blk_softlimit</code>. The soft
limit will turn into a hard limit after the elapsed time exceeds ID zero’s
<code class="literal">d_btimer</code> value. When d_bcount goes back below <code class="literal">d_blk_softlimit</code>, <code class="literal">d_btimer</code>
is reset back to zero.
</dd><dt><span class="term">
<span class="strong"><strong>d_iwarns</strong></span>
, </span><span class="term">
<span class="strong"><strong>d_bwarns</strong></span>
, </span><span class="term">
<span class="strong"><strong>d_rtbwarns</strong></span>
</span></dt><dd>
Specifies how many times a warning has been issued. Currently not used.
</dd><dt><span class="term">
<span class="strong"><strong>d_rtb_hardlimit</strong></span>
</span></dt><dd>
The hard limit for the number of real-time blocks the ID can own. The
ID cannot own more space on the real-time subvolume beyond this limit.
</dd><dt><span class="term">
<span class="strong"><strong>d_rtb_softlimit</strong></span>
</span></dt><dd>
The soft limit for the number of real-time blocks the ID can own. The
ID can temporarily own more space than specified by <code class="literal">d_rtb_softlimit</code> up to
<code class="literal">d_rtb_hardlimit</code>. If <code class="literal">d_rtbcount</code> is not reduced by the time limit specified
by ID zero’s <code class="literal">d_rtbtimer value</code>, the ID will be denied from owning more space
until the count goes below <code class="literal">d_rtb_softlimit</code>.
</dd><dt><span class="term">
<span class="strong"><strong>d_rtbcount</strong></span>
</span></dt><dd>
How many real-time blocks are currently owned by the ID.
</dd><dt><span class="term">
<span class="strong"><strong>d_rtbtimer</strong></span>
</span></dt><dd>
Specifies the time when the ID’s <code class="literal">d_rtbcount</code> exceeded <code class="literal">d_rtb_softlimit</code>. The
soft limit will turn into a hard limit after the elapsed time exceeds ID zero’s
<code class="literal">d_rtbtimer</code> value. When <code class="literal">d_rtbcount</code> goes back below <code class="literal">d_rtb_softlimit</code>,
<code class="literal">d_rtbtimer</code> is reset back to zero.
</dd><dt><span class="term">
<span class="strong"><strong>dd_uuid</strong></span>
</span></dt><dd>
The UUID of this block, which must match either <code class="literal">sb_uuid</code> or <code class="literal">sb_meta_uuid</code>
depending on which features are set.
</dd><dt><span class="term">
<span class="strong"><strong>dd_lsn</strong></span>
</span></dt><dd>
Log sequence number of the last DQ block write.
</dd><dt><span class="term">
<span class="strong"><strong>dd_crc</strong></span>
</span></dt><dd>
Checksum of the DQ block.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Real-time_Inodes"></a>15.2. Real-time Inodes</h2></div></div></div><p>There are two inodes allocated to managing the real-time device’s space, the
Bitmap Inode and the Summary Inode.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Real-Time_Bitmap_Inode"></a>15.2.1. Real-Time Bitmap Inode</h3></div></div></div><p>The real time bitmap inode, <code class="literal">sb_rbmino</code>, tracks the used/free space in the
real-time device using an old-style bitmap. One bit is allocated per real-time
extent. The size of an extent is specified by the superblock’s <code class="literal">sb_rextsize</code>
value.</p><p>The number of blocks used by the bitmap inode is equal to the number of
real-time extents (<code class="literal">sb_rextents</code>) divided by the block size (<code class="literal">sb_blocksize</code>)
and bits per byte. This value is stored in <code class="literal">sb_rbmblocks</code>. The nblocks and
extent array for the inode should match this.  Each real time block gets its
own bit in the bitmap.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Real-Time_Summary_Inode"></a>15.2.2. Real-Time Summary Inode</h3></div></div></div><p>The real time summary inode, <code class="literal">sb_rsumino</code>, tracks the used and free space
accounting information for the real-time device.  This file indexes the
approximate location of each free extent on the real-time device first by
log2(extent size) and then by the real-time bitmap block number.  The size of
the summary inode file is equal to <code class="literal">sb_rbmblocks</code> × log2(realtime device size)
× sizeof(<code class="literal">xfs_suminfo_t</code>).  The entry for a given log2(extent size) and
rtbitmap block number is 0 if there is no free extents of that size at that
rtbitmap location, and positive if there are any.</p><p>This data structure is not particularly space efficient, however it is a very
fast way to provide the same data as the two free space B+trees for regular
files since the space is preallocated and metadata maintenance is minimal.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Real_time_Reverse_Mapping_Btree"></a>15.2.3. Real-Time Reverse-Mapping B+tree</h3></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>This data structure is under construction!  Details may change.</p></div><p>If the reverse-mapping B+tree and real-time storage device features
are enabled, the real-time device has its own reverse block-mapping
B+tree.</p><p>As mentioned in the chapter about <a class="link" href="#Reconstruction" title="Chapter 5. Metadata Reconstruction">reconstruction</a>,
this data structure is another piece of the puzzle necessary to
reconstruct the data or attribute fork of a file from reverse-mapping
records; we can also use it to double-check allocations to ensure that
we are not accidentally cross-linking blocks, which can cause severe
damage to the filesystem.</p><p>This B+tree is only present if the <code class="literal">XFS_SB_FEAT_RO_COMPAT_RMAPBT</code>
feature is enabled and a real time device is present.  The feature
requires a version 5 filesystem.</p><p>The real-time reverse mapping B+tree is rooted in an inode’s data
fork; the inode number is given by the <code class="literal">sb_rrmapino</code> field in the
superblock.  The B+tree blocks themselves are stored in the regular
filesystem.  The structures used for an inode’s B+tree root are:</p><pre class="programlisting">struct xfs_rtrmap_root {
     __be16                     bb_level;
     __be16                     bb_numrecs;
};</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
On disk, the B+tree node starts with the <code class="literal">xfs_rtrmap_root</code> header
followed by an array of <code class="literal">xfs_rtrmap_key</code> values and then an array of
<code class="literal">xfs_rtrmap_ptr_t</code> values. The size of both arrays is specified by the
header’s <code class="literal">bb_numrecs</code> value.
</li><li class="listitem">
The root node in the inode can only contain up to 10 key/pointer
pairs for a standard 512 byte inode before a new level of nodes is
added between the root and the leaves.  <code class="literal">di_forkoff</code> should always
be zero, because there are no extended attributes.
</li></ul></div><p>Each record in the real-time reverse-mapping B+tree has the following
structure:</p><pre class="programlisting">struct xfs_rtrmap_rec {
     __be64                     rm_startblock;
     __be64                     rm_blockcount;
     __be64                     rm_owner;
     __be64                     rm_fork:1;
     __be64                     rm_bmbt:1;
     __be64                     rm_unwritten:1;
     __be64                     rm_unused:7;
     __be64                     rm_offset:54;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>rm_startblock</strong></span>
</span></dt><dd>
Real-time device block number of this record.
</dd><dt><span class="term">
<span class="strong"><strong>rm_blockcount</strong></span>
</span></dt><dd>
The length of this extent, in real-time blocks.
</dd><dt><span class="term">
<span class="strong"><strong>rm_owner</strong></span>
</span></dt><dd>
A 64-bit number describing the owner of this extent.  This must be an
inode number, because the real-time device is for file data only.
</dd><dt><span class="term">
<span class="strong"><strong>rm_fork</strong></span>
</span></dt><dd>
If <code class="literal">rm_owner</code> describes an inode, this can be 1 if this record is for
an attribute fork.  This value will always be zero for real-time
extents.
</dd><dt><span class="term">
<span class="strong"><strong>rm_bmbt</strong></span>
</span></dt><dd>
If <code class="literal">rm_owner</code> describes an inode, this can be 1 to signify that this
record is for a block map B+tree block.  In this case, <code class="literal">rm_offset</code> has
no meaning.  This value will always be zero for real-time extents.
</dd><dt><span class="term">
<span class="strong"><strong>rm_unwritten</strong></span>
</span></dt><dd>
A flag indicating that the extent is unwritten.  This corresponds to
the flag in the <a class="link" href="#Data_Extents" title="Chapter 17. Data Extents">extent record</a> format which means
<code class="literal">XFS_EXT_UNWRITTEN</code>.
</dd><dt><span class="term">
<span class="strong"><strong>rm_offset</strong></span>
</span></dt><dd>
The 54-bit logical file block offset, if <code class="literal">rm_owner</code> describes an
inode.
</dd></dl></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The single-bit flag values <code class="literal">rm_unwritten</code>, <code class="literal">rm_fork</code>, and <code class="literal">rm_bmbt</code>
are packed into the larger fields in the C structure definition.</p></div><p>The key has the following structure:</p><pre class="programlisting">struct xfs_rtrmap_key {
     __be64                     rm_startblock;
     __be64                     rm_owner;
     __be64                     rm_fork:1;
     __be64                     rm_bmbt:1;
     __be64                     rm_reserved:1;
     __be64                     rm_unused:7;
     __be64                     rm_offset:54;
};</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
All block numbers are 64-bit real-time device block numbers.
</li><li class="listitem">
The <code class="literal">bb_magic</code> value is “MAPR” (0x4d415052).
</li><li class="listitem">
The <code class="literal">xfs_btree_lblock_t</code> header is used for intermediate B+tree node as well
as the leaves.
</li><li class="listitem">
Each pointer is associated with two keys.  The first of these is the
"low key", which is the key of the smallest record accessible through
the pointer.  This low key has the same meaning as the key in all
other btrees.  The second key is the high key, which is the maximum of
the largest key that can be used to access a given record underneath
the pointer.  Recall that each record in the real-time reverse mapping
b+tree describes an interval of physical blocks mapped to an interval
of logical file block offsets; therefore, it makes sense that a range
of keys can be used to find to a record.
</li></ul></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a id="_xfs_db_rtrmapbt_example"></a>xfs_db rtrmapbt Example</h4></div></div></div><p>This example shows a real-time reverse-mapping B+tree from a freshly
populated root filesystem:</p><pre class="screen">xfs_db&gt; sb 0
xfs_db&gt; addr rrmapino
xfs_db&gt; p
core.magic = 0x494e
core.mode = 0100000
core.version = 3
core.format = 5 (rtrmapbt)
...
u3.rtrmapbt.level = 3
u3.rtrmapbt.numrecs = 1
u3.rtrmapbt.keys[1] = [startblock,owner,offset,attrfork,bmbtblock,startblock_hi,
                       owner_hi,offset_hi,attrfork_hi,bmbtblock_hi]
        1:[1,132,1,0,0,1705337,133,54431,0,0]
u3.rtrmapbt.ptrs[1] = 1:671
xfs_db&gt; addr u3.rtrmapbt.ptrs[1]
xfs_db&gt; p
magic = 0x4d415052
level = 2
numrecs = 8
leftsib = null
rightsib = null
bno = 5368
lsn = 0x400000000
uuid = 98bbde42-67e7-46a5-a73e-d64a76b1b5ce
owner = 131
crc = 0x2560d199 (correct)
keys[1-8] = [startblock,owner,offset,attrfork,bmbtblock,startblock_hi,owner_hi,
             offset_hi,attrfork_hi,bmbtblock_hi]
        1:[1,132,1,0,0,17749,132,17749,0,0]
        2:[17751,132,17751,0,0,35499,132,35499,0,0]
        3:[35501,132,35501,0,0,53249,132,53249,0,0]
        4:[53251,132,53251,0,0,1658473,133,7567,0,0]
        5:[1658475,133,7569,0,0,1667473,133,16567,0,0]
        6:[1667475,133,16569,0,0,1685223,133,34317,0,0]
        7:[1685225,133,34319,0,0,1694223,133,43317,0,0]
        8:[1694225,133,43319,0,0,1705337,133,54431,0,0]
ptrs[1-8] = 1:134 2:238 3:345 4:453 5:795 6:563 7:670 8:780</pre><p>We arbitrarily pick pointer 7 (twice) to traverse downwards:</p><pre class="screen">xfs_db&gt; addr ptrs[7]
xfs_db&gt; p
magic = 0x4d415052
level = 1
numrecs = 36
leftsib = 563
rightsib = 780
bno = 5360
lsn = 0
uuid = 98bbde42-67e7-46a5-a73e-d64a76b1b5ce
owner = 131
crc = 0x6807761d (correct)
keys[1-36] = [startblock,owner,offset,attrfork,bmbtblock,startblock_hi,owner_hi,
              offset_hi,attrfork_hi,bmbtblock_hi]
        1:[1685225,133,34319,0,0,1685473,133,34567,0,0]
        2:[1685475,133,34569,0,0,1685723,133,34817,0,0]
        3:[1685725,133,34819,0,0,1685973,133,35067,0,0]
        ...
        34:[1693475,133,42569,0,0,1693723,133,42817,0,0]
        35:[1693725,133,42819,0,0,1693973,133,43067,0,0]
        36:[1693975,133,43069,0,0,1694223,133,43317,0,0]
ptrs[1-36] = 1:669 2:672 3:674...34:722 35:723 36:725
xfs_db&gt; addr ptrs[7]
xfs_db&gt; p
magic = 0x4d415052
level = 0
numrecs = 125
leftsib = 678
rightsib = 681
bno = 5440
lsn = 0
uuid = 98bbde42-67e7-46a5-a73e-d64a76b1b5ce
owner = 131
crc = 0xefce34d4 (correct)
recs[1-125] = [startblock,blockcount,owner,offset,extentflag,attrfork,bmbtblock]
        1:[1686725,1,133,35819,0,0,0]
        2:[1686727,1,133,35821,0,0,0]
        3:[1686729,1,133,35823,0,0,0]
        ...
        123:[1686969,1,133,36063,0,0,0]
        124:[1686971,1,133,36065,0,0,0]
        125:[1686973,1,133,36067,0,0,0]</pre><p>Several interesting things pop out here.  The first record shows that
inode 133 has mapped real-time block 1,686,725 at offset 35,819.  We
confirm this by looking at the block map for that inode:</p><pre class="screen">xfs_db&gt; inode 133
xfs_db&gt; p core.realtime
core.realtime = 1
xfs_db&gt; bmap
data offset 35817 startblock 1686723 (1/638147) count 1 flag 0
data offset 35819 startblock 1686725 (1/638149) count 1 flag 0
data offset 35821 startblock 1686727 (1/638151) count 1 flag 0</pre><p>Notice that inode 133 has the real-time flag set, which means that its
data blocks are all allocated from the real-time device.</p></div></div></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="_dynamically_allocated_structures"></a>Part III. Dynamically Allocated Structures</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="On-disk_Inode"></a>Chapter 16. On-disk Inode</h2></div></div></div><p>All files, directories, and links are stored on disk with inodes and descend from
the root inode with its number defined in the <a class="link" href="#Superblocks" title="13.1. Superblocks">superblock</a>. The
previous section on <a class="link" href="#AG_Inode_Management" title="13.3. AG Inode Management">AG Inode Management</a> describes the
allocation and management of inodes on disk. This section describes the contents
of inodes themselves.</p><p>An inode is divided into 3 parts:</p><div class="figure"><a id="idm4977"></a><p class="title"><strong>Figure 16.1. On-disk inode sections</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/23.png" alt="images/23.png" /></div></div></div><br class="figure-break" /><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The core contains what the inode represents, stat data, and information
describing the data and attribute forks.
</li><li class="listitem">
The <code class="literal">di_u</code> “data fork” contains normal data related to the inode. Its contents
depends on the file type specified by <code class="literal">di_core.di_mode</code> (eg. regular file,
directory, link, etc) and how much information is contained in the file which
determined by <code class="literal">di_core.di_format</code>. The following union to represent this data is
declared as follows:
</li></ul></div><pre class="programlisting">union {
     xfs_bmdr_block_t di_bmbt;
     xfs_bmbt_rec_t   di_bmx[1];
     xfs_dir2_sf_t    di_dir2sf;
     char             di_c[1];
     xfs_dev_t        di_dev;
     uuid_t           di_muuid;
     char             di_symlink[1];
} di_u;</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The <code class="literal">di_a</code> “attribute fork” contains extended attributes. Its layout is
determined by the <code class="literal">di_core.di_aformat</code> value. Its representation is declared as
follows:
</li></ul></div><pre class="programlisting">union {
     xfs_bmdr_block_t     di_abmbt;
     xfs_bmbt_rec_t       di_abmx[1];
     xfs_attr_shortform_t di_attrsf;
} di_a;</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The above two unions are rarely used in the XFS code, but the structures
within the union are directly cast depending on the <code class="literal">di_mode/di_format</code> and
<code class="literal">di_aformat</code> values. They are referenced in this document to make it easier to
explain the various structures in use within the inode.</p></div><p>The remaining space in the inode after <code class="literal">di_next_unlinked</code> where the two forks
are located is called the inode’s “literal area”. This starts at offset 100
(0x64) in a version 1 or 2 inode, and offset 176 (0xb0) in a version 3 inode.</p><p>The space for each of the two forks in the literal area is determined by the
inode size, and <code class="literal">di_core.di_forkoff</code>. The data fork is located between the start
of the literal area and <code class="literal">di_forkoff</code>. The attribute fork is located between
<code class="literal">di_forkoff</code> and the end of the inode.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Inode_Core"></a>16.1. Inode Core</h2></div></div></div><p>The inode’s core is 96 bytes on a V4 filesystem and 176 bytes on a V5
filesystem.  It contains information about the file itself including most stat
data information about data and attribute forks after the core within the
inode. It uses the following structure:</p><pre class="programlisting">struct xfs_dinode_core {
     __uint16_t                di_magic;
     __uint16_t                di_mode;
     __int8_t                  di_version;
     __int8_t                  di_format;
     __uint16_t                di_onlink;
     __uint32_t                di_uid;
     __uint32_t                di_gid;
     __uint32_t                di_nlink;
     __uint16_t                di_projid;
     __uint16_t                di_projid_hi;
     union {
          /* Number of data fork extents if NREXT64 is set */
          __be64               di_big_nextents;

          /* Padding for V3 inodes without NREXT64 set. */
          __be64               di_v3_pad;

          /* Padding and inode flush counter for V2 inodes. */
          struct {
               __u8            di_v2_pad[6];
               __be16          di_flushiter;
          };
     };
     xfs_timestamp_t           di_atime;
     xfs_timestamp_t           di_mtime;
     xfs_timestamp_t           di_ctime;
     xfs_fsize_t               di_size;
     xfs_rfsblock_t            di_nblocks;
     xfs_extlen_t              di_extsize;
     union {
          /*
           * For V2 inodes and V3 inodes without NREXT64 set, this
           * is the number of data and attr fork extents.
           */
          struct {
               __be32          di_nextents;
               __be16          di_anextents;
          } __packed;

          /* Number of attr fork extents if NREXT64 is set. */
          struct {
               __be32          di_big_anextents;
               __be16          di_nrext64_pad;
          } __packed;
     } __packed;
     xfs_extnum_t              di_nextents;
     xfs_aextnum_t             di_anextents;
     __uint8_t                 di_forkoff;
     __int8_t                  di_aformat;
     __uint32_t                di_dmevmask;
     __uint16_t                di_dmstate;
     __uint16_t                di_flags;
     __uint32_t                di_gen;

     /* di_next_unlinked is the only non-core field in the old dinode */
     __be32                    di_next_unlinked;

     /* version 5 filesystem (inode version 3) fields start here */
     __le32                    di_crc;
     __be64                    di_changecount;
     __be64                    di_lsn;
     __be64                    di_flags2;
     __be32                    di_cowextsize;
     __u8                      di_pad2[12];
     xfs_timestamp_t           di_crtime;
     __be64                    di_ino;
     uuid_t                    di_uuid;

};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>di_magic</strong></span>
</span></dt><dd>
The inode signature; these two bytes are “IN” (0x494e).
</dd><dt><span class="term">
<span class="strong"><strong>di_mode</strong></span>
</span></dt><dd>
Specifies the mode access bits and type of file using the standard S_Ixxx values
defined in stat.h.
</dd><dt><span class="term">
<span class="strong"><strong>di_version</strong></span>
</span></dt><dd>
Specifies the inode version which currently can only be 1, 2, or 3. The inode
version specifies the usage of the <code class="literal">di_onlink</code>, <code class="literal">di_nlink</code> and <code class="literal">di_projid</code>
values in the inode core. Initially, inodes are created as v1 but can be
converted on the fly to v2 when required.  v3 inodes are created only for v5
filesystems.
</dd><dt><span class="term">
<span class="strong"><strong>di_format</strong></span>
</span></dt><dd>
Specifies the format of the data fork in conjunction with the <code class="literal">di_mode</code> type.
This can be one of several values. For directories and links, it can be “local”
where all metadata associated with the file is within the inode; “extents” where
the inode contains an array of extents to other filesystem blocks which contain
the associated metadata or data; or “btree” where the inode contains a B+tree
root node which points to filesystem blocks containing the metadata or data.
Migration between the formats depends on the amount of metadata associated with
the inode. “dev” is used for character and block devices while “uuid” is
currently not used.  “rmap” indicates that a reverse-mapping B+tree
is rooted in the fork.
</dd></dl></div><pre class="programlisting">typedef enum xfs_dinode_fmt {
     XFS_DINODE_FMT_DEV,
     XFS_DINODE_FMT_LOCAL,
     XFS_DINODE_FMT_EXTENTS,
     XFS_DINODE_FMT_BTREE,
     XFS_DINODE_FMT_UUID,
     XFS_DINODE_FMT_RMAP,
} xfs_dinode_fmt_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>di_onlink</strong></span>
</span></dt><dd>
In v1 inodes, this specifies the number of links to the inode from directories.
When the number exceeds 65535, the inode is converted to v2 and the link count
is stored in <code class="literal">di_nlink</code>.
</dd><dt><span class="term">
<span class="strong"><strong>di_uid</strong></span>
</span></dt><dd>
Specifies the owner’s UID of the inode.
</dd><dt><span class="term">
<span class="strong"><strong>di_gid</strong></span>
</span></dt><dd>
Specifies the owner’s GID of the inode.
</dd><dt><span class="term">
<span class="strong"><strong>di_nlink</strong></span>
</span></dt><dd>
Specifies the number of links to the inode from directories. This is maintained
for both inode versions for current versions of XFS.  Prior to v2 inodes, this
field was part of <code class="literal">di_pad</code>.
</dd><dt><span class="term">
<span class="strong"><strong>di_projid</strong></span>
</span></dt><dd>
Specifies the owner’s project ID in v2 inodes. An inode is converted to v2 if
the project ID is set. This value must be zero for v1 inodes.
</dd><dt><span class="term">
<span class="strong"><strong>di_projid_hi</strong></span>
</span></dt><dd>
Specifies the high 16 bits of the owner’s project ID in v2 inodes, if the
<code class="literal">XFS_SB_VERSION2_PROJID32BIT</code> feature is set; and zero otherwise.
</dd><dt><span class="term">
<span class="strong"><strong>di_pad[6]</strong></span>
</span></dt><dd>
Reserved, must be zero.  Only exists for v2 inodes.
</dd><dt><span class="term">
<span class="strong"><strong>di_flushiter</strong></span>
</span></dt><dd>
Incremented on flush.  Only exists for v2 inodes.
</dd><dt><span class="term">
<span class="strong"><strong>di_v3_pad</strong></span>
</span></dt><dd>
Must be zero for v3 inodes without the NREXT64 flag set.
</dd><dt><span class="term">
<span class="strong"><strong>di_big_nextents</strong></span>
</span></dt><dd>
Specifies the number of data extents associated with this inode if the NREXT64
flag is set.  This allows for up to 2<sup>48</sup> - 1 extent mappings.
</dd><dt><span class="term">
<span class="strong"><strong>di_atime</strong></span>
</span></dt><dd>
Specifies the last access time of the files using UNIX time conventions the
following structure. This value may be undefined if the filesystem is mounted
with the “noatime” option.  XFS supports timestamps with nanosecond resolution:
</dd></dl></div><pre class="programlisting">struct xfs_timestamp {
     __int32_t                 t_sec;
     __int32_t                 t_nsec;
};</pre><p>If the <code class="literal">XFS_SB_FEAT_INCOMPAT_BIGTIME</code> feature is enabled, the 64 bits used by
the timestamp field are interpreted as a flat 64-bit nanosecond counter.
See the section about <a class="link" href="#Inode_Timestamps" title="12.1. Inode Timestamps">inode timestamps</a> for more details.</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>di_mtime</strong></span>
</span></dt><dd>
Specifies the last time the file was modified.
</dd><dt><span class="term">
<span class="strong"><strong>di_ctime</strong></span>
</span></dt><dd>
Specifies when the inode’s status was last changed.
</dd><dt><span class="term">
<span class="strong"><strong>di_size</strong></span>
</span></dt><dd>
Specifies the EOF of the inode in bytes. This can be larger or smaller than the
extent space (therefore actual disk space) used for the inode. For regular
files, this is the filesize in bytes, directories, the space taken by directory
entries and for links, the length of the symlink.
</dd><dt><span class="term">
<span class="strong"><strong>di_nblocks</strong></span>
</span></dt><dd>
Specifies the number of filesystem blocks used to store the inode’s data
including relevant metadata like B+trees. This does not include blocks used for
extended attributes.
</dd><dt><span class="term">
<span class="strong"><strong>di_extsize</strong></span>
</span></dt><dd>
Specifies the extent size for filesystems with real-time devices or an extent
size hint for standard filesystems. For normal filesystems, and with
directories, the <code class="literal">XFS_DIFLAG_EXTSZINHERIT</code> flag must be set in <code class="literal">di_flags</code> if
this field is used. Inodes created in these directories will inherit the
di_extsize value and have <code class="literal">XFS_DIFLAG_EXTSIZE</code> set in their <code class="literal">di_flags</code>. When a
file is written to beyond allocated space, XFS will attempt to allocate
additional disk space based on this value.
</dd><dt><span class="term">
<span class="strong"><strong>di_nextents</strong></span>
</span></dt><dd>
Specifies the number of data extents associated with this inode if the NREXT64
flag is not set.  Supports up to 2<sup>31</sup> - 1 extents.
</dd><dt><span class="term">
<span class="strong"><strong>di_anextents</strong></span>
</span></dt><dd>
Specifies the number of extended attribute extents associated with this inode
if the NREXT64 flag is not set.  Supports up to 2<sup>15</sup> - 1 extents.
</dd><dt><span class="term">
<span class="strong"><strong>di_big_anextents</strong></span>
</span></dt><dd>
Specifies the number of extended attribute extents associated with this inode
if the NREXT64 flag is set.  Supports up to 2<sup>32</sup> - 1 extents.
</dd><dt><span class="term">
<span class="strong"><strong>di_nrext64_pad</strong></span>
</span></dt><dd>
Must be zero if the NREXT64 flag is set.
</dd><dt><span class="term">
<span class="strong"><strong>di_forkoff</strong></span>
</span></dt><dd>
Specifies the offset into the inode’s literal area where the extended attribute
fork starts. This is an 8-bit value that is multiplied by 8 to determine the
actual offset in bytes (ie. attribute data is 64-bit aligned). This also limits
the maximum size of the inode to 2048 bytes. This value is initially zero until
an extended attribute is created. When in attribute is added, the nature of
<code class="literal">di_forkoff</code> depends on the <code class="literal">XFS_SB_VERSION2_ATTR2BIT</code>  flag in the superblock.
Refer to <a class="link" href="#Extended_Attribute_Versions" title="16.4.1. Extended Attribute Versions">Extended Attribute Versions</a> for more
details.
</dd><dt><span class="term">
<span class="strong"><strong>di_aformat</strong></span>
</span></dt><dd>
Specifies the format of the attribute fork. This uses the same values as
<code class="literal">di_format</code>, but restricted to “local”, “extents” and “btree” formats for
extended attribute data.
</dd><dt><span class="term">
<span class="strong"><strong>di_dmevmask</strong></span>
</span></dt><dd>
DMAPI event mask.
</dd><dt><span class="term">
<span class="strong"><strong>di_dmstate</strong></span>
</span></dt><dd>
DMAPI state.
</dd><dt><span class="term">
<span class="strong"><strong>di_flags</strong></span>
</span></dt><dd>
Specifies flags associated with the inode. This can be a combination of the
following values:
</dd></dl></div><div class="table"><a id="idm5185"></a><p class="title"><strong>Table 16.1. Version 2 Inode flags</strong></p><div class="table-contents"><table class="table" summary="Version 2 Inode flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_REALTIME</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The inode’s data is located on the real-time device.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_PREALLOC</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The inode’s extents have been preallocated.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_NEWRTBM</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Specifies the <code class="literal">sb_rbmino</code> uses the new real-time bitmap format</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_IMMUTABLE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Specifies the inode cannot be modified.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_APPEND</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The inode is in append only mode.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_SYNC</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The inode is written synchronously.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_NOATIME</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The inode’s <code class="literal">di_atime</code> is not updated.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_NODUMP</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Specifies the inode is to be ignored by xfsdump.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_RTINHERIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>For directory inodes, new inodes inherit the <code class="literal">XFS_DIFLAG_REALTIME</code> bit.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_PROJINHERIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>For directory inodes, new inodes inherit the <code class="literal">di_projid</code> value.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_NOSYMLINKS</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>For directory inodes, symlinks cannot be created.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_EXTSIZE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Specifies the extent size for real-time files or an extent size hint for regular files.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_EXTSZINHERIT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>For directory inodes, new inodes inherit the <code class="literal">di_extsize</code> value.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_NODEFRAG</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Specifies the inode is to be ignored when defragmenting the filesystem.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG_FILESTREAMS</code></p></td><td style="" align="left" valign="top"><p>Use the filestream allocator.  The filestreams allocator allows a directory to
reserve an entire allocation group for exclusive use by files created in that
directory.  Files in other directories cannot use AGs reserved by other
directories.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>di_gen</strong></span>
</span></dt><dd>
A generation number used for inode identification. This is used by tools that do
inode scanning such as backup tools and xfsdump. An inode’s generation number
can change by unlinking and creating a new file that reuses the inode.
</dd><dt><span class="term">
<span class="strong"><strong>di_next_unlinked</strong></span>
</span></dt><dd>
See the section on <a class="link" href="#Unlinked_Pointer" title="16.2. Unlinked Pointer">unlinked inode pointers</a> for more
information.
</dd><dt><span class="term">
<span class="strong"><strong>di_crc</strong></span>
</span></dt><dd>
Checksum of the inode.
</dd><dt><span class="term">
<span class="strong"><strong>di_changecount</strong></span>
</span></dt><dd>
Counts the number of changes made to the attributes in this inode.
</dd><dt><span class="term">
<span class="strong"><strong>di_lsn</strong></span>
</span></dt><dd>
Log sequence number of the last inode write.
</dd><dt><span class="term">
<span class="strong"><strong>di_flags2</strong></span>
</span></dt><dd>
Specifies extended flags associated with a v3 inode.
</dd></dl></div><div class="table"><a id="idm5322"></a><p class="title"><strong>Table 16.2. Version 3 Inode flags</strong></p><div class="table-contents"><table class="table" summary="Version 3 Inode flags" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG2_DAX</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>For a file, enable DAX to increase performance on persistent-memory storage.
If set on a directory, files created in the directory will inherit this flag.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG2_REFLINK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>This inode shares (or has shared) data blocks with another inode.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG2_COWEXTSIZE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>For files, this is the extent size hint for copy on write operations; see
<code class="literal">di_cowextsize</code> for details.  For directories, the value in <code class="literal">di_cowextsize</code>
will be copied to all newly created files and directories.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIFLAG2_NREXT64</code></p></td><td style="" align="left" valign="top"><p>Files with this flag set may have up to (2<sup>48</sup> - 1) extents mapped to the data
fork and up to (2<sup>32</sup> - 1) extents mapped to the attribute fork.  This flag
requires the <code class="literal">XFS_SB_FEAT_INCOMPAT_NREXT64</code> feature to be enabled.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>di_cowextsize</strong></span>
</span></dt><dd>
Specifies the extent size hint for copy on write operations.  When allocating
extents for a copy on write operation, the allocator will be asked to align
its allocations to either <code class="literal">di_cowextsize</code> blocks or <code class="literal">di_extsize</code> blocks,
whichever is greater.  The <code class="literal">XFS_DIFLAG2_COWEXTSIZE</code> flag must be set if this
field is used.  If this field and its flag are set on a directory file, the
value will be copied into any files or directories created within this
directory.  During a block sharing operation, this value will be copied from
the source file to the destination file if the sharing operation completely
overwrites the destination file’s contents and the destination file does not
already have <code class="literal">di_cowextsize</code> set.
</dd><dt><span class="term">
<span class="strong"><strong>di_pad2</strong></span>
</span></dt><dd>
Padding for future expansion of the inode.
</dd><dt><span class="term">
<span class="strong"><strong>di_crtime</strong></span>
</span></dt><dd>
Specifies the time when this inode was created.
</dd><dt><span class="term">
<span class="strong"><strong>di_ino</strong></span>
</span></dt><dd>
The full inode number of this inode.
</dd><dt><span class="term">
<span class="strong"><strong>di_uuid</strong></span>
</span></dt><dd>
The UUID of this inode, which must match either <code class="literal">sb_uuid</code> or <code class="literal">sb_meta_uuid</code>
depending on which features are set.
</dd></dl></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Unlinked_Pointer"></a>16.2. Unlinked Pointer</h2></div></div></div><p>The <code class="literal">di_next_unlinked</code> value in the inode is used to track inodes that have
been unlinked (deleted) but are still open by a program.  When an inode is
in this state, the inode is added to one of the <a class="link" href="#AG_Inode_Management" title="13.3. AG Inode Management">AGI’s</a>
<code class="literal">agi_unlinked</code> hash buckets. The AGI unlinked bucket points to an inode and the
<code class="literal">di_next_unlinked</code> value points to the next inode in the chain. The last inode
in the chain has <code class="literal">di_next_unlinked</code> set to NULL (-1).</p><p>Once the last reference is released, the inode is removed from the unlinked hash
chain and <code class="literal">di_next_unlinked</code> is set to NULL. In the case of a system crash, XFS
recovery will complete the unlink process for any inodes found in these lists.</p><p>The only time the unlinked fields can be seen to be used on disk is either on an
active filesystem or a crashed system. A cleanly unmounted or recovered
filesystem will not have any inodes in these unlink hash chains.</p><div class="figure"><a id="idm5404"></a><p class="title"><strong>Figure 16.2. Unlinked inode pointer</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/28.png" alt="images/28.png" /></div></div></div><br class="figure-break" /></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Data_Fork"></a>16.3. Data Fork</h2></div></div></div><p>The structure of the inode’s data fork based is on the inode’s type and
<code class="literal">di_format</code>. The data fork begins at the start of the inode’s “literal area”.
This area starts at offset 100 (0x64), or offset 176 (0xb0) in a v3 inode. The
size of the data fork is determined by the type and format. The maximum size is
determined by the inode size and <code class="literal">di_forkoff</code>. In code, use the <code class="literal">XFS_DFORK_PTR</code>
macro specifying <code class="literal">XFS_DATA_FORK</code> for the “which” parameter. Alternatively,
the <code class="literal">XFS_DFORK_DPTR</code> macro can be used.</p><p>Each of the following sub-sections summarises the contents of the data fork
based on the inode type.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Regular_Files_S_IFREG"></a>16.3.1. Regular Files (S_IFREG)</h3></div></div></div><p>The data fork specifies the file’s data extents. The extents specify where the
file’s actual data is located within the filesystem. Extents can have 2 formats
which is defined by the di_format value:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">XFS_DINODE_FMT_EXTENTS</code>: The extent data is fully contained within the inode
which contains an array of extents to the filesystem blocks for the file’s data.
To access the extents, cast the return value from <code class="literal">XFS_DFORK_DPTR</code> to
<code class="literal">xfs_bmbt_rec_t*</code>.
</li><li class="listitem">
<code class="literal">XFS_DINODE_FMT_BTREE</code>: The extent data is contained in the leaves of a B+tree.
The inode contains the root node of the tree and is accessed by casting the
return value from <code class="literal">XFS_DFORK_DPTR</code> to <code class="literal">xfs_bmdr_block_t*</code>.
</li></ul></div><p>Details for each of these data extent formats are covered in the
<a class="link" href="#Data_Extents" title="Chapter 17. Data Extents">Data Extents</a> later on.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Directories_S_IFDIR"></a>16.3.2. Directories (S_IFDIR)</h3></div></div></div><p>The data fork contains the directory’s entries and associated data. The format
of the entries is also determined by the <code class="literal">di_format</code> value and can be one of 3
formats:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">XFS_DINODE_FMT_LOCAL</code>: The directory entries are fully contained within the
inode. This is accessed by casting the value from <code class="literal">XFS_DFORK_DPTR</code> to
<code class="literal">xfs_dir2_sf_t*</code>.
</li><li class="listitem">
<code class="literal">XFS_DINODE_FMT_EXTENTS</code>: The actual directory entries are located in another
filesystem block, the inode contains an array of extents to these filesystem
blocks (<code class="literal">xfs_bmbt_rec_t*</code>).
</li><li class="listitem">
<code class="literal">XFS_DINODE_FMT_BTREE</code>: The directory entries are contained in the leaves of a
B+tree. The inode contains the root node (<code class="literal">xfs_bmdr_block_t*</code>).
</li></ul></div><p>Details for each of these directory formats are covered in the
<a class="link" href="#Directories" title="Chapter 18. Directories">Directories</a> later on.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Symbolic_Links_S_IFLNK"></a>16.3.3. Symbolic Links (S_IFLNK)</h3></div></div></div><p>The data fork contains the contents of the symbolic link. The format of the link
is determined by the <code class="literal">di_format</code> value and can be one of 2 formats:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">XFS_DINODE_FMT_LOCAL</code>: The symbolic link is fully contained within the inode.
This is accessed by casting the return value from <code class="literal">XFS_DFORK_DPTR</code> to <code class="literal">char*</code>.
</li><li class="listitem">
<code class="literal">XFS_DINODE_FMT_EXTENTS</code>: The actual symlink is located in another filesystem
block, the inode contains the extents to these filesystem blocks
(<code class="literal">xfs_bmbt_rec_t*</code>).
</li></ul></div><p>Details for symbolic links is covered in the section about
<a class="link" href="#Symbolic_Links" title="Chapter 20. Symbolic Links">Symbolic Links</a>.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Other_File_Types"></a>16.3.4. Other File Types</h3></div></div></div><p>For character and block devices (<code class="literal">S_IFCHR</code> and <code class="literal">S_IFBLK</code>), cast the value from
<code class="literal">XFS_DFORK_DPTR</code> to <code class="literal">xfs_dev_t*</code>.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Attribute_Fork"></a>16.4. Attribute Fork</h2></div></div></div><p>The attribute fork in the inode always contains the location of the extended
attributes associated with the inode.</p><p>The location of the attribute fork in the inode’s literal area is specified by
the <code class="literal">di_forkoff</code> value in the inode’s core. If this value is zero, the inode
does not contain any extended attributes.  If non-zero, the attribute fork’s
byte offset into the literal area can be computed from <code class="literal">di_forkoff × 8</code>.
Attributes must be allocated on a 64-bit boundary on the disk. To access the
extended attributes in code, use the <code class="literal">XFS_DFORK_PTR</code> macro specifying
<code class="literal">XFS_ATTR_FORK</code> for the “which” parameter.  Alternatively, the <code class="literal">XFS_DFORK_APTR</code>
macro can be used.</p><p>The structure of the attribute fork depends on the <code class="literal">di_aformat</code> value
in the inode. It can be one of the following values:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
<code class="literal">XFS_DINODE_FMT_LOCAL</code>: The extended attributes are contained entirely within
the inode. This is accessed by casting the value from <code class="literal">XFS_DFORK_APTR</code> to
<code class="literal">xfs_attr_shortform_t*</code>.
</li><li class="listitem">
<code class="literal">XFS_DINODE_FMT_EXTENTS</code>: The attributes are located in another filesystem
block, the inode contains an array of pointers to these filesystem blocks. They
are accessed by casting the value from <code class="literal">XFS_DFORK_APTR</code> to <code class="literal">xfs_bmbt_rec_t*</code>.
</li><li class="listitem">
<code class="literal">XFS_DINODE_FMT_BTREE</code>: The extents for the attributes are contained in the
leaves of a B+tree. The inode contains the root node of the tree and is accessed
by casting the value from <code class="literal">XFS_DFORK_APTR</code> to <code class="literal">xfs_bmdr_block_t*</code>.
</li></ul></div><p>Detailed information on the layouts of extended attributes are covered in the
<a class="link" href="#Extended_Attributes" title="Chapter 19. Extended Attributes">Extended Attributes</a> in this document.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="Extended_Attribute_Versions"></a>16.4.1. Extended Attribute Versions</h3></div></div></div><p>Extended attributes come in two versions: “attr1” or “attr2”. The attribute
version is specified by the <code class="literal">XFS_SB_VERSION2_ATTR2BIT</code>  flag in the
<code class="literal">sb_features2</code> field in the superblock. It determines how the inode’s extra
space is split between <code class="literal">di_u</code> and <code class="literal">di_a</code> forks which also determines how the
<code class="literal">di_forkoff</code> value is maintained in the inode’s core.</p><p>With “attr1” attributes, the <code class="literal">di_forkoff</code> is set to somewhere in the middle of
the space between the core and end of the inode and never changes (which has the
effect of artificially limiting the space for data information). As the data
fork grows, when it gets to <code class="literal">di_forkoff</code>, it will move the data to the next
format level (ie. local &lt; extent &lt; btree). If very little space is used
for either attributes or data, then a good portion of the available inode space
is wasted with this version.</p><p>“attr2” was introduced to maximum the utilisation of the inode’s literal area.
The <code class="literal">di_forkoff</code> starts at the end of the inode and works its way to the data
fork as attributes are added. Attr2 is highly recommended if extended attributes
are used.</p><p>The following diagram compares the two versions:</p><div class="figure"><a id="idm5522"></a><p class="title"><strong>Figure 16.3. Extended attribute layouts</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/30.png" alt="images/30.png" /></div></div></div><br class="figure-break" /><p>Note that because <code class="literal">di_forkoff</code> is an 8-bit value measuring units of 8 bytes,
the maximum size of an inode is 2<sup>8</sup> × 2<sup>3</sup> = 2<sup>11</sup> = 2048 bytes.</p></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Data_Extents"></a>Chapter 17. Data Extents</h2></div></div></div><p>XFS manages space using extents, which are defined as a starting location and
length.  A fork in an XFS inode maps a logical offset to a space extent.  This
enables a file’s extent map to support sparse files (i.e. “holes” in the file).
A flag is also used to specify if the extent has been preallocated but has not
yet been written (unwritten extent).</p><p>A file can have more than one extent if one chunk of contiguous disk space is
not available for the file. As a file grows, the XFS space allocator will
attempt to keep space contiguous and to merge extents. If more than one file is
being allocated space in the same AG at the same time, multiple extents for the
files will occur as the extent allocations interleave. The effect of this can
vary depending on the extent allocator used in the XFS driver.</p><p>An extent is 128 bits in size and uses the following packed layout:</p><div class="table"><a id="idm5539"></a><p class="title"><strong>Table 17.1. Extent record format</strong></p><div class="table-contents"><table class="table" summary="Extent record format" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /><col class="col_3" /><col class="col_4" /></colgroup><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>bit[127]</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>bits[73-126]</p></td><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>bits[21-72]</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>bits[0-20]</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>flag</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>logical file block offset</p></td><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p>absolute block number</p></td><td style="" align="left" valign="top"><p># of blocks</p></td></tr></tbody></table></div></div><br class="table-break" /><p>The extent is represented by the <code class="literal">xfs_bmbt_rec</code> structure which uses a big
endian format on-disk. In-core management of extents use the <code class="literal">xfs_bmbt_irec</code>
structure which is the unpacked version of <code class="literal">xfs_bmbt_rec</code>:</p><pre class="programlisting">struct xfs_bmbt_irec {
     xfs_fileoff_t             br_startoff;
     xfs_fsblock_t             br_startblock;
     xfs_filblks_t             br_blockcount;
     xfs_exntst_t              br_state;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>br_startoff</strong></span>
</span></dt><dd>
Logical block offset of this mapping.
</dd><dt><span class="term">
<span class="strong"><strong>br_startblock</strong></span>
</span></dt><dd>
Filesystem block of this mapping.
</dd><dt><span class="term">
<span class="strong"><strong>br_blockcount</strong></span>
</span></dt><dd>
The length of this mapping.
</dd><dt><span class="term">
<span class="strong"><strong>br_state</strong></span>
</span></dt><dd>
The extent <code class="literal">br_state</code> field uses the following enum declaration:
</dd></dl></div><pre class="programlisting">typedef enum {
     XFS_EXT_NORM,
     XFS_EXT_UNWRITTEN,
     XFS_EXT_INVALID
} xfs_exntst_t;</pre><p>Some other points about extents:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The <code class="literal">xfs_bmbt_rec_32_t</code> and <code class="literal">xfs_bmbt_rec_64_t</code> structures were effectively
the same as <code class="literal">xfs_bmbt_rec_t</code>, just different representations of the same 128
bits in on-disk big endian format.  <code class="literal">xfs_bmbt_rec_32_t</code> was removed and
<code class="literal">xfs_bmbt_rec_64_t</code> renamed to <code class="literal">xfs_bmbt_rec_t</code> some time ago.
</li><li class="listitem">
When a file is created and written to, XFS will endeavour to keep the extents
within the same AG as the inode. It may use a different AG if the AG is busy
or there is no space left in it.
</li><li class="listitem">
If a file is zero bytes long, it will have no extents and <code class="literal">di_nblocks</code> and
<code class="literal">di_nexents</code> will be zero. Any file with data will have at least one extent, and
each extent can use from 1 to over 2 million blocks (2<sup>21</sup>) on the filesystem.
For a default 4KB block size filesystem, a single extent can be up to 8GB in
length.
</li></ul></div><p>The following two subsections cover the two methods of storing extent
information for a file. The first is the fastest and simplest where the inode
completely contains an extent array to the file’s data. The second is slower and
more complex B+tree which can handle thousands to millions of extents
efficiently.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Extent_List"></a>17.1. Extent List</h2></div></div></div><p>If the entire extent list is short enough to fit within the inode’s fork
region, we say that the fork is in “extent list” format.  This is the most
optimal in terms of speed and resource consumption. The trade-off is the file
can only have a few extents before the inode runs out of space.</p><p>The data fork of the inode contains an array of extents; the size of the array
is determined by the inode’s <code class="literal">di_nextents</code> value.</p><div class="figure"><a id="idm5616"></a><p class="title"><strong>Figure 17.1. Inode data fork extent layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/32.png" alt="images/32.png" /></div></div></div><br class="figure-break" /><p>The number of extents that can fit in the inode depends on the inode size and
<code class="literal">di_forkoff</code>. For a default 256 byte inode with no extended attributes, a file
can have up to 9 extents with this format.  On a default v5 filesystem with 512
byte inodes, a file can have up to 21 extents with this format.  Beyond that,
extents have to use the B+tree format.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_inode_data_fork_extents_example"></a>17.1.1. xfs_db Inode Data Fork Extents Example</h3></div></div></div><p>An 8MB file with one extent:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
core.magic = 0x494e
core.mode = 0100644
core.version = 1
core.format = 2 (extents)
...
core.size = 8294400
core.nblocks = 2025
core.extsize = 0
core.nextents = 1
core.naextents = 0
core.forkoff = 0
...
u.bmx[0] = [startoff,startblock,blockcount,extentflag]
        0:[0,25356,2025,0]</pre><p>A 24MB file with three extents:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
...
core.format = 2 (extents)
...
core.size = 24883200
core.nblocks = 6075
core.nextents = 3
...
u.bmx[0-2] = [startoff,startblock,blockcount,extentflag]
        0:[0,27381,2025,0]
        1:[2025,31431,2025,0]
        2:[4050,35481,2025,0]</pre><p>Raw disk version of the inode with the third extent highlighted (<code class="literal">di_u</code>
starts at offset 0x64):</p><pre class="screen">xfs_db&gt; type text
xfs_db&gt; p
00: 49 4e 81 a4 01 02 00 01 00 00 00 00 00 00 00 00 IN..............
10: 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 01 ................
20: 44 b6 88 dd 2f 8a ed d0 44 b6 88 f7 10 8c 5b de D.......D.......
30: 44 b6 88 f7 10 8c 5b d0 00 00 00 00 01 7b b0 00 D...............
40: 00 00 00 00 00 00 17 bb 00 00 00 00 00 00 00 03 ................
50: 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 ................
60: ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00 0d ................
70: 5e a0 07 e9 00 00 00 00 00 0f d2 00 00 00 00 0f ................
80: 58 e0 07 e9 <span class="strong"><strong>00 00 00 00 00 1f a4 00 00 00 00 11 X...............
90: 53 20 07 e9</strong></span> 00 00 00 00 00 00 00 00 00 00 00 00 S...............
a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
be: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
co: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
do: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
e0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
fo: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</pre><p>We can expand the highlighted section into the following bit array from MSB to
LSB with the file offset and the block count highlighted:</p><pre class="screen">127-96:  0<span class="strong"><strong>000 0000 0000 0000  0000 0000 0000 0000</strong></span>
 95-64:  <span class="strong"><strong>0000 0000 0001 1111  1010 010</strong></span>0 0000 0000
 63-32:  0000 0000 0000 0000  0000 0000 0000 1111
 31-0 :  0101 1000 111<span class="strong"><strong>0 0000  0000 0111 1110 1001</strong></span>

Grouping by highlights we get:
   file offset = 0x0fd2 (4050)
   start block = 0x7ac7 (31431)
   block count = 0x07e9 (2025)</pre><p>A 4MB file with two extents and a hole in the middle, the first extent
containing 64KB of data, the second about 4MB in containing 32KB (<code class="literal">write</code> 64KB,
<code class="literal">lseek</code> 4MB, <code class="literal">write</code> 32KB operations):</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
...
core.format = 2 (extents)
...
core.size = 4063232
core.nblocks = 24
core.nextents = 2
...
u.bmx[0-1] = [startoff,startblock,blockcount,extentflag]
        0:[0,37506,16,0]
        1:[984,37522,8,0]</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Btree_Extent_List"></a>17.2. B+tree Extent List</h2></div></div></div><p>To manage extent maps that cannot fit in the inode fork area, XFS uses
<a class="link" href="#Long_Format_Btrees" title="10.2. Long Format B+trees">long format B+trees</a>.  The root node of the B+tree is
stored in the inode’s data fork.  All block pointers for extent B+trees are
64-bit filesystem block numbers.</p><p>For a single level B+tree, the root node points to the B+tree’s leaves. Each
leaf occupies one filesystem block and contains a header and an array of extents
sorted by the file’s offset. Each leaf has left and right (or backward and
forward) block pointers to adjacent leaves. For a standard 4KB filesystem block,
a leaf can contain up to 254 extents before a B+tree rebalance is triggered.</p><p>For a multi-level B+tree, the root node points to other B+tree nodes which
eventually point to the extent leaves.  B+tree keys are based on the file’s
offset and have pointers to the next level down.  Nodes at each level in the
B+tree also have pointers to the adjacent nodes.</p><p>The base B+tree node is used for extents, directories and extended attributes.
The structures used for an inode’s B+tree root are:</p><pre class="programlisting">struct xfs_bmdr_block {
     __be16                     bb_level;
     __be16                     bb_numrecs;
};
struct xfs_bmbt_key {
     xfs_fileoff_t              br_startoff;
};
typedef xfs_fsblock_t xfs_bmbt_ptr_t, xfs_bmdr_ptr_t;</pre><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
On disk, the B+tree node starts with the <code class="literal">xfs_bmdr_block_t</code> header followed by
an array of <code class="literal">xfs_bmbt_key_t</code> values and then an array of <code class="literal">xfs_bmbt_ptr_t</code>
values. The size of both arrays is specified by the header’s <code class="literal">bb_numrecs</code> value.
</li><li class="listitem">
The root node in the inode can only contain up to 9 key/pointer pairs for a
standard 256 byte inode before a new level of nodes is added between the root
and the leaves. This will be less if <code class="literal">di_forkoff</code> is not zero (i.e. attributes
are in use on the inode).
</li><li class="listitem">
The magic number for a BMBT block is “BMAP” (0x424d4150).  On a v5
filesystem, this is “BMA3” (0x424d4133).
</li><li class="listitem">
For intermediate nodes, the data following <code class="literal">xfs_btree_lblock</code> is the same as
the root node: array of <code class="literal">xfs_bmbt_key</code> value followed by an array of
<code class="literal">xfs_bmbt_ptr_t</code> values that starts halfway through the block (offset 0x808 for
a 4096 byte filesystem block).
</li><li class="listitem">
For leaves, an array of <code class="literal">xfs_bmbt_rec</code> extents follow the <code class="literal">xfs_btree_lblock</code>
header.
</li><li class="listitem">
Nodes and leaves use the same value for <code class="literal">bb_magic</code>.
</li><li class="listitem">
The <code class="literal">bb_level</code> value determines if the node is an intermediate node or a leaf.
Leaves have a <code class="literal">bb_level</code> of zero, nodes are one or greater.
</li><li class="listitem">
Intermediate nodes, like leaves, can contain up to 254 pointers to leaf blocks
for a standard 4KB filesystem block size as both the keys and pointers are 64
bits in size.
</li></ul></div><div class="figure"><a id="idm5683"></a><p class="title"><strong>Figure 17.2. Single level extent B+tree</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/35.png" alt="images/35.png" /></div></div></div><br class="figure-break" /><div class="figure"><a id="idm5690"></a><p class="title"><strong>Figure 17.3. Multiple level extent B+tree</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/36.png" alt="images/36.png" /></div></div></div><br class="figure-break" /><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_bmbt_example"></a>17.2.1. xfs_db bmbt Example</h3></div></div></div><p>In this example, we dissect the data fork of a VM image that is sufficiently
sparse and interleaved to have become a B+tree.</p><pre class="screen">xfs_db&gt; inode 132
xfs_db&gt; p
core.magic = 0x494e
core.mode = 0100600
core.version = 3
core.format = 3 (btree)
...
u3.bmbt.level = 1
u3.bmbt.numrecs = 3
u3.bmbt.keys[1-3] = [startoff] 1:[0] 2:[9072] 3:[13136]
u3.bmbt.ptrs[1-3] = 1:8568 2:8569 3:8570</pre><p>As you can see, the block map B+tree is rooted in the inode.  This tree has two
levels, so let’s go down a level to look at the records:</p><pre class="screen">xfs_db&gt; addr u3.bmbt.ptrs[1]
xfs_db&gt; p
magic = 0x424d4133
level = 0
numrecs = 251
leftsib = null
rightsib = 8569
bno = 68544
lsn = 0x100000006
uuid = 9579903c-333f-4673-a7d4-3254c05816ea
owner = 132
crc = 0xc61513dc (correct)
recs[1-251] = [startoff,startblock,blockcount,extentflag]
        1:[0,8520,48,0] 2:[48,4421,16,0] 3:[80,9136,16,0] 4:[96,8569,16,0]
        5:[144,8601,32,0] 6:[192,8637,16,0] 7:[240,8680,16,0] 8:[288,9870,16,0]
        9:[320,9920,16,0] 10:[336,9950,16,0] 11:[384,4004,32,0]
        12:[432,6771,16,0] 13:[480,2702,16,0] 14:[528,8420,16,0]
        ...</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Directories"></a>Chapter 18. Directories</h2></div></div></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>Only v2 directories covered here. v1 directories are obsolete.</p></div><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The term “block” in this section will refer to directory blocks, not filesystem
blocks unless otherwise specified.</p></div><p>The size of a “directory block” is defined by the <a class="link" href="#Superblocks" title="13.1. Superblocks">superblock’s</a>
<code class="literal">sb_dirblklog</code> value. The size in bytes = <code class="literal">sb_blocksize</code> × 2<sup>sb_dirblklog</sup>.
For example, if <code class="literal">sb_blocksize</code> = 4096 and <code class="literal">sb_dirblklog</code> = 2, the directory block
size is 16384 bytes. Directory blocks are always allocated in multiples based on
<code class="literal">sb_dirblklog</code>. Directory blocks cannot be more that 65536 bytes in size.</p><p>All directory entries contain the following “data”:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The entry’s name (counted string consisting of a single byte <code class="literal">namelen</code>
followed by <code class="literal">name</code> consisting of an array of 8-bit chars without a NULL
terminator).
</li><li class="listitem">
The entry’s absolute <a class="link" href="#Inode_Numbers" title="13.3.1. Inode Numbers">inode number</a>, which are
always 64 bits (8 bytes) in size except a special case for shortform
directories.
</li><li class="listitem">
An <code class="literal">offset</code> or <code class="literal">tag</code> used for iterative readdir calls.
</li><li class="listitem">
If the <code class="literal">XFS_SB_FEAT_INCOMPAT_FTYPE</code> feature flag is set, each
directory entry contains an <code class="literal">ftype</code> field that caches the inode’s type
to avoid having to perform an inode lookup.
</li></ul></div><div class="table"><a id="idm5734"></a><p class="title"><strong>Table 18.1. ftype values</strong></p><div class="table-contents"><table class="table" summary="ftype values" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_FT_UNKNOWN</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Entry points to an unknown inode type.  This should never appear on disk.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_FT_REG_FILE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Entry points to a file.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_FT_DIR</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Entry points to another directory.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_FT_CHRDEV</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Entry points to a character device.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_FT_BLKDEV</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Entry points to a block device.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_FT_FIFO</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Entry points to a FIFO.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_FT_SOCK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Entry points to a socket.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_FT_SYMLINK</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>Entry points to a symbolic link.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_DIR3_FT_WHT</code></p></td><td style="" align="left" valign="top"><p>Entry points to an overlayfs whiteout file.  This (as far as the author
knows) has never appeared on disk.</p></td></tr></tbody></table></div></div><br class="table-break" /><p>All non-shortform directories also contain two additional structures: “leaves”
and “freespace indexes”.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Leaves contain the sorted hashed name value (<code class="literal">xfs_da_hashname()</code> in
xfs_da_btree.c) and associated “address” which points to the effective offset
into the directory’s data structures. Leaves are used to optimise lookup
operations.
</li><li class="listitem">
Freespace indexes contain free space/empty entry tracking for quickly finding an
appropriately sized location for new entries. They maintain the largest free
space for each “data” block.
</li></ul></div><p>A few common types are used for the directory structures:</p><pre class="programlisting">typedef __uint16_t xfs_dir2_data_off_t;
typedef __uint32_t xfs_dir2_dataptr_t;</pre><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Shortform_Directories"></a>18.1. Short Form Directories</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Directory entries are stored within the inode.
</li><li class="listitem">
The only data stored is the name, inode number, and offset.  No “leaf” or
“freespace index” information is required as an inode can only store a few
entries.
</li><li class="listitem">
“.” is not stored (as it’s in the inode itself), and “..” is a dedicated
<code class="literal">parent</code> field in the header.
</li><li class="listitem">
The number of directories that can be stored in an inode depends on the
<a class="link" href="#On-disk_Inode" title="Chapter 16. On-disk Inode">inode</a> size, the number of entries, the length of the entry
names, and extended attribute data.
</li><li class="listitem">
Once the number of entries exceeds the space available in the inode, the
format is converted to a <a class="link" href="#Block_Directories" title="18.2. Block Directories">block directory</a>.
</li><li class="listitem">
Shortform directory data is packed as tightly as possible on the disk with the
remaining space zeroed:
</li></ul></div><pre class="programlisting">typedef struct xfs_dir2_sf {
     xfs_dir2_sf_hdr_t         hdr;
     xfs_dir2_sf_entry_t       list[1];
} xfs_dir2_sf_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>hdr</strong></span>
</span></dt><dd>
Short form directory header.
</dd><dt><span class="term">
<span class="strong"><strong>list</strong></span>
</span></dt><dd>
An array of variable-length directory entry records.
</dd></dl></div><pre class="programlisting">typedef struct xfs_dir2_sf_hdr {
     __uint8_t                 count;
     __uint8_t                 i8count;
     xfs_dir2_inou_t           parent;
} xfs_dir2_sf_hdr_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>count</strong></span>
</span></dt><dd>
Number of directory entries.
</dd><dt><span class="term">
<span class="strong"><strong>i8count</strong></span>
</span></dt><dd>
Number of directory entries requiring 64-bit entries, if any inode numbers
require 64-bits.  Zero otherwise.
</dd><dt><span class="term">
<span class="strong"><strong>parent</strong></span>
</span></dt><dd>
The absolute inode number of this directory’s parent.
</dd></dl></div><pre class="programlisting">typedef struct xfs_dir2_sf_entry {
     __uint8_t                 namelen;
     xfs_dir2_sf_off_t         offset;
     __uint8_t                 name[1];
     __uint8_t                 ftype;
     xfs_dir2_inou_t           inumber;
} xfs_dir2_sf_entry_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>namelen</strong></span>
</span></dt><dd>
Length of the name, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>offset</strong></span>
</span></dt><dd>
Offset tag used to assist with directory iteration.
</dd><dt><span class="term">
<span class="strong"><strong>name</strong></span>
</span></dt><dd>
The name of the directory entry.  The entry is not NULL-terminated.
</dd><dt><span class="term">
<span class="strong"><strong>ftype</strong></span>
</span></dt><dd>
The type of the inode.  This is used to avoid reading the inode while iterating
a directory.  The <code class="literal">XFS_SB_VERSION2_FTYPE</code> feature must be set, or this field
will not be present.
</dd><dt><span class="term">
<span class="strong"><strong>inumber</strong></span>
</span></dt><dd>
The inode number that this entry points to.  The length is either 32 or 64
bits, depending on whether <code class="literal">icount</code> or <code class="literal">i8count</code>, respectively, are set in the
header.
</dd></dl></div><div class="figure"><a id="idm5884"></a><p class="title"><strong>Figure 18.1. Short form directory layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/39.png" alt="images/39.png" /></div></div></div><br class="figure-break" /><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Inode numbers are stored using 4 or 8 bytes depending on whether all the inode
numbers for the directory fit in 4 bytes (32 bits) or not. If all inode numbers
fit in 4 bytes, the header’s <code class="literal">count</code> value specifies the number of entries in
the directory and <code class="literal">i8count</code> will be zero. If any inode number exceeds 4 bytes,
all inode numbers will be 8 bytes in size and the header’s <code class="literal">i8count</code> value
specifies the number of entries requiring larger inodes.  <code class="literal">i4count</code> is still
the number of entries.  The following union covers the shortform inode number
structure:
</li></ul></div><pre class="programlisting">typedef struct { __uint8_t i[8]; } xfs_dir2_ino8_t;
typedef struct { __uint8_t i[4]; } xfs_dir2_ino4_t;
typedef union {
     xfs_dir2_ino8_t           i8;
     xfs_dir2_ino4_t           i4;
} xfs_dir2_inou_t;</pre><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_short_form_directory_example"></a>18.1.1. xfs_db Short Form Directory Example</h3></div></div></div><p>A directory is created with 4 files, all inode numbers fitting within 4 bytes:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
core.magic = 0x494e
core.mode = 040755
core.version = 1
core.format = 1 (local)
core.nlinkv1 = 2
...
core.size = 94
core.nblocks = 0
core.extsize = 0
core.nextents = 0
...
u.sfdir2.hdr.count = 4
u.sfdir2.hdr.i8count = 0
u.sfdir2.hdr.parent.i4 = 128              /* parent = root inode */
u.sfdir2.list[0].namelen = 15
u.sfdir2.list[0].offset = 0x30
u.sfdir2.list[0].name = "frame000000.tst"
u.sfdir2.list[0].inumber.i4 = 25165953
u.sfdir2.list[1].namelen = 15
u.sfdir2.list[1].offset = 0x50
u.sfdir2.list[1].name = "frame000001.tst"
u.sfdir2.list[1].inumber.i4 = 25165954
u.sfdir2.list[2].namelen = 15
u.sfdir2.list[2].offset = 0x70
u.sfdir2.list[2].name = "frame000002.tst"
u.sfdir2.list[2].inumber.i4 = 25165955
u.sfdir2.list[3].namelen = 15
u.sfdir2.list[3].offset = 0x90
u.sfdir2.list[3].name = "frame000003.tst"
u.sfdir2.list[3].inumber.i4 = 25165956</pre><p>The raw data on disk with the first entry highlighted. The six byte header
precedes the first entry:</p><pre class="screen">xfs_db&gt; type text
xfs_db&gt; p
00: 49 4e 41 ed 01 01 00 02 00 00 00 00 00 00 00 00 INA.............
10: 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 02 ................
20: 44 ad 3a 83 1d a9 4a d0 44 ad 3a ab 0b c7 a7 d0 D.....J.D.......
30: 44 ad 3a ab 0b c7 a7 d0 00 00 00 00 00 00 00 5e D...............
40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
50: 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 ................
60: ff ff ff ff 04 00 00 00 00 80 <span class="strong"><strong>0f 00 30 66 72 61</strong></span> ............0fra
70: <span class="strong"><strong>6d 65 30 30 30 30 30 30 2e 74 73 74 01 80 00 81</strong></span> me000000.tst....
80: 0f 00 50 66 72 61 6d 65 30 30 30 30 30 31 2e 74 ..Pframe000001.t
90: 73 74 01 80 00 82 0f 00 70 66 72 61 6d 65 30 30 st......pframe00
a0: 30 30 30 32 2e 74 73 74 01 80 00 83 0f 00 90 66 0002.tst........
b0: 72 61 6d 65 30 30 30 30 30 33 2e 74 73 74 01 80 rame000003.tst..
cO: 00 84 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</pre><p>Next, an entry is deleted (frame000001.tst), and any entries after the deleted
entry are moved or compacted to “cover” the hole:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
core.magic = 0x494e
core.mode = 040755
core.version = 1
core.format = 1 (local)
core.nlinkv1 = 2
...
core.size = 72
core.nblocks = 0
core.extsize = 0
core.nextents = 0
...
u.sfdir2.hdr.count = 3
u.sfdir2.hdr.i8count = 0
u.sfdir2.hdr.parent.i4 = 128
u.sfdir2.list[0].namelen = 15
u.sfdir2.list[0].offset = 0x30
u.sfdir2.list[0].name = "frame000000.tst"
u.sfdir2.list[0].inumber.i4 = 25165953
u.sfdir2.list[1].namelen = 15
u.sfdir2.list[1].offset = 0x70
u.sfdir2.list[1].name = "frame000002.tst"
u.sfdir2.list[1].inumber.i4 = 25165955
u.sfdir2.list[2].namelen = 15
u.sfdir2.list[2].offset = 0x90
u.sfdir2.list[2].name = "frame000003.tst"
u.sfdir2.list[2].inumber.i4 = 25165956</pre><p>Raw disk data, the space beyond the shortform entries is invalid and could be non-zero:</p><pre class="screen">xfs_db&gt; type text
xfs_db&gt; p
00: 49  4e 41 ed 01 01 00 02 00 00 00 00 00 00 00 00 INA.............
10: 00  00 00 02 00 00 00 00 00 00 00 00 00 00 00 03 ................
20: 44  b2 45 a2 09 fd e4 50 44 b2 45 a3 12 ee b5 d0 D.E....PD.E.....
30: 44  b2 45 a3 12 ee b5 d0 00 00 00 00 00 00 00 48 D.E............H
40: 00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
50: 00  00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 ................
60: ff  ff ff ff 03 00 00 00 00 80 0f 00 30 66 72 61 ............0fra
70: 6d  65 30 30 30 30 30 30 2e 74 73 74 01 80 00 81 me000000.tst....
80: 0f  00 70 66 72 61 6d 65 30 30 30 30 30 32 2e 74 ..pframe000002.t
90: 73  74 01 80 00 83 0f 00 90 66 72 61 6d 65 30 30 st.......frame00
a0: 30  30 30 33 2e 74 73 74 01 80 00 84 0f 00 90 66 0003.tst.......f
b0: 72  61 6d 65 30 30 30 30 30 33 2e 74 73 74 01 80 rame000003.tst..
c0: 00  84 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</pre><p>This is an example of mixed 4-byte and 8-byte inodes in a directory:</p><pre class="screen">xfs_db&gt; inode 1024
xfs_db&gt; p
core.magic = 0x494e
core.mode = 040755
core.version = 3
core.format = 1 (local)
core.nlinkv2 = 9
...
core.size = 125
core.nblocks = 0
core.extsize = 0
core.nextents = 0
...
u3.sfdir3.hdr.count = 7
u3.sfdir3.hdr.i8count = 4
u3.sfdir3.hdr.parent.i8 = 1024
u3.sfdir3.list[0].namelen = 3
u3.sfdir3.list[0].offset = 0x60
u3.sfdir3.list[0].name = "git"
u3.sfdir3.list[0].inumber.i8 = 1027
u3.sfdir3.list[0].filetype = 2
u3.sfdir3.list[1].namelen = 4
u3.sfdir3.list[1].offset = 0x70
u3.sfdir3.list[1].name = "home"
u3.sfdir3.list[1].inumber.i8 = 13422826546
u3.sfdir3.list[1].filetype = 2
u3.sfdir3.list[2].namelen = 10
u3.sfdir3.list[2].offset = 0x80
u3.sfdir3.list[2].name = "mike"
u3.sfdir3.list[2].inumber.i8 = 4299308032
u3.sfdir3.list[2].filetype = 2
u3.sfdir3.list[3].namelen = 3
u3.sfdir3.list[3].offset = 0x98
u3.sfdir3.list[3].name = "mtr"
u3.sfdir3.list[3].inumber.i8 = 13433252916
u3.sfdir3.list[3].filetype = 2
u3.sfdir3.list[4].namelen = 3
u3.sfdir3.list[4].offset = 0xa8
u3.sfdir3.list[4].name = "vms"
u3.sfdir3.list[4].inumber.i8 = 16647516355
u3.sfdir3.list[4].filetype = 2
u3.sfdir3.list[5].namelen = 5
u3.sfdir3.list[5].offset = 0xb8
u3.sfdir3.list[5].name = "rsync"
u3.sfdir3.list[5].inumber.i8 = 3494912
u3.sfdir3.list[5].filetype = 2
u3.sfdir3.list[6].namelen = 3
u3.sfdir3.list[6].offset = 0xd0
u3.sfdir3.list[6].name = "tmp"
u3.sfdir3.list[6].inumber.i8 = 1593379
u3.sfdir3.list[6].filetype = 2</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Block_Directories"></a>18.2. Block Directories</h2></div></div></div><p>When the shortform directory space exceeds the space in an inode, the directory
data is moved into a new single directory block outside the inode. The inode’s
format is changed from “local” to “extent” Following is a list of points about
block directories.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
All directory data is stored within the one directory block, including “.” and
“..” entries which are mandatory.
</li><li class="listitem">
The block also contains “leaf” and “freespace index” information.
</li><li class="listitem">
The location of the block is defined by the inode’s in-core
<a class="link" href="#Extent_List" title="17.1. Extent List">extent list</a>: the <code class="literal">di_u.u_bmx[0]</code> value. The file offset in
the extent must always be zero and the <code class="literal">length</code> = (directory block size /
filesystem block size). The block number points to the filesystem block
containing the directory data.
</li><li class="listitem">
Block directory data is stored in the following structures:
</li></ul></div><pre class="programlisting">#define XFS_DIR2_DATA_FD_COUNT 3
typedef struct xfs_dir2_block {
     xfs_dir2_data_hdr_t        hdr;
     xfs_dir2_data_union_t      u[1];
     xfs_dir2_leaf_entry_t      leaf[1];
     xfs_dir2_block_tail_t      tail;
} xfs_dir2_block_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>hdr</strong></span>
</span></dt><dd>
Directory block header.  On a v5 filesystem this is <code class="literal">xfs_dir3_data_hdr_t</code>.
</dd><dt><span class="term">
<span class="strong"><strong>u</strong></span>
</span></dt><dd>
Union of directory and unused entries.
</dd><dt><span class="term">
<span class="strong"><strong>leaf</strong></span>
</span></dt><dd>
Hash values of the entries in this block.
</dd><dt><span class="term">
<span class="strong"><strong>tail</strong></span>
</span></dt><dd>
Bookkeeping for the leaf entries.
</dd></dl></div><pre class="programlisting">typedef struct xfs_dir2_data_hdr {
     __uint32_t                 magic;
     xfs_dir2_data_free_t       bestfree[XFS_DIR2_DATA_FD_COUNT];
} xfs_dir2_data_hdr_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>magic</strong></span>
</span></dt><dd>
Magic number for this directory block.
</dd><dt><span class="term">
<span class="strong"><strong>bestfree</strong></span>
</span></dt><dd>
An array pointing to free regions in the directory block.
</dd></dl></div><p>On a v5 filesystem, directory and attribute blocks are formatted with v3
headers, which contain extra data:</p><pre class="programlisting">struct xfs_dir3_blk_hdr {
     __be32                     magic;
     __be32                     crc;
     __be64                     blkno;
     __be64                     lsn;
     uuid_t                     uuid;
     __be64                     owner;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>magic</strong></span>
</span></dt><dd>
Magic number for this directory block.
</dd><dt><span class="term">
<span class="strong"><strong>crc</strong></span>
</span></dt><dd>
Checksum of the directory block.
</dd><dt><span class="term">
<span class="strong"><strong>blkno</strong></span>
</span></dt><dd>
Block number of this directory block.
</dd><dt><span class="term">
<span class="strong"><strong>lsn</strong></span>
</span></dt><dd>
Log sequence number of the last write to this block.
</dd><dt><span class="term">
<span class="strong"><strong>uuid</strong></span>
</span></dt><dd>
The UUID of this block, which must match either <code class="literal">sb_uuid</code> or <code class="literal">sb_meta_uuid</code>
depending on which features are set.
</dd><dt><span class="term">
<span class="strong"><strong>owner</strong></span>
</span></dt><dd>
The inode number that this directory block belongs to.
</dd></dl></div><pre class="programlisting">struct xfs_dir3_data_hdr {
     struct xfs_dir3_blk_hdr    hdr;
     xfs_dir2_data_free_t       best_free[XFS_DIR2_DATA_FD_COUNT];
     __be32                     pad;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>hdr</strong></span>
</span></dt><dd>
The v5 directory/attribute block header.
</dd><dt><span class="term">
<span class="strong"><strong>best_free</strong></span>
</span></dt><dd>
An array pointing to free regions in the directory block.
</dd><dt><span class="term">
<span class="strong"><strong>pad</strong></span>
</span></dt><dd>
Padding to maintain a 64-bit alignment.
</dd></dl></div><p>Within the block, data structures are as follows:</p><pre class="programlisting">typedef struct xfs_dir2_data_free {
     xfs_dir2_data_off_t        offset;
     xfs_dir2_data_off_t        length;
} xfs_dir2_data_free_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>offset</strong></span>
</span></dt><dd>
Block offset of a free block, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>length</strong></span>
</span></dt><dd>
Length of the free block, in bytes.
</dd></dl></div><p>Space inside the directory block can be used for directory entries or unused
entries.  This is signified via a union of the two types:</p><pre class="programlisting">typedef union {
     xfs_dir2_data_entry_t      entry;
     xfs_dir2_data_unused_t     unused;
} xfs_dir2_data_union_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>entry</strong></span>
</span></dt><dd>
A directory entry.
</dd><dt><span class="term">
<span class="strong"><strong>unused</strong></span>
</span></dt><dd>
An unused entry.
</dd></dl></div><pre class="programlisting">typedef struct xfs_dir2_data_entry {
     xfs_ino_t                  inumber;
     __uint8_t                  namelen;
     __uint8_t                  name[1];
     __uint8_t                  ftype;
     xfs_dir2_data_off_t        tag;
} xfs_dir2_data_entry_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>inumber</strong></span>
</span></dt><dd>
The inode number that this entry points to.
</dd><dt><span class="term">
<span class="strong"><strong>namelen</strong></span>
</span></dt><dd>
Length of the name, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>name</strong></span>
</span></dt><dd>
The name associated with this entry.
</dd><dt><span class="term">
<span class="strong"><strong>ftype</strong></span>
</span></dt><dd>
The type of the inode.  This is used to avoid reading the inode while iterating
a directory.  The <code class="literal">XFS_SB_VERSION2_FTYPE</code> feature must be set, or this field
will not be present.
</dd><dt><span class="term">
<span class="strong"><strong>tag</strong></span>
</span></dt><dd>
Starting offset of the entry, in bytes.  This is used for directory iteration.
</dd></dl></div><pre class="programlisting">typedef struct xfs_dir2_data_unused {
     __uint16_t                 freetag;  /* 0xffff */
     xfs_dir2_data_off_t        length;
     xfs_dir2_data_off_t        tag;
} xfs_dir2_data_unused_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>freetag</strong></span>
</span></dt><dd>
Magic number signifying that this is an unused entry.  Must be 0xFFFF.
</dd><dt><span class="term">
<span class="strong"><strong>length</strong></span>
</span></dt><dd>
Length of this unused entry, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>tag</strong></span>
</span></dt><dd>
Starting offset of the entry, in bytes.
</dd></dl></div><pre class="programlisting">typedef struct xfs_dir2_leaf_entry {
     xfs_dahash_t               hashval;
     xfs_dir2_dataptr_t         address;
} xfs_dir2_leaf_entry_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>hashval</strong></span>
</span></dt><dd>
Hash value of the name of the directory entry.  This is used to speed up entry
lookups.
</dd><dt><span class="term">
<span class="strong"><strong>address</strong></span>
</span></dt><dd>
Block offset of the entry, in eight byte units.
</dd></dl></div><pre class="programlisting">typedef struct xfs_dir2_block_tail {
     __uint32_t                 count;
     __uint32_t                 stale;
} xfs_dir2_block_tail_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>count</strong></span>
</span></dt><dd>
Number of leaf entries.
</dd><dt><span class="term">
<span class="strong"><strong>stale</strong></span>
</span></dt><dd>
Number of free leaf entries.
</dd></dl></div><p>Following is a diagram of how these pieces fit together for a block directory.</p><div class="figure"><a id="idm6111"></a><p class="title"><strong>Figure 18.2. Block directory layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/43.png" alt="images/43.png" /></div></div></div><br class="figure-break" /><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The magic number in the header is “XD2B” (0x58443242), or “XDB3” (0x58444233)
on a v5 filesystem.
</li><li class="listitem">
The <code class="literal">tag</code> in the <code class="literal">xfs_dir2_data_entry_t</code> structure stores its offset from the
start of the block.
</li><li class="listitem">
The start of a free space region is marked with the <code class="literal">xfs_dir2_data_unused_t</code>
structure where the <code class="literal">freetag</code> is <code class="literal">0xffff</code>. The <code class="literal">freetag</code> and <code class="literal">length</code> overwrites
the <code class="literal">inumber</code> for an entry. The <code class="literal">tag</code> is located at <code class="literal">length - sizeof(tag)</code> from
the start of the <code class="literal">unused</code> entry on-disk.
</li><li class="listitem">
The <code class="literal">bestfree</code> array in the header points to as many as three of the largest
spaces of free space within the block for storing new entries sorted by largest
to third largest. If there are less than 3 empty regions, the remaining
<code class="literal">bestfree</code> elements are zeroed. The <code class="literal">offset</code> specifies the offset from the start
of the block in bytes, and the <code class="literal">length</code> specifies the size of the free space in
bytes. The location each points to must contain the above
<code class="literal">xfs_dir2_data_unused_t</code> structure. As a block cannot exceed 64KB in size, each
is a 16-bit value. <code class="literal">bestfree</code> is used to optimise the time required to locate
space to create an entry. It saves scanning through the block to find a location
suitable for every entry created.
</li><li class="listitem">
The <code class="literal">tail</code> structure specifies the number of elements in the <code class="literal">leaf</code> array and
the number of <code class="literal">stale</code> entries in the array. The <code class="literal">tail</code> is always located at the
end of the block. The <code class="literal">leaf</code> data immediately precedes the <code class="literal">tail</code> structure.
</li><li class="listitem">
The <code class="literal">leaf</code> array, which grows from the end of the block just before the <code class="literal">tail</code>
structure, contains an array of hash/address pairs for quickly looking up a name
by a hash value. Hash values are covered by the introduction to directories. The
<code class="literal">address</code> on-disk is the offset into the block divided by 8
(<code class="literal">XFS_DIR2_DATA_ALIGN</code>). Hash/address pairs are stored on disk to optimise
lookup speed for large directories. If they were not stored, the hashes would
have to be calculated for all entries each time a lookup occurs in a directory.
</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_block_directory_example"></a>18.2.1. xfs_db Block Directory Example</h3></div></div></div><p>A directory is created with 8 entries, directory block size = filesystem block size:</p><pre class="screen">xfs_db&gt; sb 0
xfs_db&gt; p
magicnum = 0x58465342
blocksize = 4096
...
dirblklog = 0
...
xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
core.magic = 0x494e
core.mode = 040755
core.version = 1
core.format = 2 (extents)
core.nlinkv1 = 2
...
core.size = 4096
core.nblocks = 1
core.extsize = 0
core.nextents = 1
...
u.bmx[0] = [startoff,startblock,blockcount,extentflag] 0:[0,2097164,1,0]</pre><p>Go to the “startblock” and show the raw disk data:</p><pre class="screen">xfs_db&gt; dblock 0
xfs_db&gt; type text
xfs_db&gt; p
000: 58 44 32 42  01 30 0e 78 00 00 00 00 00 00 00 00 XD2B.0.x........
010: 00 00 00 00  02 00 00 80 01 2e 00 00 00 00 00 10 ................
020: 00 00 00 00  00 00 00 80 02 2e 2e 00 00 00 00 20 ................
030: 00 00 00 00  02 00 00 81 0f 66 72 61 6d 65 30 30 .........frame00
040: 30 30 30 30  2e 74 73 74 80 8e 59 00 00 00 00 30 0000.tst..Y....0
050: 00 00 00 00  02 00 00 82 0f 66 72 61 6d 65 30 30 .........frame00
060: 30 30 30 31  2e 74 73 74 d0 ca 5c 00 00 00 00 50 0001.tst.......P
070: 00 00 00 00  02 00 00 83 0f 66 72 61 6d 65 30 30 .........frame00
080: 30 30 30 32  2e 74 73 74 00 00 00 00 00 00 00 70 0002.tst.......p
090: 00 00 00 00  02 00 00 84 0f 66 72 61 6d 65 30 30 .........frame00
0a0: 30 30 30 33  2e 74 73 74 00 00 00 00 00 00 00 90 0003.tst........
0b0: 00 00 00 00  02 00 00 85 0f 66 72 61 6d 65 30 30 .........frame00
0c0: 30 30 30 34 2e 74 73 74 00 00 00 00 00 00 00 b0 0004.tst........
0d0: 00 00 00 00 02 00 00 86 0f 66 72 61 6d 65 30 30 .........frame00
0e0: 30 30 30 35 2e 74 73 74 00 00 00 00 00 00 00 d0 0005.tst........
0f0: 00 00 00 00 02 00 00 87 0f 66 72 61 6d 65 30 30 .........frame00
100: 30 30 30 36 2e 74 73 74 00 00 00 00 00 00 00 f0 0006.tst........
110: 00 00 00 00 02 00 00 88 0f 66 72 61 6d 65 30 30 .........frame00
120: 30 30 30 37 2e 74 73 74 00 00 00 00 00 00 01 10 0007.tst........
130: ff ff 0e 78 00 00 00 00 00 00 00 00 00 00 00 00 ...x............</pre><p>The “leaf” and “tail” structures are stored at the end of the block, so as the
directory grows, the middle is filled in:</p><pre class="screen">fa0: 00 00 00 00 00 00 01 30 00 00 00 2e 00 00 00 02 .......0........
fb0: 00 00 17 2e 00 00 00 04 83 a0 40 b4 00 00 00 0e ................
fc0: 93 a0 40 b4 00 00 00 12 a3 a0 40 b4 00 00 00 06 ................
fd0: b3 a0 40 b4 00 00 00 0a c3 a0 40 b4 00 00 00 1e ................
fe0: d3 a0 40 b4 00 00 00 22 e3 a0 40 b4 00 00 00 16 ................
ff0: f3 a0 40 b4 00 00 00 1a 00 00 00 0a 00 00 00 00 ................</pre><p>In a readable format:</p><pre class="screen">xfs_db&gt; type dir2
xfs_db&gt; p
bhdr.magic = 0x58443242
bhdr.bestfree[0].offset = 0x130
bhdr.bestfree[0].length = 0xe78
bhdr.bestfree[1].offset = 0
bhdr.bestfree[1].length = 0
bhdr.bestfree[2].offset = 0
bhdr.bestfree[2].length = 0
bu[0].inumber = 33554560
bu[0].namelen = 1
bu[0].name = "."
bu[0].tag = 0x10
bu[1].inumber = 128
bu[1].namelen = 2
bu[1].name = ".."
bu[1].tag = 0x20
bu[2].inumber = 33554561
bu[2].namelen = 15
bu[2].name = "frame000000.tst"
bu[2].tag = 0x30
bu[3].inumber = 33554562
bu[3].namelen = 15
bu[3].name = "frame000001.tst"
bu[3].tag = 0x50
...
bu[8].inumber = 33554567
bu[8].namelen = 15
bu[8].name = "frame000006.tst"
bu[8].tag = 0xf0
bu[9].inumber = 33554568
bu[9].namelen = 15
bu[9].name = "frame000007.tst"
bu[9].tag = 0x110
bu[10].freetag = 0xffff
bu[10].length = 0xe78
bu[10].tag = 0x130
bleaf[0].hashval = 0x2e
bleaf[0].address = 0x2
bleaf[1].hashval = 0x172e
bleaf[1].address = 0x4
bleaf[2].hashval = 0x83a040b4
bleaf[2].address = 0xe
...
bleaf[8].hashval = 0xe3a040b4
bleaf[8].address = 0x16
bleaf[9].hashval = 0xf3a040b4
bleaf[9].address = 0x1a
btail.count = 10
btail.stale = 0</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>For block directories, all xfs_db fields are preceded with “b”.</p></div><p>For a simple lookup example, the hash of frame000000.tst is 0xb3a040b4. Looking
up that value, we get an address of 0x6. Multiply that by 8, it becomes offset
0x30 and the inode at that point is 33554561.</p><p>When we remove an entry from the middle (frame000004.tst), we can see how the
freespace details are adjusted:</p><pre class="screen">bhdr.magic = 0x58443242
bhdr.bestfree[0].offset = 0x130
bhdr.bestfree[0].length = 0xe78
bhdr.bestfree[1].offset = 0xb0
bhdr.bestfree[1].length = 0x20
bhdr.bestfree[2].offset = 0
bhdr.bestfree[2].length = 0
...
bu[5].inumber = 33554564
bu[5].namelen = 15
bu[5].name = "frame000003.tst"
bu[5].tag = 0x90
bu[6].freetag = 0xffff
bu[6].length = 0x20
bu[6].tag = 0xb0
bu[7].inumber = 33554566
bu[7].namelen = 15
bu[7].name = "frame000005.tst"
bu[7].tag = 0xd0
...
bleaf[7].hashval = 0xd3a040b4
bleaf[7].address = 0x22
bleaf[8].hashval = 0xe3a040b4
bleaf[8].address = 0
bleaf[9].hashval = 0xf3a040b4
bleaf[9].address = 0x1a
btail.count = 10
btail.stale = 1</pre><p>A new “bestfree” value is added for the entry, the start of the entry is marked
as unused with 0xffff (which overwrites the inode number for an actual entry),
and the length of the space. The tag remains intact at the <code class="literal">offset+length -
sizeof(tag)</code>. The address for the hash is also cleared. The affected areas are
highlighted below:</p><pre class="screen">090: 00 00 00 00 02 00 00 84 0f 66 72 61 6d 65 30 30 ..........frame00
0a0: 30 30 30 33 2e 74 73 74 00 00 00 00 00 00 00 90 0003.tst.........
0b0: <span class="strong"><strong>ff ff 00 20</strong></span> 02 00 00 85 0f 66 72 61 6d 65 30 30 ..........frame00
0c0: 30 30 30 34 2e 74 73 74 00 00 00 00 <span class="strong"><strong>00 00 00 b0</strong></span> 0004.tst.........
0d0: 00 00 00 00 02 00 00 86 0f 66 72 61 6d 65 30 30 ..........frame00
0e0: 30 30 30 35 2e 74 73 74 00 00 00 00 00 00 00 0d 0005.tst.........
...
fb0: 00 00 17 2e 00 00 00 04 83 a0 40 b4 00 00 00 0e .................
fc0: 93 a0 40 b4 00 00 00 12 a3 a0 40 b4 00 00 00 06 .................
fd0: b3 a0 40 b4 00 00 00 0a c3 a0 40 b4 00 00 00 1e .................
fe0: d3 a0 40 b4 00 00 00 22 e3 a0 40 b4 <span class="strong"><strong>00 00 00 00</strong></span> .................
ff0: f3 a0 40 b4 00 00 00 1a 00 00 00 0a <span class="strong"><strong>00 00 00 01</strong></span> .................</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Leaf_Directories"></a>18.3. Leaf Directories</h2></div></div></div><p>Once a Block Directory has filled the block, the directory data is changed into
a new format. It still uses <a class="link" href="#Data_Extents" title="Chapter 17. Data Extents">extents</a> and the same basic
structures, but the “data” and “leaf” are split up into their own extents. The
“leaf” information only occupies one extent. As “leaf” information is more
compact than “data” information, more than one “data” extent is common.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
Block to Leaf conversions retain the existing block for the data entries and
allocate a new block for the leaf and freespace index information.
</li><li class="listitem">
As with all directories, data blocks must start at logical offset zero.
</li><li class="listitem">
The “leaf” block has a special offset defined by <code class="literal">XFS_DIR2_LEAF_OFFSET</code>.
Currently, this is 32GB and in the extent view, a block offset of
32GB / <code class="literal">sb_blocksize</code>. On a 4KB block filesystem, this is 0x800000 (8388608
decimal).
</li><li class="listitem">
Blocks with directory entries (“data” extents) have the magic number “X2D2”
(0x58443244), or “XDD3” (0x58444433) on a v5 filesystem.
</li><li class="listitem">
The “data” extents have a new header (no “leaf” data):
</li></ul></div><pre class="programlisting">typedef struct xfs_dir2_data {
     xfs_dir2_data_hdr_t       hdr;
     xfs_dir2_data_union_t     u[1];
} xfs_dir2_data_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>hdr</strong></span>
</span></dt><dd>
Data block header.  On a v5 filesystem, this field is <code class="literal">struct xfs_dir3_data_hdr</code>.
</dd><dt><span class="term">
<span class="strong"><strong>u</strong></span>
</span></dt><dd>
Union of directory and unused entries, exactly the same as in a block directory.
</dd></dl></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The “leaf” extent uses the following structures:
</li></ul></div><pre class="programlisting">typedef struct xfs_dir2_leaf {
     xfs_dir2_leaf_hdr_t       hdr;
     xfs_dir2_leaf_entry_t     ents[1];
     xfs_dir2_data_off_t       bests[1];
     xfs_dir2_leaf_tail_t      tail;
} xfs_dir2_leaf_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>hdr</strong></span>
</span></dt><dd>
Directory leaf header.  On a v5 filesystem this is <code class="literal">struct
xfs_dir3_leaf_hdr_t</code>.
</dd><dt><span class="term">
<span class="strong"><strong>ents</strong></span>
</span></dt><dd>
Hash values of the entries in this block.
</dd><dt><span class="term">
<span class="strong"><strong>bests</strong></span>
</span></dt><dd>
An array pointing to free regions in the directory block.
</dd><dt><span class="term">
<span class="strong"><strong>tail</strong></span>
</span></dt><dd>
Bookkeeping for the leaf entries.
</dd></dl></div><pre class="programlisting">typedef struct xfs_dir2_leaf_hdr {
     xfs_da_blkinfo_t          info;
     __uint16_t                count;
     __uint16_t                stale;
} xfs_dir2_leaf_hdr_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>info</strong></span>
</span></dt><dd>
Leaf btree block header.
</dd><dt><span class="term">
<span class="strong"><strong>count</strong></span>
</span></dt><dd>
Number of leaf entries.
</dd><dt><span class="term">
<span class="strong"><strong>stale</strong></span>
</span></dt><dd>
Number of stale/zeroed leaf entries.
</dd></dl></div><pre class="programlisting">struct xfs_dir3_leaf_hdr {
     struct xfs_da3_blkinfo    info;
     __uint16_t                count;
     __uint16_t                stale;
     __be32                    pad;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>info</strong></span>
</span></dt><dd>
Leaf B+tree block header.
</dd><dt><span class="term">
<span class="strong"><strong>count</strong></span>
</span></dt><dd>
Number of leaf entries.
</dd><dt><span class="term">
<span class="strong"><strong>stale</strong></span>
</span></dt><dd>
Number of stale/zeroed leaf entries.
</dd><dt><span class="term">
<span class="strong"><strong>pad</strong></span>
</span></dt><dd>
Padding to maintain alignment rules.
</dd></dl></div><pre class="programlisting">typedef struct xfs_dir2_leaf_tail {
     __uint32_t                bestcount;
} xfs_dir2_leaf_tail_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>bestcount</strong></span>
</span></dt><dd>
Number of best free entries.
</dd></dl></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The magic number of the leaf block is <code class="literal">XFS_DIR2_LEAF1_MAGIC</code> (0xd2f1); on a
v5 filesystem it is <code class="literal">XFS_DIR3_LEAF1_MAGIC</code> (0x3df1).
</li><li class="listitem">
The size of the <code class="literal">ents</code> array is specified by <code class="literal">hdr.count</code>.
</li><li class="listitem">
The size of the <code class="literal">bests</code> array is specified by the <code class="literal">tail.bestcount</code>, which is
also the number of “data” blocks for  the directory. The bests array maintains
each data block’s <code class="literal">bestfree[0].length</code> value.
</li></ul></div><div class="figure"><a id="idm6296"></a><p class="title"><strong>Figure 18.3. Leaf directory free entry detail</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/48.png" alt="images/48.png" /></div></div></div><br class="figure-break" /><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_leaf_directory_example"></a>18.3.1. xfs_db Leaf Directory Example</h3></div></div></div><p>For this example, a directory was created with 256 entries (frame000000.tst to
frame000255.tst).  Some files were deleted (frame00005*, frame00018* and
frame000240.tst) to show free list characteristics.</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
core.magic = 0x494e
core.mode = 040755
core.version = 1
core.format = 2 (extents)
core.nlinkv1 = 2
...
core.size = 12288
core.nblocks = 4
core.extsize = 0
core.nextents = 3
...
u.bmx[0-2] = [startoff,startblock,blockcount,extentflag]
          0:[0,4718604,1,0]
          1:[1,4718610,2,0]
          2:[8388608,4718605,1,0]</pre><p>As can be seen in this example, three blocks are used for “data” in two extents,
and the “leaf” extent has a logical offset of 8388608 blocks (32GB).</p><p>Examining the first block:</p><pre class="screen">xfs_db&gt; dblock 0
xfs_db&gt; type dir2
xfs_db&gt; p
dhdr.magic = 0x58443244
dhdr.bestfree[0].offset = 0x670
dhdr.bestfree[0].length = 0x140
dhdr.bestfree[1].offset = 0xff0
dhdr.bestfree[1].length = 0x10
dhdr.bestfree[2].offset = 0
dhdr.bestfree[2].length = 0
du[0].inumber = 75497600
du[0].namelen = 1
du[0].name = "."
du[0].tag = 0x10
du[1].inumber = 128
du[1].namelen = 2
du[1].name = ".."
du[1].tag = 0x20
du[2].inumber = 75497601
du[2].namelen = 15
du[2].name = "frame000000.tst"
du[2].tag = 0x30
du[3].inumber = 75497602
du[3].namelen = 15
du[3].name = "frame000001.tst"
du[3].tag = 0x50
...
du[51].inumber = 75497650
du[51].namelen = 15
du[51].name = "frame000049.tst"
du[51].tag = 0x650
du[52].freetag = 0xffff
du[52].length = 0x140
du[52].tag = 0x670
du[53].inumber = 75497661
du[53].namelen = 15
du[53].name = "frame000060.tst"
du[53].tag = 0x7b0
...
du[118].inumber = 75497758
du[118].namelen = 15
du[118].name = "frame000125.tst"
du[118].tag = 0xfd0
du[119].freetag = 0xffff
du[119].length = 0x10
du[119].tag = 0xff0</pre><div class="note" style="margin-left: 0; margin-right: 10%;"><h3 class="title">Note</h3><p>The xfs_db field output is preceded by a “d” for “data”.</p></div><p>The next “data” block:</p><pre class="screen">xfs_db&gt; dblock 1
xfs_db&gt; type dir2
xfs_db&gt; p
dhdr.magic = 0x58443244
dhdr.bestfree[0].offset = 0x6d0
dhdr.bestfree[0].length = 0x140
dhdr.bestfree[1].offset = 0xe50
dhdr.bestfree[1].length = 0x20
dhdr.bestfree[2].offset = 0xff0
dhdr.bestfree[2].length = 0x10
du[0].inumber = 75497759
du[0].namelen = 15
du[0].name = "frame000126.tst"
du[0].tag = 0x10
...
du[53].inumber = 75497844
du[53].namelen = 15
du[53].name = "frame000179.tst"
du[53].tag = 0x6b0
du[54].freetag = 0xffff
du[54].length = 0x140
du[54].tag = 0x6d0
du[55].inumber = 75497855
du[55].namelen = 15
du[55].name = "frame000190.tst"
du[55].tag = 0x810
...
du[104].inumber = 75497904
du[104].namelen = 15
du[104].name = "frame000239.tst"
du[104].tag = 0xe30
du[105].freetag = 0xffff
du[105].length = 0x20
du[105].tag = 0xe50
du[106].inumber = 75497906
du[106].namelen = 15
du[106].name = "frame000241.tst"
du[106].tag = 0xe70
...
du[117].inumber = 75497917
du[117].namelen = 15
du[117].name = "frame000252.tst"
du[117].tag = 0xfd0
du[118].freetag = 0xffff
du[118].length = 0x10
du[118].tag = 0xff0</pre><p>And the last data block:</p><pre class="screen">xfs_db&gt; dblock 2
xfs_db&gt; type dir2
xfs_db&gt; p
dhdr.magic = 0x58443244
dhdr.bestfree[0].offset = 0x70
dhdr.bestfree[0].length = 0xf90
dhdr.bestfree[1].offset = 0
dhdr.bestfree[1].length = 0
dhdr.bestfree[2].offset = 0
dhdr.bestfree[2].length = 0
du[0].inumber = 75497918
du[0].namelen = 15
du[0].name = "frame000253.tst"
du[0].tag = 0x10
du[1].inumber = 75497919
du[1].namelen = 15
du[1].name = "frame000254.tst"
du[1].tag = 0x30
du[2].inumber = 75497920
du[2].namelen = 15
du[2].name = "frame000255.tst"
du[2].tag = 0x50
du[3].freetag = 0xffff
du[3].length = 0xf90
du[3].tag = 0x70</pre><p>Examining the “leaf” block (with the fields preceded by an “l” for “leaf”):</p><pre class="screen">xfs_db&gt; dblock 8388608
xfs_db&gt; type dir2
xfs_db&gt; p
lhdr.info.forw = 0
lhdr.info.back = 0
lhdr.info.magic = 0xd2f1
lhdr.count = 258
lhdr.stale = 0
lbests[0-2] = 0:0x10 1:0x10 2:0xf90
lents[0].hashval = 0x2e
lents[0].address = 0x2
lents[1].hashval = 0x172e
lents[1].address = 0x4
lents[2].hashval = 0x23a04084
lents[2].address = 0x116
...
lents[257].hashval = 0xf3a048bc
lents[257].address = 0x366
ltail.bestcount = 3</pre><p>Note how the <code class="literal">lbests</code> array correspond with the <code class="literal">bestfree[0].length</code> values in
the “data” blocks:</p><pre class="screen">xfs_db&gt; dblock 0
xfs_db&gt; type dir2
xfs_db&gt; p
dhdr.magic = 0x58443244
dhdr.bestfree[0].offset = 0xff0
dhdr.bestfree[0].length = 0x10
...
xfs_db&gt; dblock 1
xfs_db&gt; type dir2
xfs_db&gt; p
dhdr.magic = 0x58443244
dhdr.bestfree[0].offset = 0xff0
dhdr.bestfree[0].length = 0x10
...
xfs_db&gt; dblock 2
xfs_db&gt; type dir2
xfs_db&gt; p
dhdr.magic = 0x58443244
dhdr.bestfree[0].offset = 0x70
dhdr.bestfree[0].length = 0xf90</pre><p>Now after the entries have been deleted:</p><pre class="screen">xfs_db&gt; dblock 8388608
xfs_db&gt; type dir2
xfs_db&gt; p
lhdr.info.forw = 0
lhdr.info.back = 0
lhdr.info.magic = 0xd2f1
lhdr.count = 258
lhdr.stale = 21
lbests[0-2] = 0:0x140 1:0x140 2:0xf90
lents[0].hashval = 0x2e
lents[0].address = 0x2
lents[1].hashval = 0x172e
lents[1].address = 0x4
lents[2].hashval = 0x23a04084
lents[2].address = 0x116
...</pre><p>As can be seen, the <code class="literal">lbests</code> values have been update to contain each
<code class="literal">hdr.bestfree[0].length</code> values. The leaf’s <code class="literal">hdr.stale</code> value has also been
updated to specify the number of stale entries in the array. The stale entries
have an address of zero.</p><p>TODO: Need an example for where new entries get inserted with several large free
spaces.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Node_Directories"></a>18.4. Node Directories</h2></div></div></div><p>When the “leaf” information fills a block, the extents undergo another
separation. All “freeindex” information moves into its own extent. Like Leaf
Directories, the “leaf” block maintained the best free space information for
each “data” block. This is not possible with more than one leaf.</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The “data” blocks stay the same as leaf directories.
</li><li class="listitem">
After the “freeindex” data moves to its own block, it is possible for the
leaf data to fit within a single leaf block.  This single leaf block has a
magic number of <code class="literal">XFS_DIR2_LEAFN_MAGIC</code> (0xd2ff) or on a v5 filesystem,
<code class="literal">XFS_DIR3_LEAFN_MAGIC</code> (0x3dff).
</li><li class="listitem">
The “leaf” blocks eventually change into a B+tree with the generic B+tree
header pointing to directory “leaves” as described in
<a class="link" href="#Leaf_Directories" title="18.3. Leaf Directories">Leaf Directories</a>. Blocks with leaf data still have the
<code class="literal">LEAFN_MAGIC</code> magic number as outlined above.  The top-level tree blocks are
called “nodes” and have a magic number of <code class="literal">XFS_DA_NODE_MAGIC</code> (0xfebe), or on
a v5 filesystem, <code class="literal">XFS_DA3_NODE_MAGIC</code> (0x3ebe).
</li><li class="listitem">
Distinguishing between a combined leaf/freeindex block (<code class="literal">LEAF1_MAGIC</code>), a
leaf-only block (<code class="literal">LEAFN_MAGIC</code>), and a btree node block (<code class="literal">NODE_MAGIC</code>) can only
be done by examining the magic number.
</li><li class="listitem">
The new “freeindex” block(s) only contains the bests for each data block.
</li><li class="listitem">
The freeindex block uses the following structures:
</li></ul></div><pre class="programlisting">typedef struct xfs_dir2_free_hdr {
     __uint32_t                magic;
     __int32_t                 firstdb;
     __int32_t                 nvalid;
     __int32_t                 nused;
} xfs_dir2_free_hdr_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>magic</strong></span>
</span></dt><dd>
The magic number of the free block, “XD2F” (0x0x58443246).
</dd><dt><span class="term">
<span class="strong"><strong>firstdb</strong></span>
</span></dt><dd>
The starting directory block number for the bests array.
</dd><dt><span class="term">
<span class="strong"><strong>nvalid</strong></span>
</span></dt><dd>
Number of valid elements in the bests array.  This number must
correspond with the number of directory blocks can fit under the inode
<code class="literal">di_size</code>.
</dd><dt><span class="term">
<span class="strong"><strong>nused</strong></span>
</span></dt><dd>
Number of used elements in the bests array.  This number must correspond
with the number of directory blocks actually mapped under the inode
<code class="literal">di_size</code>.
</dd></dl></div><pre class="programlisting">typedef struct xfs_dir2_free {
     xfs_dir2_free_hdr_t       hdr;
     xfs_dir2_data_off_t       bests[1];
} xfs_dir2_free_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>hdr</strong></span>
</span></dt><dd>
Free block header.
</dd><dt><span class="term">
<span class="strong"><strong>bests</strong></span>
</span></dt><dd>
An array specifying the best free counts in each directory data block.
</dd></dl></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
On a v5 filesystem, the freeindex block uses the following structures:
</li></ul></div><pre class="programlisting">struct xfs_dir3_free_hdr {
     struct xfs_dir3_blk_hdr   hdr;
     __int32_t                 firstdb;
     __int32_t                 nvalid;
     __int32_t                 nused;
     __int32_t                 pad;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>hdr</strong></span>
</span></dt><dd>
v3 directory block header.  The magic number is "XDF3" (0x0x58444633).
</dd><dt><span class="term">
<span class="strong"><strong>firstdb</strong></span>
</span></dt><dd>
The starting directory block number for the bests array.
</dd><dt><span class="term">
<span class="strong"><strong>nvalid</strong></span>
</span></dt><dd>
Number of valid elements in the bests array.  This number must
correspond with the number of directory blocks can fit under the inode
<code class="literal">di_size</code>.
</dd><dt><span class="term">
<span class="strong"><strong>nused</strong></span>
</span></dt><dd>
Number of used elements in the bests array.  This number must correspond
with the number of directory blocks actually mapped under the inode
<code class="literal">di_size</code>.
</dd><dt><span class="term">
<span class="strong"><strong>pad</strong></span>
</span></dt><dd>
Padding to maintain alignment.
</dd></dl></div><pre class="programlisting">struct xfs_dir3_free {
     xfs_dir3_free_hdr_t       hdr;
     __be16                    bests[1];
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>hdr</strong></span>
</span></dt><dd>
Free block header.
</dd><dt><span class="term">
<span class="strong"><strong>bests</strong></span>
</span></dt><dd>
An array specifying the best free counts in each directory data block.
</dd></dl></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The location of the leaf blocks can be in any order, the only way to determine
the appropriate is by the node block hash/before values. Given a hash to look up,
you read the node’s <code class="literal">btree</code> array and first <code class="literal">hashval</code> in the array that exceeds
the given hash and it can then be found in the block pointed to by the <code class="literal">before</code>
value.
</li></ul></div><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The freeindex’s <code class="literal">bests</code> array starts from the end of the block and grows to the
start of the block.
</li><li class="listitem">
When an data block becomes unused (ie. all entries in it have been deleted), the
block is freed, the data extents contain a hole, and the freeindex’s <code class="literal">hdr.nused</code>
value is decremented and the associated <code class="literal">bests[]</code> entry is set to 0xffff.
</li><li class="listitem">
As the first data block always contains “.” and “..”, it’s invalid for the
directory to have a hole at the start.
</li><li class="listitem">
The freeindex’s <code class="literal">hdr.nused</code> should always be the same as the number of
allocated data directory blocks containing name/inode data and will always be
less than or equal to <code class="literal">hdr.nvalid</code>.  The value of <code class="literal">hdr.nvalid</code> should be the same
as the index of the last data directory block plus one (i.e. when the last data
block is freed, <code class="literal">nused</code> and <code class="literal">nvalid</code> are decremented).
</li></ul></div><div class="figure"><a id="idm6457"></a><p class="title"><strong>Figure 18.4. Node directory layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/54.png" alt="images/54.png" /></div></div></div><br class="figure-break" /><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_node_directory_example"></a>18.4.1. xfs_db Node Directory Example</h3></div></div></div><p>With the node directory examples, we are using a filesystems with 4KB block
size, and a 16KB directory size. The directory has over 2000 entries:</p><pre class="screen">xfs_db&gt; sb 0
xfs_db&gt; p
magicnum = 0x58465342
blocksize = 4096
...
dirblklog = 2
...
xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
core.magic = 0x494e
core.mode = 040755
core.version = 1
core.format = 2 (extents)
...
core.size = 81920
core.nblocks = 36
core.extsize = 0
core.nextents = 8
...
u.bmx[0-7] = [startoff,startblock,blockcount,extentflag] 0:[0,7368,4,0]
1:[4,7408,4,0] 2:[8,7444,4,0] 3:[12,7480,4,0] 4:[16,7520,4,0]
5:[8388608,7396,4,0] 6:[8388612,7524,8,0] 7:[16777216,7516,4,0]</pre><p>As can already be observed, all extents are allocated is multiples of 4 blocks.</p><p>Blocks 0 to 19 (16+4-1) are used for directory data blocks. Looking at blocks
16-19, we can seen that it’s the same as the single-leaf format, except the
<code class="literal">length</code> values are a lot larger to accommodate the increased directory block
size:</p><pre class="screen">xfs_db&gt; dblock 16
xfs_db&gt; type dir2
xfs_db&gt; p
dhdr.magic = 0x58443244
dhdr.bestfree[0].offset = 0xb0
dhdr.bestfree[0].length = 0x3f50
dhdr.bestfree[1].offset = 0
dhdr.bestfree[1].length = 0
dhdr.bestfree[2].offset = 0
dhdr.bestfree[2].length = 0
du[0].inumber = 120224
du[0].namelen = 15
du[0].name = "frame002043.tst"
du[0].tag = 0x10
du[1].inumber = 120225
du[1].namelen = 15
du[1].name = "frame002044.tst"
du[1].tag = 0x30
du[2].inumber = 120226
du[2].namelen = 15
du[2].name = "frame002045.tst"
du[2].tag = 0x50
du[3].inumber = 120227
du[3].namelen = 15
du[3].name = "frame002046.tst"
du[3].tag = 0x70
du[4].inumber = 120228
du[4].namelen = 15
du[4].name = "frame002047.tst"
du[4].tag = 0x90
du[5].freetag = 0xffff
du[5].length = 0x3f50
du[5].tag = 0</pre><p>Next, the “node” block, the fields are preceded with <span class="emphasis"><em>n</em></span> for node blocks:</p><pre class="screen">xfs_db&gt; dblock 8388608
xfs_db&gt; type dir2
xfs_db&gt; p
nhdr.info.forw = 0
nhdr.info.back = 0
nhdr.info.magic = 0xfebe
nhdr.count = 2
nhdr.level = 1
nbtree[0-1] = [hashval,before] 0:[0xa3a440ac,8388616] 1:[0xf3a440bc,8388612]</pre><p>The two following leaf blocks were allocated as part of the directory’s
conversion to node format.  All hashes less than 0xa3a440ac are located at
directory offset 8,388,616, and hashes less than 0xf3a440bc are located at
directory offset 8,388,612.  Hashes greater or equal to 0xf3a440bc don’t exist
in this directory.</p><pre class="screen">xfs_db&gt; dblock 8388616
xfs_db&gt; type dir2
xfs_db&gt; p
lhdr.info.forw = 8388612
lhdr.info.back = 0
lhdr.info.magic = 0xd2ff
lhdr.count = 1023
lhdr.stale = 0
lents[0].hashval = 0x2e
lents[0].address = 0x2
lents[1].hashval = 0x172e
lents[1].address = 0x4
lents[2].hashval = 0x23a04084
lents[2].address = 0x116
...
lents[1021].hashval = 0xa3a440a4
lents[1021].address = 0x1fa2
lents[1022].hashval = 0xa3a440ac
lents[1022].address = 0x1fca
xfs_db&gt; dblock 8388612
xfs_db&gt; type dir2
xfs_db&gt; p
lhdr.info.forw = 0
lhdr.info.back = 8388616
lhdr.info.magic = 0xd2ff
lhdr.count = 1027
lhdr.stale = 0
lents[0].hashval = 0xa3a440b4
lents[0].address = 0x1f52
lents[1].hashval = 0xa3a440bc
lents[1].address = 0x1f7a
...
lents[1025].hashval = 0xf3a440b4
lents[1025].address = 0x1f66
lents[1026].hashval = 0xf3a440bc
lents[1026].address = 0x1f8e</pre><p>An example lookup using xfs_db:</p><pre class="screen">xfs_db&gt; hash frame001845.tst
0xf3a26094</pre><p>Doing a binary search through the array, we get address 0x1ce6, which is offset
0xe730. Each fsblock is 4KB in size (0x1000), so it will be offset 0x730 into
directory offset 14. From the extent map, this will be fsblock 7482:</p><pre class="screen">xfs_db&gt; fsblock 7482
xfs_db&gt; type text
xfs_db&gt; p
...
730: 00 00 00 00 00 01 d4 da 0f 66 72 61 6d 65 30 30 .........frame00
740: 31 38 34 35 2e 74 73 74 00 00 00 00 00 00 27 30 1845.tst.......0</pre><p>Looking at the freeindex information (fields with an <span class="emphasis"><em>f</em></span> tag):</p><pre class="screen">xfs_db&gt; fsblock 7516
xfs_db&gt; type dir2
xfs_db&gt; p
fhdr.magic = 0x58443246
fhdr.firstdb = 0
fhdr.nvalid = 5
fhdr.nused = 5
fbests[0-4] = 0:0x10 1:0x10 2:0x10 3:0x10 4:0x3f50</pre><p>Like the Leaf Directory, each of the <code class="literal">fbests</code> values correspond to each data
block’s <code class="literal">bestfree[0].length</code> value.</p><p>The <code class="literal">fbests</code> array is highlighted in a raw block dump:</p><pre class="screen">xfs_db&gt; type text
xfs_db&gt; p
000: 58 44 32 46 00 00 00 00 00 00 00 05 00 00 00 05 XD2F............
010: <span class="strong"><strong>00 10 00 10 00 10 00 10 3f 50</strong></span> 00 00 1f 01 ff ff .........P......</pre><p>TODO: Example with a hole in the middle</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Btree_Directories"></a>18.5. B+tree Directories</h2></div></div></div><p>When the extent map in an inode grows beyond the inode’s space, the inode format
is changed to a “btree”. The inode contains a filesystem block point to the
B+tree extent map for the directory’s blocks. The B+tree extents contain the
extent map for the “data”, “node”, “leaf”, and “freeindex” information as
described in Node Directories.</p><p>Refer to the previous section on B+tree <a class="link" href="#Btree_Extent_List" title="17.2. B+tree Extent List">Data Extents</a> for
more information on XFS B+tree extents.</p><p>The following properties apply to both node and B+tree directories:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
The node/leaf trees can be more than one level deep.
</li><li class="listitem">
More than one freeindex block may exist, but this will be quite rare. It would
required hundreds of thousand files with quite long file names (or millions with
shorter names) to get a second freeindex block.
</li></ul></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_b_tree_directory_example"></a>18.5.1. xfs_db B+tree Directory Example</h3></div></div></div><p>A directory has been created with 200,000 entries with each entry being 100
characters long. The filesystem block size and directory block size are 4KB:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
core.magic = 0x494e
core.mode = 040755
core.version = 1
core.format = 3 (btree)
...
core.size = 22757376
core.nblocks = 6145
core.extsize = 0
core.nextents = 234
core.naextents = 0
core.forkoff = 0
...
u.bmbt.level = 1
u.bmbt.numrecs = 1
u.bmbt.keys[1] = [startoff] 1:[0]
u.bmbt.ptrs[1] = 1:89
xfs_db&gt; fsblock 89
xfs_db&gt; type bmapbtd
xfs_db&gt; p
magic = 0x424d4150
level = 0
numrecs = 234
leftsib = null
rightsib = null
recs[1-234] = [startoff,startblock,blockcount,extentflag]
   1:[0,53,1,0] 2:[1,55,13,0] 3:[14,69,1,0] 4:[15,72,13,0]
   5:[28,86,2,0] 6:[30,90,21,0] 7:[51,112,1,0] 8:[52,114,11,0]
   ...
   125:[5177,902,15,0] 126:[5192,918,6,0] 127:[5198,524786,358,0]
   128:[8388608,54,1,0] 129:[8388609,70,2,0] 130:[8388611,85,1,0]
   ...
   229:[8389164,917,1,0] 230:[8389165,924,19,0] 231:[8389184,944,9,0]
   232:[16777216,68,1,0] 233:[16777217,7340114,1,0] 234:[16777218,5767362,1,0]</pre><p>We have 128 extents and a total of 5555 blocks being used to store name/inode
pairs. With only about 2000 values that can be stored in the freeindex block, 3
blocks have been allocated for this information. The <code class="literal">firstdb</code> field specifies
the starting directory block number for each array:</p><pre class="screen">xfs_db&gt; dblock 16777216
xfs_db&gt; type dir2
xfs_db&gt; p
fhdr.magic = 0x58443246
fhdr.firstdb = 0
fhdr.nvalid = 2040
fhdr.nused = 2040
fbests[0-2039] = ...
xfs_db&gt; dblock 16777217
xfs_db&gt; type dir2
xfs_db&gt; p
fhdr.magic = 0x58443246
fhdr.firstdb = 2040
fhdr.nvalid = 2040
fhdr.nused = 2040
fbests[0-2039] = ...
xfs_db&gt; dblock 16777218
xfs_db&gt; type dir2
xfs_db&gt; p
fhdr.magic = 0x58443246
fhdr.firstdb = 4080
fhdr.nvalid = 1476
fhdr.nused = 1476
fbests[0-1475] = ...</pre><p>Looking at the root node in the node block, it’s a pretty deep tree:</p><pre class="screen">xfs_db&gt; dblock 8388608
xfs_db&gt; type dir2
xfs_db&gt; p
nhdr.info.forw = 0
nhdr.info.back = 0
nhdr.info.magic = 0xfebe
nhdr.count = 2
nhdr.level = 2
nbtree[0-1] = [hashval,before] 0:[0x6bbf6f39,8389121] 1:[0xfbbf7f79,8389120]
xfs_db&gt; dblock 8389121
xfs_db&gt; type dir2
xfs_db&gt; p
nhdr.info.forw = 8389120
nhdr.info.back = 0
nhdr.info.magic = 0xfebe
nhdr.count = 263
nhdr.level = 1
nbtree[0-262] = ... 262:[0x6bbf6f39,8388928]
xfs_db&gt; dblock 8389120
xfs_db&gt; type dir2
xfs_db&gt; p
nhdr.info.forw = 0
nhdr.info.back = 8389121
nhdr.info.magic = 0xfebe
nhdr.count = 319
nhdr.level = 1
nbtree[0-318] = [hashval,before] 0:[0x70b14711,8388919] ...</pre><p>The leaves at each the end of a node always point to the end leaves in adjacent
nodes. Directory block 8388928 has a forward pointer to block 8388919 and block
8388919 has a previous pointer to block 8388928, as highlighted in the
following example:</p><pre class="screen">xfs_db&gt; dblock 8388928
xfs_db&gt; type dir2
xfs_db&gt; p
lhdr.info.forw = <span class="strong"><strong>8388919</strong></span>
lhdr.info.back = 8388937
lhdr.info.magic = 0xd2ff
...

xfs_db&gt; dblock 8388919
xfs_db&gt; type dir2
xfs_db&gt; p
lhdr.info.forw = 8388706
lhdr.info.back = <span class="strong"><strong>8388928</strong></span>
lhdr.info.magic = 0xd2ff
...</pre></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Extended_Attributes"></a>Chapter 19. Extended Attributes</h2></div></div></div><p>Extended attributes enable users and administrators to attach (name: value)
pairs to inodes within the XFS filesystem. They could be used to store
meta-information about the file.</p><p>Attribute names can be up to 256 bytes in length, terminated by the first 0
byte. The intent is that they be printable ASCII (or other character set) names
for the attribute. The values can contain up to 64KB of arbitrary binary data.
Some XFS internal attributes (eg. parent pointers) use non-printable names for
the attribute.</p><p>Access Control Lists (ACLs) and Data Migration Facility (DMF) use extended
attributes to store their associated metadata with an inode.</p><p>XFS uses two disjoint attribute name spaces associated with every inode. These
are the root and user address spaces. The root address space is accessible only
to the superuser, and then only by specifying a flag argument to the function
call. Other users will not see or be able to modify attributes in the root
address space. The user address space is protected by the normal file
permissions mechanism, so the owner of the file can decide who is able to see
and/or modify the value of attributes on any particular file.</p><p>To view extended attributes from the command line, use the <code class="literal">getfattr</code> command.
To set or delete extended attributes, use the <code class="literal">setfattr</code> command. ACLs control
should use the <code class="literal">getfacl</code> and <code class="literal">setfacl</code> commands.</p><p>XFS attributes supports three namespaces: “user”, “trusted” (or “root” using
IRIX terminology), and “secure”.</p><p>See the section about <a class="link" href="#Extended_Attribute_Versions" title="16.4.1. Extended Attribute Versions">extended attributes</a> in
the inode for instructions on how to calculate the location of the attributes.</p><p>The following four sections describe each of the on-disk formats.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Shortform_Attributes"></a>19.1. Short Form Attributes</h2></div></div></div><p>When the all extended attributes can fit within the inode’s attribute fork, the
inode’s <code class="literal">di_aformat</code> is set to “local” and the attributes are stored in the
inode’s literal area starting at offset <code class="literal">di_forkoff × 8</code>.</p><p>Shortform attributes use the following structures:</p><pre class="programlisting">typedef struct xfs_attr_shortform {
     struct xfs_attr_sf_hdr {
           __be16               totsize;
           __u8                 count;
     } hdr;
     struct xfs_attr_sf_entry {
           __uint8_t            namelen;
           __uint8_t            valuelen;
           __uint8_t            flags;
           __uint8_t            nameval[1];
     } list[1];
} xfs_attr_shortform_t;
typedef struct xfs_attr_sf_hdr xfs_attr_sf_hdr_t;
typedef struct xfs_attr_sf_entry xfs_attr_sf_entry_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>totsize</strong></span>
</span></dt><dd>
Total size of the attribute structure in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>count</strong></span>
</span></dt><dd>
The number of entries that can be found in this structure.
</dd><dt><span class="term">
<span class="strong"><strong>namelen</strong></span> and <span class="strong"><strong>valuelen</strong></span>
</span></dt><dd>
These values specify the size of the two byte arrays containing the name and
value pairs. <code class="literal">valuelen</code> is zero for extended attributes with no value.
</dd><dt><span class="term">
<span class="strong"><strong>nameval[]</strong></span>
</span></dt><dd>
A single array whose size is the sum of <code class="literal">namelen</code> and <code class="literal">valuelen</code>. The names and
values are not null terminated on-disk. The value immediately follows the name
in the array.
</dd><dt><span class="term">
<span class="strong"><strong>flags</strong></span>
</span></dt><dd>
A combination of the following:
</dd></dl></div><div class="table"><a id="Attribute_Flags"></a><p class="title"><strong>Table 19.1. Attribute Namespaces</strong></p><div class="table-contents"><table class="table" summary="Attribute Namespaces" cellpadding="4px" style="border-collapse: collapse;border-top: 3px solid #527bbd; border-bottom: 3px solid #527bbd; border-left: 3px solid #527bbd; border-right: 3px solid #527bbd; "><colgroup><col class="col_1" /><col class="col_2" /></colgroup><thead><tr><th style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"> Flag                          </th><th style="border-bottom: 1px solid #527bbd; " align="left" valign="top"> Description</th></tr></thead><tbody><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>0</p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The attribute’s namespace is “user”.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ATTR_ROOT</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The attribute’s namespace is “trusted”.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ATTR_SECURE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>The attribute’s namespace is “secure”.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; border-bottom: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ATTR_INCOMPLETE</code></p></td><td style="border-bottom: 1px solid #527bbd; " align="left" valign="top"><p>This attribute is being modified.</p></td></tr><tr><td style="border-right: 1px solid #527bbd; " align="left" valign="top"><p><code class="literal">XFS_ATTR_LOCAL</code></p></td><td style="" align="left" valign="top"><p>The attribute value is contained within this block.</p></td></tr></tbody></table></div></div><br class="table-break" /><div class="figure"><a id="idm6607"></a><p class="title"><strong>Figure 19.1. Short form attribute layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/64.png" alt="images/64.png" /></div></div></div><br class="figure-break" /><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_short_form_attribute_example"></a>19.1.1. xfs_db Short Form Attribute Example</h3></div></div></div><p>A file is created and two attributes are set:</p><pre class="screen"># setfattr -n user.empty few_attr
# setfattr -n trusted.trust -v val1 few_attr</pre><p>Using xfs_db, we dump the inode:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
core.magic = 0x494e
core.mode = 0100644
...
core.naextents = 0
core.forkoff = 15
core.aformat = 1 (local)
...
a.sfattr.hdr.totsize = 24
a.sfattr.hdr.count = 2
a.sfattr.list[0].namelen = 5
a.sfattr.list[0].valuelen = 0
a.sfattr.list[0].root = 0
a.sfattr.list[0].secure = 0
a.sfattr.list[0].name = "empty"
a.sfattr.list[1].namelen = 5
a.sfattr.list[1].valuelen = 4
a.sfattr.list[1].root = 1
a.sfattr.list[1].secure = 0
a.sfattr.list[1].name = "trust"
a.sfattr.list[1].value = "val1"</pre><p>We can determine the actual inode offset to be 220 (15 x 8 + 100) or <code class="literal">0xdc</code>.
Examining the raw dump, the second attribute is highlighted:</p><pre class="screen">xfs_db&gt; type text
xfs_db&gt; p
09: 49 4e 81 a4 01 02 00 01 00 00 00 00 00 00 00 00 IN..............
10: 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 02 ................
20: 44 be 19 be 38 d1 26 98 44 be 1a be 38 d1 26 98 D...8...D...8...
30: 44 be 1a e1 3a 9a ea 18 00 00 00 00 00 00 00 04 D...............
40: 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 01 ................
50: 00 00 0f 01 00 00 00 00 00 00 00 00 00 00 00 00 ................
60: ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00 12 ................
70: 53 a0 00 01 00 00 00 00 00 00 00 00 00 00 00 00 ................
80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
d0: 00 00 00 00 00 00 00 00 00 00 00 00 <span class="strong"><strong>00 18</strong></span> 02 00 ................   &lt;-- hdr.totsize = 0x18
e0: 05 00 00 65 6d 70 74 79 <span class="strong"><strong>05 04 02 74 72 75 73 74</strong></span> ...empty...trust
f0: <span class="strong"><strong>76 61 6c 31</strong></span> 00 00 00 00 00 00 00 00 00 00 00 00 val1............</pre><p>Adding another attribute with attr1, the format is converted to extents and
<code class="literal">di_forkoff</code> remains unchanged (and all those zeros in the dump above remain
unused):</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
...
core.naextents = 1
core.forkoff = 15
core.aformat = 2 (extents)
...
a.bmx[0] = [startoff,startblock,blockcount,extentflag] 0:[0,37534,1,0]</pre><p>Performing the same steps with attr2, adding one attribute at a time, you can
see <code class="literal">di_forkoff</code> change as attributes are added:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
...
core.naextents = 0
core.forkoff = 15
core.aformat = 1 (local)
...
a.sfattr.hdr.totsize = 17
a.sfattr.hdr.count = 1
a.sfattr.list[0].namelen = 10
a.sfattr.list[0].valuelen = 0
a.sfattr.list[0].root = 0
a.sfattr.list[0].secure = 0
a.sfattr.list[0].name = "empty_attr"</pre><p>Attribute added:</p><pre class="screen">xfs_db&gt; p
...
core.naextents = 0
core.forkoff = 15
core.aformat = 1 (local)
...
a.sfattr.hdr.totsize = 31
a.sfattr.hdr.count = 2
a.sfattr.list[0].namelen = 10
a.sfattr.list[0].valuelen = 0
a.sfattr.list[0].root = 0
a.sfattr.list[0].secure = 0
a.sfattr.list[0].name = "empty_attr"
a.sfattr.list[1].namelen = 7
a.sfattr.list[1].valuelen = 4
a.sfattr.list[1].root = 1
a.sfattr.list[1].secure = 0
a.sfattr.list[1].name = "trust_a"
a.sfattr.list[1].value = "val1"</pre><p>Another attribute is added:</p><pre class="screen">xfs_db&gt; p
...
core.naextents = 0
<span class="strong"><strong>core.forkoff = 13</strong></span>
core.aformat = 1 (local)
...
a.sfattr.hdr.totsize = 52
a.sfattr.hdr.count = 3
a.sfattr.list[0].namelen = 10
a.sfattr.list[0].valuelen = 0
a.sfattr.list[0].root = 0
a.sfattr.list[0].secure = 0
a.sfattr.list[0].name = "empty_attr"
a.sfattr.list[1].namelen = 7
a.sfattr.list[1].valuelen = 4
a.sfattr.list[1].root = 1
a.sfattr.list[1].secure = 0
a.sfattr.list[1].name = "trust_a"
a.sfattr.list[1].value = "val1"
a.sfattr.list[2].namelen = 6
a.sfattr.list[2].valuelen = 12
a.sfattr.list[2].root = 0
a.sfattr.list[2].secure = 0
a.sfattr.list[2].name = "second"
a.sfattr.list[2].value = "second_value"</pre><p>One more is added:</p><pre class="screen">xfs_db&gt; p
core.naextents = 0
core.forkoff = 10
core.aformat = 1 (local)
...
a.sfattr.hdr.totsize = 69
a.sfattr.hdr.count = 4
a.sfattr.list[0].namelen = 10
a.sfattr.list[0].valuelen = 0
a.sfattr.list[0].root = 0
a.sfattr.list[0].secure = 0
a.sfattr.list[0].name = "empty_attr"
a.sfattr.list[1].namelen = 7
a.sfattr.list[1].valuelen = 4
a.sfattr.list[1].root = 1
a.sfattr.list[1].secure = 0
a.sfattr.list[1].name = "trust_a"
a.sfattr.list[1].value = "val1"
a.sfattr.list[2].namelen = 6
a.sfattr.list[2].valuelen = 12
a.sfattr.list[2].root = 0
a.sfattr.list[2].secure = 0
a.sfattr.list[2].name = "second"
a.sfattr.list[2].value = "second_value"
a.sfattr.list[3].namelen = 6
a.sfattr.list[3].valuelen = 8
a.sfattr.list[3].root = 0
a.sfattr.list[3].secure = 1
a.sfattr.list[3].name = "policy"
a.sfattr.list[3].value = "contents"</pre><p>A raw dump is shown to compare with the attr1 dump on a prior page, the header
is highlighted:</p><pre class="screen">xfs_db&gt; type text
xfs_db&gt; p
00: 49 4e 81 a4 01 02 00 01 00 00 00 00 00 00 00 00 IN..............
10: 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 05 ................
20: 44 be 24 cd 0f b0 96 18 44 be 24 cd 0f b0 96 18 D.......D.......
30: 44 be 2d f5 01 62 7a 18 00 00 00 00 00 00 00 04 D....bz.........
40: 00 00 00 00 00 00 00 01 00 00 00 00 00 00 00 01 ................
50: 00 00 0a 01 00 00 00 00 00 00 00 00 00 00 00 00 ................
60: ff ff ff ff 00 00 00 00 00 00 00 00 00 00 00 01 ................
70: 41 c0 00 01 00 00 00 00 00 00 00 00 00 00 00 00 A...............
80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
90: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
b0: 00 00 00 00 <span class="strong"><strong>00 45 04 00</strong></span> 0a 00 00 65 6d 70 74 79 .....E.....empty
c0: 5f 61 74 74 72 07 04 02 74 72 75 73 74 5f 61 76 .attr...trust.av
d0: 61 6c 31 06 0c 00 73 65 63 6f 6e 64 73 65 63 6f all...secondseco
e0: 6e 64 5f 76 61 6c 75 65 06 08 04 70 6f 6c 69 63 nd.value...polic
f0: 79 63 6f 6e 74 65 6e 74 73 64 5f 76 61 6c 75 65 ycontentsd.value</pre><p>It can be clearly seen that attr2 allows many more attributes to be stored in
an inode before they are moved to another filesystem block.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Leaf_Attributes"></a>19.2. Leaf Attributes</h2></div></div></div><p>When an inode’s attribute fork space is used up with shortform attributes and
more are added, the attribute format is migrated to “extents”.</p><p>Extent based attributes use hash/index pairs to speed up an attribute lookup.
The first part of the “leaf” contains an array of fixed size hash/index pairs
with the flags stored as well. The remaining part of the leaf block contains the
array name/value pairs, where each element varies in length.</p><p>Each leaf is based on the <code class="literal">xfs_da_blkinfo_t</code> block header declared in the
section about <a class="link" href="#Directory_Attribute_Block_Header" title="11.1. Block Headers">directories</a>.  On a v5
filesystem, the block header is <code class="literal">xfs_da3_blkinfo_t</code>.  The structure
encapsulating all other structures in the attribute block is
<code class="literal">xfs_attr_leafblock_t</code>.</p><p>The structures involved are:</p><pre class="programlisting">typedef struct xfs_attr_leaf_map {
     __be16                     base;
     __be16                     size;
} xfs_attr_leaf_map_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>base</strong></span>
</span></dt><dd>
Block offset of the free area, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>size</strong></span>
</span></dt><dd>
Size of the free area, in bytes.
</dd></dl></div><pre class="programlisting">typedef struct xfs_attr_leaf_hdr {
     xfs_da_blkinfo_t           info;
     __be16                     count;
     __be16                     usedbytes;
     __be16                     firstused;
     __u8                       holes;
     __u8                       pad1;
     xfs_attr_leaf_map_t        freemap[3];
} xfs_attr_leaf_hdr_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>info</strong></span>
</span></dt><dd>
Directory/attribute block header.
</dd><dt><span class="term">
<span class="strong"><strong>count</strong></span>
</span></dt><dd>
Number of entries.
</dd><dt><span class="term">
<span class="strong"><strong>usedbytes</strong></span>
</span></dt><dd>
Number of bytes used in the leaf block.
</dd><dt><span class="term">
<span class="strong"><strong>firstused</strong></span>
</span></dt><dd>
Block offset of the first entry in use, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>holes</strong></span>
</span></dt><dd>
Set to 1 if block compaction is necessary.
</dd><dt><span class="term">
<span class="strong"><strong>pad1</strong></span>
</span></dt><dd>
Padding to maintain alignment to 64-bit boundaries.
</dd></dl></div><pre class="programlisting">typedef struct xfs_attr_leaf_entry {
     __be32                     hashval;
     __be16                     nameidx;
     __u8                       flags;
     __u8                       pad2;
} xfs_attr_leaf_entry_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>hashval</strong></span>
</span></dt><dd>
Hash value of the attribute name.
</dd><dt><span class="term">
<span class="strong"><strong>nameidx</strong></span>
</span></dt><dd>
Block offset of the name entry, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>flags</strong></span>
</span></dt><dd>
Attribute flags, as specified <a class="link" href="#Attribute_Flags" title="Table 19.1. Attribute Namespaces">above</a>.
</dd><dt><span class="term">
<span class="strong"><strong>pad2</strong></span>
</span></dt><dd>
Pads the structure to 64-bit boundaries.
</dd></dl></div><pre class="programlisting">typedef struct xfs_attr_leaf_name_local {
     __be16                     valuelen;
     __u8                       namelen;
     __u8                       nameval[1];
} xfs_attr_leaf_name_local_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>valuelen</strong></span>
</span></dt><dd>
Length of the value, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>namelen</strong></span>
</span></dt><dd>
Length of the name, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>nameval</strong></span>
</span></dt><dd>
The name and the value.  String values are not zero-terminated.
</dd></dl></div><pre class="programlisting">typedef struct xfs_attr_leaf_name_remote {
     __be32                     valueblk;
     __be32                     valuelen;
     __u8                       namelen;
     __u8                       name[1];
} xfs_attr_leaf_name_remote_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>valueblk</strong></span>
</span></dt><dd>
The logical block in the attribute map where the value is located.
</dd><dt><span class="term">
<span class="strong"><strong>valuelen</strong></span>
</span></dt><dd>
Length of the value, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>namelen</strong></span>
</span></dt><dd>
Length of the name, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>nameval</strong></span>
</span></dt><dd>
The name.  String values are not zero-terminated.
</dd></dl></div><pre class="programlisting">typedef struct xfs_attr_leafblock  {
     xfs_attr_leaf_hdr_t           hdr;
     xfs_attr_leaf_entry_t         entries[1];
     xfs_attr_leaf_name_local_t    namelist;
     xfs_attr_leaf_name_remote_t   valuelist;
} xfs_attr_leafblock_t;</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>hdr</strong></span>
</span></dt><dd>
Attribute block header.
</dd><dt><span class="term">
<span class="strong"><strong>entries</strong></span>
</span></dt><dd>
A variable-length array of attribute entries.
</dd><dt><span class="term">
<span class="strong"><strong>namelist</strong></span>
</span></dt><dd>
A variable-length array of descriptors of local attributes.  The location and
size of these entries is determined dynamically.
</dd><dt><span class="term">
<span class="strong"><strong>valuelist</strong></span>
</span></dt><dd>
A variable-length array of descriptors of remote attributes.  The location and
size of these entries is determined dynamically.
</dd></dl></div><p>On a v5 filesystem, the header becomes <code class="literal">xfs_da3_blkinfo_t</code> to accommodate the
extra metadata integrity fields:</p><pre class="programlisting">typedef struct xfs_attr3_leaf_hdr {
     xfs_da3_blkinfo_t          info;
     __be16                     count;
     __be16                     usedbytes;
     __be16                     firstused;
     __u8                       holes;
     __u8                       pad1;
     xfs_attr_leaf_map_t        freemap[3];
     __be32                     pad2;
} xfs_attr3_leaf_hdr_t;


typedef struct xfs_attr3_leafblock  {
     xfs_attr3_leaf_hdr_t          hdr;
     xfs_attr_leaf_entry_t         entries[1];
     xfs_attr_leaf_name_local_t    namelist;
     xfs_attr_leaf_name_remote_t   valuelist;
} xfs_attr3_leafblock_t;</pre><p>Each leaf header uses the magic number <code class="literal">XFS_ATTR_LEAF_MAGIC</code> (0xfbee).  On a
v5 filesystem, the magic number is <code class="literal">XFS_ATTR3_LEAF_MAGIC</code> (0x3bee).</p><p>The hash/index elements in the <code class="literal">entries[]</code> array are packed from the top of the
block. Name/values grow from the bottom but are not packed. The freemap contains
run-length-encoded entries for the free bytes after the <code class="literal">entries[]</code> array, but
only the three largest runs are stored (smaller runs are dropped). When the
<code class="literal">freemap</code> doesn’t show enough space for an allocation, the name/value area is
compacted and allocation is tried again. If there still isn’t enough space, then
the block is split. The name/value structures (both local and remote versions)
must be 32-bit aligned.</p><p>For attributes with small values (ie. the value can be stored within the leaf),
the <code class="literal">XFS_ATTR_LOCAL</code> flag is set for the attribute. The entry details are stored
using the <code class="literal">xfs_attr_leaf_name_local_t</code> structure. For large attribute values
that cannot be stored within the leaf, separate filesystem blocks are allocated
to store the value. They use the <code class="literal">xfs_attr_leaf_name_remote_t</code> structure.  See
<a class="link" href="#Remote_Values" title="19.5. Remote Attribute Values">Remote Values</a> for more information.</p><div class="figure"><a id="idm6796"></a><p class="title"><strong>Figure 19.2. Leaf attribute layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/69.png" alt="images/69.png" /></div></div></div><br class="figure-break" /><p>Both local and remote entries can be interleaved as they are only addressed by
the hash/index entries. The flag is stored with the hash/index pairs so the
appropriate structure can be used.</p><p>Since duplicate hash keys are possible, for each hash that matches during a
lookup, the actual name string must be compared.</p><p>An “incomplete” bit is also used for attribute flags. It shows that an attribute
is in the middle of being created and should not be shown to the user if we
crash during the time that the bit is set. The bit is cleared when attribute
has finished being set up. This is done because some large attributes cannot
be created inside a single transaction.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_leaf_attribute_example"></a>19.2.1. xfs_db Leaf Attribute Example</h3></div></div></div><p>A single 30KB extended attribute is added to an inode:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
...
core.nblocks = 9
core.nextents = 0
core.naextents = 1
core.forkoff = 15
core.aformat = 2 (extents)
...
a.bmx[0] = [startoff,startblock,blockcount,extentflag]
          0:[0,37535,9,0]
xfs_db&gt; ablock 0
xfs_db&gt; p
hdr.info.forw = 0
hdr.info.back = 0
hdr.info.magic = 0xfbee
hdr.count = 1
hdr.usedbytes = 20
hdr.firstused = 4076
hdr.holes = 0
hdr.freemap[0-2] = [base,size] 0:[40,4036] 1:[0,0] 2:[0,0]
entries[0] = [hashval,nameidx,incomplete,root,secure,local]
          0:[0xfcf89d4f,4076,0,0,0,0]
nvlist[0].valueblk = 0x1
nvlist[0].valuelen = 30692
nvlist[0].namelen = 8
nvlist[0].name = "big_attr"</pre><p>Attribute blocks 1 to 8 (filesystem blocks 37536 to 37543) contain the raw
binary value data for the attribute.</p><p>Index 4076 (0xfec) is the offset into the block where the name/value information
is. As can be seen by the value, it’s at the end of the block:</p><pre class="screen">xfs_db&gt; type text
xfs_db&gt; p

000: 00 00 00 00  00 00 00 00 fb ee 00 00 00 01 00 14 ................
010: 0f ec 00 00  00 28 0f c4 00 00 00 00 00 00 00 00 ................
020: fc f8 9d 4f  0f ec 00 00 00 00 00 00 00 00 00 00 ...O............
030: 00 00 00 00  00 00 00 00 00 00 00 00 00 00 00 00 ................
...
fe0: 00 00 00 00  00 00 00 00 00 00 00 00 00 00 00 01 ................
ff0: 00 00 77 e4  08 62 69 67 5f 61 74 74 72 00 00 00 ..w..big.attr...</pre><p>A 30KB attribute and a couple of small attributes are added to a file:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
...
core.nblocks = 10
core.extsize = 0
core.nextents = 1
core.naextents = 2
core.forkoff = 15
core.aformat = 2 (extents)
...
u.bmx[0] = [startoff,startblock,blockcount,extentflag]
          0:[0,81857,1,0]
a.bmx[0-1] = [startoff,startblock,blockcount,extentflag]
          0:[0,81858,1,0]
          1:[1,182398,8,0]
xfs_db&gt; ablock 0
xfs_db&gt; p
hdr.info.forw = 0
hdr.info.back = 0
hdr.info.magic = 0xfbee
hdr.count = 3
hdr.usedbytes = 52
hdr.firstused = 4044
hdr.holes = 0
hdr.freemap[0-2] = [base,size] 0:[56,3988] 1:[0,0] 2:[0,0]
entries[0-2] = [hashval,nameidx,incomplete,root,secure,local]
          0:[0x1e9d3934,4044,0,0,0,1]
          1:[0x1e9d3937,4060,0,0,0,1]
          2:[0xfcf89d4f,4076,0,0,0,0]
nvlist[0].valuelen = 6
nvlist[0].namelen = 5
nvlist[0].name = "attr2"
nvlist[0].value = "value2"
nvlist[1].valuelen = 6
nvlist[1].namelen = 5
nvlist[1].name = "attr1"
nvlist[1].value = "value1"
nvlist[2].valueblk = 0x1
nvlist[2].valuelen = 30692
nvlist[2].namelen = 8
nvlist[2].name = "big_attr"</pre><p>As can be seen in the entries array, the two small attributes have the local
flag set and the values are printed.</p><p>A raw disk dump shows the attributes. The last attribute added is highlighted
(offset 4044 or 0xfcc):</p><pre class="screen">000: 00 00 00 00 00 00 00 00 fb ee 00 00 00 03 00 34 ...............4
010: 0f cc 00 00 00 38 0f 94 00 00 00 00 00 00 00 00 .....8..........
020: 1e 9d 39 34 0f cc 01 00 1e 9d 39 37 0f dc 01 00 ..94......97....
030: fc f8 9d 4f 0f ec 00 00 00 00 00 00 00 00 00 00 ...0............
040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00.................
...
fc0: 00 00 00 00 00 00 00 00 00 00 00 00 <span class="strong"><strong>00 06 05 61</strong></span> ...............a
fd0: <span class="strong"><strong>74 74 72 32 76 61 6c 75 65 32</strong></span> 00 00 00 06 05 61 ttr2value2.....a
fe0: 74 74 72 31 76 61 6c 75 65 31 00 00 00 00 00 01 ttr1value1......
ff0: 00 00 77 e4 08 62 69 67 5f 61 74 74 72 00 00 00 ..w..big.attr...</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Node_Attributes"></a>19.3. Node Attributes</h2></div></div></div><p>When the number of attributes exceeds the space that can fit in one filesystem
block (ie. hash, flag, name and local values), the first attribute block becomes
the root of a B+tree where the leaves contain the hash/name/value information
that was stored in a single leaf block. The inode’s attribute format itself
remains extent based. The nodes use the <code class="literal">xfs_da_intnode_t</code> or
<code class="literal">xfs_da3_intnode_t</code> structures introduced in the section about
<a class="link" href="#Directory_Attribute_Internal_Node" title="11.2. Internal Nodes">directories</a>.</p><p>The location of the attribute leaf blocks can be in any order.  The only way to
find an attribute is by walking the node block hash/before values. Given a hash
to look up, search the node’s btree array for the first <code class="literal">hashval</code> in the array
that exceeds the given hash.  The entry is in the block pointed to by the
<code class="literal">before</code> value.</p><p>Each attribute node block has a magic number of <code class="literal">XFS_DA_NODE_MAGIC</code> (0xfebe).
On a v5 filesystem this is <code class="literal">XFS_DA3_NODE_MAGIC</code> (0x3ebe).</p><div class="figure"><a id="idm6832"></a><p class="title"><strong>Figure 19.3. Node attribute layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/72.png" alt="images/72.png" /></div></div></div><br class="figure-break" /><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_node_attribute_example"></a>19.3.1. xfs_db Node Attribute Example</h3></div></div></div><p>An inode with 1000 small attributes with the naming “attribute_n” where <span class="emphasis"><em>n</em></span> is a
number:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
...
core.nblocks = 15
core.nextents = 0
core.naextents = 1
core.forkoff = 15
core.aformat = 2 (extents)
...
a.bmx[0] = [startoff,startblock,blockcount,extentflag] 0:[0,525144,15,0]
xfs_db&gt; ablock 0
xfs_db&gt; p
hdr.info.forw = 0
hdr.info.back = 0
hdr.info.magic = 0xfebe
hdr.count = 14
hdr.level = 1
btree[0-13] = [hashval,before]
          0:[0x3435122d,1]
          1:[0x343550a9,14]
          2:[0x343553a6,13]
          3:[0x3436122d,12]
          4:[0x343650a9,8]
          5:[0x343653a6,7]
          6:[0x343691af,6]
          7:[0x3436d0ab,11]
          8:[0x3436d3a7,10]
          9:[0x3437122d,9]
          10:[0x3437922e,3]
          11:[0x3437d22a,5]
          12:[0x3e686c25,4]
          13:[0x3e686fad,2]</pre><p>The hashes are in ascending order in the btree array, and if the hash for the
attribute we are looking up is before the entry, we go to the addressed
attribute block.</p><p>For example, to lookup attribute “attribute_267”:</p><pre class="screen">xfs_db&gt; hash attribute_267
0x3437d1a8</pre><p>In the root btree node, this falls between <code class="literal">0x3437922e</code> and <code class="literal">0x3437d22a</code>,
therefore leaf 11 or attribute block 5 will contain the entry.</p><pre class="screen">xfs_db&gt; ablock 5
xfs_db&gt; p
hdr.info.forw = 4
hdr.info.back = 3
hdr.info.magic = 0xfbee
hdr.count = 96
hdr.usedbytes = 2688
hdr.firstused = 1408
hdr.holes = 0
hdr.freemap[0-2] = [base,size] 0:[800,608] 1:[0,0] 2:[0,0]
entries[0.95] = [hashval,nameidx,incomplete,root,secure,local]
          0:[0x3437922f,4068,0,0,0,1]
          1:[0x343792a6,4040,0,0,0,1]
          2:[0x343792a7,4012,0,0,0,1]
          3:[0x343792a8,3984,0,0,0,1]
          ...
          82:[0x3437d1a7,2892,0,0,0,1]
          <span class="strong"><strong>83:[0x3437d1a8,2864,0,0,0,1]</strong></span>
          84:[0x3437d1a9,2836,0,0,0,1]
          ...
          95:[0x3437d22a,2528,0,0,0,1]
nvlist[0].valuelen = 10
nvlist[0].namelen = 13
nvlist[0].name = "attribute_310"
nvlist[0].value = "value_316\d"
nvlist[1].valuelen = 16
nvlist[1].namelen = 13
nvlist[1].name = "attribute_309"
nvlist[1].value = "value_309\d"
nvlist[2].valuelen = 10
nvlist[2].namelen = 13
nvlist[2].name = "attribute_308"
nvlist[2].value = "value_308\d"
nvlist[3].valuelen = 10
nvlist[3].namelen = 13
nvlist[3].name = "attribute_307"
nvlist[3].value = "value_307\d"
...
nvlist[82].valuelen = 10
nvlist[82].namelen = 13
nvlist[82].name = "attribute_268"
nvlist[82].value = "value_268\d"
nvlist[83].valuelen = 10
nvlist[83].namelen = 13
nvlist[83].name = "attribute_267"
nvlist[83].value = "value_267\d"
nvlist[84].valuelen = 10
nvlist[84].namelen = 13
nvlist[84].name = "attribute_266"
nvlist[84].value = "value_266\d"
...</pre><p>Each of the hash entries has <code class="literal">XFS_ATTR_LOCAL</code> flag set (1), which means the
attribute’s value follows immediately after the name. Raw disk of the name/value
pair at offset 2864 (0xb30), highlighted with “value_267” following
immediately after the name:</p><pre class="screen">b00: 62 75 74 65 5f 32 36 35 76 61 6c 75 65 5f 32 36 bute.265value.26
b10: 35 0a 00 00 00 0a 0d 61 74 74 72 69 62 75 74 65 5......attribute
b20: 51 32 36 36 76 61 6c 75 65 5f 32 36 36 0a 00 00 .266value.266...
b30: <span class="strong"><strong>00 0a 0d 61 74 74 72 69 62 75 74 65 5f 32 36 37</strong></span> ...attribute.267
b40: <span class="strong"><strong>76 61 6c 75 65 5f 32 36 37 0a</strong></span> 00 00 00 0a 0d 61 value.267......a
b50: 74 74 72 69 62 75 74 65 5f 32 36 38 76 61 6c 75 ttribute.268va1u
b60: 65 5f 32 36 38 0a 00 00 00 0a 0d 61 74 74 72 69 e.268......attri
b70: 62 75 74 65 5f 32 36 39 76 61 6c 75 65 5f 32 36 bute.269value.26</pre><p>Each entry starts on a 32-bit (4 byte) boundary, therefore the highlighted entry
has 2 unused bytes after it.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Btree_Attributes"></a>19.4. B+tree Attributes</h2></div></div></div><p>When the attribute’s extent map in an inode grows beyond the available space,
the inode’s attribute format is changed to a “btree”. The inode contains root
node of the extent B+tree which then address the leaves that contains the extent
arrays for the attribute data. The attribute data itself in the allocated
filesystem blocks use the same layout and structures as described in
<a class="link" href="#Node_Attributes" title="19.3. Node Attributes">Node Attributes</a>.</p><p>Refer to the previous section on <a class="link" href="#Btree_Extent_List" title="17.2. B+tree Extent List">B+tree Data Extents</a> for
more information on XFS B+tree extents.</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_b_tree_attribute_example"></a>19.4.1. xfs_db B+tree Attribute Example</h3></div></div></div><p>Added 2000 attributes with 729 byte values to a file:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
...
core.nblocks = 640
core.extsize = 0
core.nextents = 1
core.naextents = 274
core.forkoff = 15
core.aformat = 3 (btree)
...
a.bmbt.level = 1
a.bmbt.numrecs = 2
a.bmbt.keys[1-2] = [startoff] 1:[0] 2:[219]
a.bmbt.ptrs[1-2] = 1:83162 2:109968
xfs_db&gt; fsblock 83162
xfs_db&gt; type bmapbtd
xfs_db&gt; p
magic = 0x424d4150
level = 0
numrecs = 127
leftsib = null
rightsib = 109968
recs[1-127] = [startoff,startblock,blockcount,extentflag]
          1:[0,81870,1,0]
          ...
xfs_db&gt; fsblock 109968
xfs_db&gt; type bmapbtd
xfs_db&gt; p
magic = 0x424d4150
level = 0
numrecs = 147
leftsib = 83162
rightsib = null
recs[1-147] = [startoff,startblock,blockcount,extentflag]
          ...
                             (which is fsblock 81870)
xfs_db&gt; ablock 0
xfs_db&gt; p
hdr.info.forw = 0
hdr.info.back = 0
hdr.info.magic = 0xfebe
hdr.count = 2
hdr.level = 2
btree[0-1] = [hashval,before] 0:[0x343612a6,513] 1:[0x3e686fad,512]</pre><p>The extent B+tree has two leaves that specify the 274 extents used for the
attributes. Looking at the first block, it can be seen that the attribute B+tree
is two levels deep. The two blocks at offset 513 and 512 (ie. access using the
<code class="literal">ablock</code> command) are intermediate <code class="literal">xfs_da_intnode_t</code> nodes that index all the
attribute leaves.</p></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Remote_Values"></a>19.5. Remote Attribute Values</h2></div></div></div><p>On a v5 filesystem, all remote value blocks start with this header:</p><pre class="programlisting">struct xfs_attr3_rmt_hdr {
        __be32  rm_magic;
        __be32  rm_offset;
        __be32  rm_bytes;
        __be32  rm_crc;
        uuid_t  rm_uuid;
        __be64  rm_owner;
        __be64  rm_blkno;
        __be64  rm_lsn;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>rm_magic</strong></span>
</span></dt><dd>
Specifies the magic number for the remote value block: "XARM" (0x5841524d).
</dd><dt><span class="term">
<span class="strong"><strong>rm_offset</strong></span>
</span></dt><dd>
Offset of the remote value data, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>rm_bytes</strong></span>
</span></dt><dd>
Number of bytes used to contain the remote value data.
</dd><dt><span class="term">
<span class="strong"><strong>rm_crc</strong></span>
</span></dt><dd>
Checksum of the remote value block.
</dd><dt><span class="term">
<span class="strong"><strong>rm_uuid</strong></span>
</span></dt><dd>
The UUID of this block, which must match either <code class="literal">sb_uuid</code> or <code class="literal">sb_meta_uuid</code>
depending on which features are set.
</dd><dt><span class="term">
<span class="strong"><strong>rm_owner</strong></span>
</span></dt><dd>
The inode number that this remote value block belongs to.
</dd><dt><span class="term">
<span class="strong"><strong>rm_blkno</strong></span>
</span></dt><dd>
Disk block number of this remote value block.
</dd><dt><span class="term">
<span class="strong"><strong>rm_lsn</strong></span>
</span></dt><dd>
Log sequence number of the last write to this block.
</dd></dl></div><p>Filesystems formatted prior to v5 do not have this header in the remote block.
Value data begins immediately at offset zero.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_key_differences_between_directories_and_extended_attributes"></a>19.6. Key Differences Between Directories and Extended Attributes</h2></div></div></div><p>Directories and extended attributes share the function of mapping names to
information, but the differences in the functionality requirements applied to
each type of structure influence their respective internal formats.
Directories map variable length names to iterable directory entry records
(dirent records), whereas extended attributes map variable length names to
non-iterable attribute records.  Both structures can take advantage of variable
length record btree structures (i.e the dabtree) to map name hashes, but there
are major differences in the way each type of structure integrate the dabtree
index within the information being stored.  The directory dabtree leaf nodes
contain mappings between a name hash and the location of a dirent record inside
the directory entry segment.  Extended attributes, on the other hand, store
attribute records directly in the leaf nodes of the dabtree.</p><p>When XFS adds or removes an attribute record in any dabtree, it splits or
merges leaf nodes of the tree based on where the name hash index determines a
record needs to be inserted into or removed.  In the attribute dabtree, XFS
splits or merges sparse leaf nodes of the dabtree as a side effect of inserting
or removing attribute records.</p><p>Directories, however, are subject to stricter constraints.  The userspace
readdir/seekdir/telldir directory cookie API places a requirement on the
directory structure that dirent record cookie cannot change for the life of the
dirent record.  XFS uses the dirent record’s logical offset into the directory
data segment as the cookie, and hence the dirent record cannot change location.
Therefore, XFS cannot store dirent records in the leaf nodes of the dabtree
because the offset into the tree would change as other entries are inserted and
removed.</p><p>Dirent records are therefore stored within directory data blocks, all of which
are mapped in the first directory segment.  The directory dabtree is mapped
into the second directory segment.  Therefore, directory blocks require
external free space tracking because they are not part of the dabtree itself.
Because the dabtree only stores pointers to dirent records in the first data
segment, there is no need to leave holes in the dabtree itself.  The dabtree
splits or merges leaf nodes as required as pointers to the directory data
segment are added or removed, and needs no free space tracking.</p><p>When XFS adds a dirent record, it needs to find the best-fitting free space in
the directory data segment to turn into the new record.  This requires a free
space index for the directory data segment.  The free space index is held in
the third directory segment.  Once XFS has used the free space index to find
the block with that best free space, it modifies the directory data block and
updates the dabtree to point the name hash at the new record.  When XFS removes
dirent records, it leaves hole in the data segment so that the rest of the
entries do not move, and removes the corresponding dabtree name hash mapping.</p><p>Note that for small directories, XFS collapses the name hash mappings and
the free space information into the directory data blocks to save space.</p><p>In summary, the requirement for a free space map in the directory structure
results from storing the dirent records externally to the dabtree.  Attribute
records are stored directly in the dabtree leaf nodes of the dabtree (except
for remote attribute values which can be anywhere in the attr fork address
space) and do not need external free space tracking to determine where to best
insert them.  As a result, extended attributes exhibit nearly perfect scaling
until the computer runs out of memory.</p></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Symbolic_Links"></a>Chapter 20. Symbolic Links</h2></div></div></div><p>Symbolic links to a file can be stored in one of two formats: “local” and
“extents”. The length of the symlink contents is always specified by the inode’s
<code class="literal">di_size</code> value.</p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Shortform_Symbolic_Links"></a>20.1. Short Form Symbolic Links</h2></div></div></div><p>Symbolic links are stored with the “local” <code class="literal">di_format</code> if the symbolic link can
fit within the inode’s data fork. The link data is an array of characters
(<code class="literal">di_symlink</code> array in the data fork union).</p><div class="figure"><a id="idm6937"></a><p class="title"><strong>Figure 20.1. Symbolic link short form layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/61.png" alt="images/61.png" /></div></div></div><br class="figure-break" /><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_short_form_symbolic_link_example"></a>20.1.1. xfs_db Short Form Symbolic Link Example</h3></div></div></div><p>A short symbolic link to a file is created:</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
core.magic = 0x494e
core.mode = 0120777
core.version = 1
core.format = 1 (local)
...
core.size = 12
core.nblocks = 0
core.extsize = 0
core.nextents = 0
...
u.symlink = "small_target"</pre><p>Raw on-disk data with the link contents highlighted:</p><pre class="screen">xfs_db&gt; type text
xfs_db&gt; p
00: 49 4e a1 ff 01 01 00 01 00 00 00 00 00 00 00 00 IN..............
10: 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00 01 ................
20: 44 be e1 c7 03 c4 d4 18 44 be el c7 03 c4 d4 18 D.......D.......
30: 44 be e1 c7 03 c4 d4 18 00 00 00 00 00 00 00 Oc D...............
40: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
50: 00 00 00 02 00 00 00 00 00 00 00 00 00 00 00 00 ................
60: ff ff ff ff <span class="strong"><strong>73 6d 61 6c 6c 5f 74 61 72 67 65 74</strong></span> ....small.target
70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................</pre></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="Extent_Symbolic_Links"></a>20.2. Extent Symbolic Links</h2></div></div></div><p>If the length of the symbolic link exceeds the space available in the inode’s
data fork, the link is moved to a new filesystem block and the inode’s
<code class="literal">di_format</code> is changed to “extents”. The location of the block(s) is specified
by the data fork’s <code class="literal">di_bmx[]</code> array. In the significant majority of cases, this
will be in one filesystem block as a symlink cannot be longer than 1024
characters.</p><p>On a v5 filesystem, the first block of each extent starts with the following
header structure:</p><pre class="programlisting">struct xfs_dsymlink_hdr {
     __be32                    sl_magic;
     __be32                    sl_offset;
     __be32                    sl_bytes;
     __be32                    sl_crc;
     uuid_t                    sl_uuid;
     __be64                    sl_owner;
     __be64                    sl_blkno;
     __be64                    sl_lsn;
};</pre><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>sl_magic</strong></span>
</span></dt><dd>
Specifies the magic number for the symlink block: "XSLM" (0x58534c4d).
</dd><dt><span class="term">
<span class="strong"><strong>sl_offset</strong></span>
</span></dt><dd>
Offset of the symbolic link target data, in bytes.
</dd><dt><span class="term">
<span class="strong"><strong>sl_bytes</strong></span>
</span></dt><dd>
Number of bytes used to contain the link target data.
</dd><dt><span class="term">
<span class="strong"><strong>sl_crc</strong></span>
</span></dt><dd>
Checksum of the symlink block.
</dd><dt><span class="term">
<span class="strong"><strong>sl_uuid</strong></span>
</span></dt><dd>
The UUID of this block, which must match either <code class="literal">sb_uuid</code> or <code class="literal">sb_meta_uuid</code>
depending on which features are set.
</dd><dt><span class="term">
<span class="strong"><strong>sl_owner</strong></span>
</span></dt><dd>
The inode number that this symlink block belongs to.
</dd><dt><span class="term">
<span class="strong"><strong>sl_blkno</strong></span>
</span></dt><dd>
Disk block number of this symlink.
</dd><dt><span class="term">
<span class="strong"><strong>sl_lsn</strong></span>
</span></dt><dd>
Log sequence number of the last write to this block.
</dd></dl></div><p>Filesystems formatted prior to v5 do not have this header in the remote block.
Symlink data begins immediately at offset zero.</p><div class="figure"><a id="idm7002"></a><p class="title"><strong>Figure 20.2. Symbolic link extent layout</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/62.png" alt="images/62.png" /></div></div></div><br class="figure-break" /><div class="section"><div class="titlepage"><div><div><h3 class="title"><a id="_xfs_db_symbolic_link_extent_example"></a>20.2.1. xfs_db Symbolic Link Extent Example</h3></div></div></div><p>A longer link is created (greater than 156 bytes):</p><pre class="screen">xfs_db&gt; inode &lt;inode#&gt;
xfs_db&gt; p
core.magic = 0x494e
core.mode = 0120777
core.version = 1
core.format = 2 (extents)
...
core.size = 182
core.nblocks = 1
core.extsize = 0
core.nextents = 1
...
u.bmx[0] = [startoff,startblock,blockcount,extentflag] 0:[0,37530,1,0]
xfs_db&gt; dblock 0
xfs_db&gt; type symlink
xfs_db&gt; p
"symlink contents..."</pre></div></div></div></div><div class="part"><div class="titlepage"><div><div><h1 class="title"><a id="_auxiliary_data_structures"></a>Part IV. Auxiliary Data Structures</h1></div></div></div><div class="chapter"><div class="titlepage"><div><div><h2 class="title"><a id="Metadata_Dumps"></a>Chapter 21. Metadata Dumps</h2></div></div></div><p>The <code class="literal">xfs_metadump</code> and <code class="literal">xfs_mdrestore</code> tools are used to create a sparse
snapshot of a live file system and to restore that snapshot onto a block
device for debugging purposes.  Only the metadata are captured in the
snapshot, and the metadata blocks may be obscured for privacy reasons.</p><p>A metadump file starts with a <code class="literal">xfs_metablock</code> that records the addresses of
the blocks that follow.  Following that are the metadata blocks captured
from the filesystem.  The first block following the first superblock
must be the superblock from AG 0.  If the metadump has more blocks than
can be pointed to by the <code class="literal">xfs_metablock.mb_daddr</code> area, the sequence
of <code class="literal">xfs_metablock</code> followed by metadata blocks is repeated.</p><p><strong>Metadata Dump Format. </strong>
</p><pre class="programlisting">struct xfs_metablock {
        __be32          mb_magic;
        __be16          mb_count;
        uint8_t         mb_blocklog;
        uint8_t         mb_reserved;
        __be64          mb_daddr[];
};</pre><p>
</p><div class="variablelist"><dl class="variablelist"><dt><span class="term">
<span class="strong"><strong>mb_magic</strong></span>
</span></dt><dd>
The magic number, “XFSM” (0x5846534d).
</dd><dt><span class="term">
<span class="strong"><strong>mb_count</strong></span>
</span></dt><dd>
Number of blocks indexed by this record.  This value must not exceed <code class="literal">(1
&lt;&lt; mb_blocklog) - sizeof(struct xfs_metablock)</code>.
</dd><dt><span class="term">
<span class="strong"><strong>mb_blocklog</strong></span>
</span></dt><dd>
The log size of a metadump block.  This size of a metadump block 512
bytes, so this value should be 9.
</dd><dt><span class="term">
<span class="strong"><strong>mb_reserved</strong></span>
</span></dt><dd>
Reserved.  Should be zero.
</dd><dt><span class="term">
<span class="strong"><strong>mb_daddr</strong></span>
</span></dt><dd>
An array of disk addresses.  Each of the <code class="literal">mb_count</code> blocks (of size <code class="literal">(1
&lt;&lt; mb_blocklog</code>) following the <code class="literal">xfs_metablock</code> should be written back to
the address pointed to by the corresponding <code class="literal">mb_daddr</code> entry.
</dd></dl></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="_dump_obfuscation"></a>21.1. Dump Obfuscation</h2></div></div></div><p>Unless explicitly disabled, the <code class="literal">xfs_metadump</code> tool obfuscates empty block
space and naming information to avoid leaking sensitive information into
the metadump file.  <code class="literal">xfs_metadump</code> does not copy user data blocks.</p><p>The obfuscation policy is as follows:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem">
File and extended attribute names are both considered "names".
</li><li class="listitem">
Names longer than 8 characters are totally rewritten with a name that matches the hash of the old name.
</li><li class="listitem">
Names between 5 and 8 characters are partially rewritten to match the hash of the old name.
</li><li class="listitem">
Names shorter than 5 characters are not obscured at all.
</li><li class="listitem">
Names that cross a block boundary are not obscured at all.
</li><li class="listitem">
Extended attribute values are zeroed.
</li><li class="listitem">
Empty parts of metadata blocks are zeroed.
</li></ul></div></div></div></div></div></body></html>